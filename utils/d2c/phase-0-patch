diff -ur clisp/src/charstrg.d clisp-conversion/src/charstrg.d
--- clisp/src/charstrg.d	Mon Feb 24 19:14:54 2003
+++ clisp-conversion/src/charstrg.d	Sat Mar  1 15:17:01 2003
@@ -7,40 +7,6 @@
 
 #include "lispbibl.c"
 
-/* character conversion tables: */
-#if defined(UNICODE)
-/* here are the registered bijective case (small<-->CAP) transformations
- for Unicode. */
-#elif defined(ISOLATIN_CHS)
-/* here are the registered bijective case (small<-->CAP) transformations
-  small 61 ... 7A E0 ... F6 F8 ... FE
-  CAP   41 ... 5A C0 ... D6 D8 ... DE
-  both  aA ... zZ àÀ ... öÖ øØ ... þÞ */
-#elif defined(HPROMAN8_CHS)
-/* here are the registered bijective case (small<-->CAP) transformations
-  small 61 ... 7A C4 C5 D5 C6 C7 B2 C0 C1 D1 C2 C3 C8 C9 D9 CA CB
-  CAP   41 ... 5A E0 DC E5 E7 ED B1 A2 A4 A6 DF AE A1 A3 E6 E8 AD
-  which aA ... zZ áÁ éÉ íÍ óÓ úÚ ýÝ âÂ êÊ îÎ ôÔ ûÛ àÀ èÈ ìÌ òÒ ùÙ
-  small CC CD DD CE CF EF E2 B7 EA D4 D7 D6 B5 EC E4 F1
-  CAP   D8 A5 A7 DA DB EE E1 B6 E9 D0 D3 D2 B4 EB E3 F0
-  which äÄ ëË ïÏ öÖ üÜ ÿŸ ãÃ ñÑ õÕ åÅ æÆ øØ çÇ šŠ ðÐ þÞ */
-#elif defined(NEXTSTEP_CHS)
-/* here are the registered bijective case (small<-->CAP) transformations
- small 61 ... 7A D5 ... E0 E2 E4 ... E7 EC ... F0 F1 F2 .. F4 F6 F7 F9 FA FC
- CAP   41 ... 5A 81 ... 8C 8D 8E ... 91 92 ... 96 E1 97 .. 99 9A 9B E9 EA 9C
- which aA ... zZ àÀ ... ìÌ íÍ îÎ ... ñÑ òÒ ... öÖ æÆ ùÙ .. ûÛ üÜ ýÝ øØ œŒ þÞ */
-#elif defined(IBMPC_CHS)
-/* here are the registered bijective case (small<-->CAP) transformations
-  small 61 ... 7A 87 81 82 84 86 91 94 A4
-  CAP   41 ... 5A 80 9A 90 8E 8F 92 99 A5
-  both  aA ... zZ çÇ üÜ éÉ äÄ åÅ æÆ öÖ ñÑ */
-#else /* defined(ASCII_CHS) */
-/* here are the registered bijective case (small<-->CAP) transformations
-  small 61 ... 7A
-  CAP   41 ... 5A
-  both  aA ... zZ */
-#endif
-
 #ifdef UNICODE
 /* No-conversion table, used by up_case_table and down_case_table. */
 static const uint16 nop_page[256] = {
@@ -1180,13 +1146,14 @@
     /* obj is a symbol */
     obj = TheSymbol(obj)->pname; goto string;
   } else if (stringp(obj)) {
-   string: /* obj is a string */
+   string: { /* obj is a string */
     var uintL len;
     var uintL offset;
     var object string = unpack_string_ro(obj,&len,&offset);
     /* at ptr are len characters */
     if (len==1)
       return code_char(schar(string,offset));
+   }
   } else if (nullpSv(coerce_fixnum_char_ansi) && posfixnump(obj)) {
     var uintL code = posfixnum_to_L(obj);
     if (code < char_code_limit)
diff -ur clisp/src/compelem.d clisp-conversion/src/compelem.d
--- clisp/src/compelem.d	Mon Dec 16 20:25:13 2002
+++ clisp-conversion/src/compelem.d	Sat Mar  1 15:17:01 2003
@@ -542,9 +542,11 @@
           }
         }
         # beide Komponenten zu einer komplexen Zahl zusammenfügen:
-        var object a = STACK_1;
+        {
+         var object a = STACK_1;
         var object b = STACK_0;
         skipSTACK(2); return R_R_complex_C(a,b);
+        }
       }
     }
   #define C_durch_C  N_durch_N
@@ -865,7 +867,8 @@
         var object b = TheComplex(x)->c_imag;
         pushSTACK(b); pushSTACK(a);
         var object r = R_R_hypot_R(a,b); # r = (abs x)
-        var object a = STACK_0;
+        {
+         var object a = STACK_0;
         if (!R_minusp(a)) {
           # a>=0
           var object c = # sqrt((r+a)/2)
@@ -889,6 +892,7 @@
           d = R_R_complex_C(d,STACK_0); # c+di
           skipSTACK(2); return d; # als Ergebnis
         }
+        }
       }
     }
 
diff -ur clisp/src/comptran.d clisp-conversion/src/comptran.d
--- clisp/src/comptran.d	Fri Dec 20 12:15:36 2002
+++ clisp-conversion/src/comptran.d	Sat Mar  1 15:17:01 2003
@@ -176,10 +176,11 @@
           if (R_rationalp(b))
             b = RA_F_float_F(b,STACK_0);
           b = F_ln_F(b,true,&STACK_2); STACK_0 = F_F_durch_F(STACK_0,b);
-         real_ok:
+        real_ok: {
           # Stackaufbau: a, b, Imaginärteil, Realteil.
           var object erg = R_R_complex_C(STACK_0,STACK_1);
           skipSTACK(4); return erg;
+          }
         }
       } else { /* normal complex case */
         pushSTACK(a); pushSTACK(b);
@@ -341,7 +342,7 @@
             }
           } else {
             if (R_rationalp(TheComplex(x)->c_real) && R_rationalp(TheComplex(x)->c_imag)) {
-             complex_rational: # x in Q(i)
+             complex_rational: { # x in Q(i)
               var uintL k = I_power2p(TheRatio(y)->rt_den);
               if (!(k==0)) {
                 # n Zweierpotenz = 2^(k-1). n>1, also k>1
@@ -349,6 +350,7 @@
                 dotimespL(k,k-1, { x = N_sqrt_N(x); } ); # k-1 mal Quadratwurzel
                 return N_I_expt_N(x,popSTACK()); # dann hoch m
               }
+             }
             }
           }
           if (I_fixnump(TheRatio(y)->rt_num) # |m| klein
diff -ur clisp/src/control.d clisp-conversion/src/control.d
--- clisp/src/control.d	Thu Feb 27 21:19:45 2003
+++ clisp-conversion/src/control.d	Sat Mar  1 15:17:01 2003
@@ -37,11 +37,12 @@
   VALUES1(NIL);
   skipSTACK(2);
   return;
- found: /* symbol EVAL found */
+ found: { /* symbol EVAL found */
   var object body = popSTACK();
   skipSTACK(1);
   implicit_progn(body,NIL); /* evaluate body */
 }
+}
 
 LISPSPECFORM(quote, 1,0,nobody)
 { /* (QUOTE object) == 'object, CLTL p. 86 */
@@ -1157,11 +1158,12 @@
   /* no condition was fulfilled. */
   VALUES1(NIL); skipSTACK(1); return;
   /* fulfilled condition found: */
- eval_clause:
+ eval_clause: {
   var object clause_rest = popSTACK(); /* clause rest */
   skipSTACK(1);
   implicit_progn(clause_rest,value1); /* evaluate */
 }
+}
 
 LISPSPECFORM(case, 1,0,body)
 { /* (CASE keyform {(keys {form})}), CLTL p. 117 */
@@ -1202,10 +1204,11 @@
   /* no condition was fulfilled. */
   VALUES1(NIL); return;
   /* fulfilled condition found: */
- eval_clause:
+ eval_clause: {
   var object clause_rest = Cdr(clause); /* clause-rest */
   implicit_progn(clause_rest,NIL); /* evaluate */
 }
+}
 
 LISPSPECFORM(block, 1,0,body)
 { /* (BLOCK name {form}), CLTL p. 119 */
diff -ur clisp/src/dfloat.d clisp-conversion/src/dfloat.d
--- clisp/src/dfloat.d	Tue Jan  7 08:45:19 2003
+++ clisp-conversion/src/dfloat.d	Sat Mar  1 15:17:01 2003
@@ -1409,7 +1409,7 @@
  }
   DOCONSTTIMES(32/intDsize,NEXT_DIGIT);
  #undef NEXT_DIGIT
-  --len; ok:
+  --len; ok: {
   /* the NDS consists of msd, msdd, msddf and len further digits.
      the highest set bit in 2^64*msd+2^32*msdd+msddf is bit number
      63 + (exp mod intDsize). */
@@ -1466,6 +1466,7 @@
   }
   encode2_DF(sign,(sintL)exp,manthi,mantlo, return);
  #endif
+  }
 }
 
 /* RA_to_DF(x) converts a rational number x into a Double-Float
diff -ur clisp/src/eval.d clisp-conversion/src/eval.d
--- clisp/src/eval.d	Thu Feb 27 21:19:46 2003
+++ clisp-conversion/src/eval.d	Sat Mar  1 15:17:01 2003
@@ -1107,7 +1107,7 @@
         var uintL depth = 0; # recursion depth := 0
         # pseudo-recursion: nests a GO_ENV.
         # Input: env, a GO_ENV. Output: env, with Alist.
-       nest_go_start: # start of recursion
+       nest_go_start: { # start of recursion
         var gcv_object_t* FRAME;
         if (framepointerp(env)) {
           # env is a pointer into the STACK to a ITAGBODY-frame.
@@ -1165,13 +1165,14 @@
           goto nest_go_reentry;
         env5->go_env = env; # file nested GO_ENV
       }
+      }
       # BLOCK_ENV:
       {
         var object env = env5->block_env;
         var uintL depth = 0; # recursion depth := 0
         # Pseudo-Recursion: nests a BLOCK_ENV.
         # Input: env, a BLOCK_ENV. Output: env, with Aliste.
-       nest_block_start: # start of recursion
+       nest_block_start: { # start of recursion
         var gcv_object_t* FRAME;
         if (framepointerp(env)) {
           # env is a pointer into the STACK to a IBLOCK-Frame.
@@ -1210,6 +1211,7 @@
           goto nest_block_reentry;
         env5->block_env = env; # file nested BLOCK_ENV
       }
+}
       # FUN_ENV:
       env5->fun_env = nest_fun(env5->fun_env);
       # VAR_ENV:
@@ -3439,7 +3441,7 @@
         }
       } else {
         # SUBR with Keywords.
-       apply_subr_key:
+       apply_subr_key: {
         # args = remaining argument-list (not yet finished)
         # First initialize the Keyword-parameters with #<UNBOUND> , then
         # evaluate the remaining arguments and push into Stack, then
@@ -3465,6 +3467,7 @@
         # assign Keywords and poss. discard remaining arguments:
         match_subr_key(fun,argcount,key_args_pointer,rest_args_pointer);
       }
+      }
      los: # call function
       # remaining argument-list must be NIL :
       if (!nullp(args)) goto fehler_dotted;
@@ -3986,7 +3989,7 @@
       #ifdef DYNAMIC_FFI
       elif (ffunctionp(fun)) { # Foreign-Function ?
         # call (SYS::FOREIGN-CALL-OUT foreign-function . args)
-       call_ffunction:
+      call_ffunction: {
         # Therefore first shift down the arguments in Stack by 1.
         var uintC count;
         var gcv_object_t* ptr = &STACK_0;
@@ -3996,6 +3999,7 @@
         *(ptr STACKop -1) = fun;
         skipSTACK(-1);
         return_Values apply_subr(L(foreign_call_out),args_on_stack+1,other_args);
+        }
       }
       #endif
       else if (consp(fun) && eq(Car(fun),S(lambda))) /* Cons (LAMBDA ...) ? */
@@ -4895,7 +4899,7 @@
       #ifdef DYNAMIC_FFI
       elif (ffunctionp(fun)) { # Foreign-Function ?
         # call (SYS::FOREIGN-CALL-OUT foreign-function . args)
-       call_ffunction:
+       call_ffunction: {
         # First shift down the arguments in Stack by 1.
         var uintC count;
         var gcv_object_t* ptr = &STACK_0;
@@ -4906,6 +4910,7 @@
         skipSTACK(-1);
         return_Values funcall_subr(L(foreign_call_out),args_on_stack+1);
       }
+      }
       #endif
       else if (consp(fun) && eq(Car(fun),S(lambda))) /* Cons (LAMBDA ...) ? */
         fehler_lambda_expression(S(funcall),fun);
@@ -7328,7 +7333,8 @@
             U_operand(k2);
             U_operand(n);
             U_operand(l);
-            var gcv_object_t* FRAME = (gcv_object_t*) SP_(k1+jmpbufsize*k2);
+            {
+             var gcv_object_t* FRAME = (gcv_object_t*) SP_(k1+jmpbufsize*k2);
             var object tagbody_cons = FRAME_(n);
             if (eq(Cdr(tagbody_cons),disabled)) {
               var object tag_vector = Car(tagbody_cons);
@@ -7340,7 +7346,7 @@
             }
             # value passed to Tagbody:
             # For CTAGBODY-Frames 1+l as Fixnum.
-            var gcv_object_t* FRAME = uTheFramepointer(Cdr(tagbody_cons));
+           { var gcv_object_t* FRAME = uTheFramepointer(Cdr(tagbody_cons));
             VALUES1(fixnum(1+l));
             # unwind upto Tagbody-Frame, then jump to its Routine,
             # which then jumps to Label l:
@@ -7349,6 +7355,8 @@
             #endif
             unwind_upto(FRAME);
           }
+          }
+          }
         # ------------------- (12) CATCH and THROW -----------------------
         CASE cod_catch_open:             # (CATCH-OPEN label)
           # occupies 3 STACK-Entries and 1 SP-jmp_buf-Entry and 2 SP-Entries
diff -ur clisp/src/ffloat.d clisp-conversion/src/ffloat.d
--- clisp/src/ffloat.d	Tue Dec 17 03:26:11 2002
+++ clisp-conversion/src/ffloat.d	Sat Mar  1 15:17:01 2003
@@ -791,7 +791,7 @@
         }
       DOCONSTTIMES(32/intDsize,NEXT_DIGIT);
       #undef NEXT_DIGIT
-      --len; ok:
+      --len; ok: {
       # Die NDS besteht aus msd, msdd, und len weiteren Digits.
       # Das höchste in 2^32*msd+msdd gesetzte Bit ist Bit Nummer
       # 31 + (exp mod intDsize).
@@ -820,6 +820,7 @@
         }
       }
       encode_FF(sign,(sintL)exp,mant, return);
+      }
     }
 
 # RA_to_FF(x) wandelt eine rationale Zahl x in ein Single-Float um
diff -ur clisp/src/foreign.d clisp-conversion/src/foreign.d
--- clisp/src/foreign.d	Mon Feb 24 19:15:00 2003
+++ clisp-conversion/src/foreign.d	Sat Mar  1 15:17:01 2003
@@ -2370,7 +2370,7 @@
           cumul_size += data_size;
         }
         goto bad_slot;
-       found_struct_slot:
+       found_struct_slot: {
         var uintL size = data_size;
         pushSTACK(make_faddress(TheFaddress(TheFvariable(fvar)->fv_address)->fa_base,
                                 TheFaddress(TheFvariable(fvar)->fv_address)->fa_offset
@@ -2386,6 +2386,7 @@
         VALUES1(new_fvar);
         skipSTACK(2);
         return;
+        }
       }
       if (eq(TheSvector(fvd)->data[0],S(c_union)) && (fvdlen > 1)) {
         var object slots = TheSvector(fvd)->data[1];
diff -ur clisp/src/intdiv.d clisp-conversion/src/intdiv.d
--- clisp/src/intdiv.d	Thu Aug 23 09:08:29 2001
+++ clisp-conversion/src/intdiv.d	Sat Mar  1 15:17:01 2003
@@ -155,7 +155,7 @@
             num_stack_need(b_len,b_MSDptr=,b_LSDptr=);
             shiftleftcopy_loop_down(old_b_LSDptr,b_LSDptr,b_len,s);
           }
-       shift_ok:
+      shift_ok: {
         # Wieder b = b_MSDptr/b_len/b_LSDptr.
         # Kopiere a und schiebe es dabei um s Bits nach links, erhalte r:
         var uintD* r_MSDptr = roomptr;
@@ -278,6 +278,7 @@
         r_->MSDptr = r_MSDptr; r_->len = b_len; r_->LSDptr = r_LSDptr;
         RESTORE_NUM_STACK # num_stack zurück
         return;
+        }
       }
     }
 
diff -ur clisp/src/intlog.d clisp-conversion/src/intlog.d
--- clisp/src/intlog.d	Fri Sep 20 08:52:48 2002
+++ clisp-conversion/src/intlog.d	Sat Mar  1 15:17:01 2003
@@ -683,11 +683,12 @@
 {
   if (I_fixnump(x)) {
     var uint16 x16; /* auxiliary variable */
-    var uint32 x32 = FN_to_L(x); /* x as 32-bit-number */
+    { var uint32 x32 = FN_to_L(x); /* x as 32-bit-number */
     if (FN_L_minusp(x,(sint32)x32))
       x32 = ~ x32; /* if <0, make 1-complement */
     logcount_32(); /* count bits of x32 */
     return fixnum((uintL)x16);
+    }
   } else {
     var uintD* MSDptr;
     var uintC len;
@@ -714,10 +715,12 @@
    #if (intDsize==32)
     dotimespC(len,len, {
       var uint16 x16; /* auxiliary variable */
-      var uintD x32 = (*ptr++) ^ sign; /* next intDsize-bit-package, */
+      {
+        var uintD x32 = (*ptr++) ^ sign; /* next intDsize-bit-package, */
       /* negative numbers are complemented */
       /* count bits of x32, increase total counter: */
       bitcount += (uintL)(logcount_32(), x16);
+    }
     });
    #endif
     /* 0 <= bitcount < intDsize*2^intWCsize, fits poss. into a fixnum. */
diff -ur clisp/src/intplus.d clisp-conversion/src/intplus.d
--- clisp/src/intplus.d	Fri Mar 30 03:35:11 2001
+++ clisp-conversion/src/intplus.d	Sat Mar  1 15:17:01 2003
@@ -155,7 +155,7 @@
       } else {
         # x ist Bignum
         if (I_fixnump(y)) {
-         xBN_yFN:
+        xBN_yFN: {
           # x ist Bignum, y ist Fixnum, also x länger
           var sint32 y_ = FN_to_L(y); # Wert von y
           if (FN_L_zerop(y,y_))
@@ -194,6 +194,7 @@
             RESTORE_NUM_STACK # num_stack zurück
             return result;
           }
+        }
         } else {
           # x und y sind Bignums
           SAVE_NUM_STACK # num_stack retten
diff -ur clisp/src/intsqrt.d clisp-conversion/src/intsqrt.d
--- clisp/src/intsqrt.d	Thu Mar 21 07:23:13 2002
+++ clisp-conversion/src/intsqrt.d	Sat Mar  1 15:17:01 2003
@@ -517,7 +517,8 @@
         }
       }
       # Nun ist n < (integer-length x). Also passt n in ein uintL.
-      var uintL n = I_to_UL(popSTACK());
+      {
+        var uintL n = I_to_UL(popSTACK());
       var object x = popSTACK();
       while ((n % 2) == 0) { # n gerade?
         x = I_sqrtp(x); # Quadratwurzel ziehen versuchen
@@ -685,4 +686,5 @@
         skipSTACK(2); return temp;
       }
     }
+    }
 
diff -ur clisp/src/io.d clisp-conversion/src/io.d
--- clisp/src/io.d	Fri Feb 28 15:49:45 2003
+++ clisp-conversion/src/io.d	Sat Mar  1 15:17:01 2003
@@ -3868,7 +3868,7 @@
       and_or_flag = 0; goto and_or;
     } else if (string_gleich(opname,Symbol_name(S(or)))) { # expr = (OR ...)
       and_or_flag = ~0;
-    and_or:
+      and_or: {
       # interprete the list-elements of expr, until there is a
       # result /=and_or_flag. Default is and_or_flag.
       var object list = Cdr(expr);
@@ -3881,6 +3881,7 @@
       if (nullp(list))
         return and_or_flag;
       # expr was a Dotted List -> error
+        }
     } else if (string_gleich(opname,Symbol_name(S(not)))) {
       # expr = (NOT ...) is to be of the shape (NOT obj):
       var object opargs = Cdr(expr);
diff -ur clisp/src/package.d clisp-conversion/src/package.d
--- clisp/src/package.d	Mon Feb 24 19:15:10 2003
+++ clisp-conversion/src/package.d	Sat Mar  1 15:17:01 2003
@@ -648,10 +648,11 @@
     funcall(S(format),3); /* (FORMAT stream ... option-list) */
     terpri(stream_);
   }
- antwort_ok:
+ antwort_ok: {
   var object mlistr = popSTACK(); /* last option-list */
   skipSTACK(3); /* answer, forget stream and option-list */
   return Car(mlistr); /* chosen option */
+  }
 }
 
 /* UP: searches a package of given name or nickname
@@ -1842,7 +1843,7 @@
     fehler(package_error,GETTEXT("~: Package ~ has been deleted."));
   }
   if (stringp(obj)) {
-  string: /* string -> search package with name obj: */
+  string: { /* string -> search package with name obj: */
     var object pack = find_package(obj);
     if (!nullp(pack))
       return pack;
@@ -1850,6 +1851,7 @@
     pushSTACK(obj); pushSTACK(TheSubr(subr_self)->name);
     fehler(package_error,GETTEXT("~: There is no package with name ~"));
   }
+  }
   if (symbolp(obj)) { /* symbol -> */
     obj = Symbol_name(obj); goto string; /* use print name */
   }
@@ -2467,7 +2469,7 @@
       VALUES1(NIL); return; /* already deleted -> 1 value NIL */
     }
   } else if (stringp(pack)) {
-  string: /* string -> search package with this name: */
+  string: { /* string -> search package with this name: */
     var object found = find_package(pack);
     if (nullp(found)) {
       /* raise Continuable Error: */
@@ -2487,6 +2489,7 @@
       return;
     }
     pack = found;
+  }
   } else if (symbolp(pack)) { /* symbol -> */
     pack = Symbol_name(pack); goto string; /* use printname */
   } else if (charp(pack)) { /* character -> */
Only in clisp-conversion/src: package.d.orig
diff -ur clisp/src/pathname.d clisp-conversion/src/pathname.d
--- clisp/src/pathname.d	Mon Feb 24 19:15:11 2003
+++ clisp-conversion/src/pathname.d	Sat Mar  1 15:17:01 2003
@@ -10400,7 +10400,7 @@
     }
   } else {
     pathname = coerce_pathname(pathname); # turn into a pathname
-  is_pathname: # pathname is now really a pathname
+  is_pathname: { # pathname is now really a pathname
     var object namestring = true_namestring(pathname,true,false);
    #ifdef EMUNIX
     with_sstring_0(namestring,O(pathname_encoding),namestring_asciz, {
@@ -10441,6 +10441,9 @@
    #endif
     skipSTACK(1);
   }
+  }
+
+
   # date/time no is in the buffer file_datetime.
   # convert into Universal-Time-Format:
  #if defined(UNIX) || defined(EMUNIX) || defined(AMIGAOS) || defined(RISCOS)
@@ -10470,7 +10473,7 @@
     }
   } else {
     pathname = coerce_pathname(pathname); # turn into a pathname
-  is_pathname: # pathname is now really a pathname
+  is_pathname: { # pathname is now really a pathname
     var object namestring = true_namestring(pathname,true,false);
   #ifdef MSDOS
    #if 1
@@ -10505,6 +10508,7 @@
    #endif
     skipSTACK(1);
   }
+  }
   # file exists -> NIL as value
   VALUES1(NIL);
 }
Only in clisp-conversion/src: pathname.d.orig
diff -ur clisp/src/sfloat.d clisp-conversion/src/sfloat.d
--- clisp/src/sfloat.d	Fri Mar 30 03:35:11 2001
+++ clisp-conversion/src/sfloat.d	Sat Mar  1 15:17:01 2003
@@ -675,7 +675,7 @@
         }
       DOCONSTTIMES(32/intDsize,NEXT_DIGIT);
       #undef NEXT_DIGIT
-      --len; ok:
+      --len; ok: {
       # Die NDS besteht aus msd, msdd, und len weiteren Digits.
       # Das höchste in 2^32*msd+msdd gesetzte Bit ist Bit Nummer
       # 31 + (exp mod intDsize).
@@ -704,6 +704,7 @@
         }
       }
       encode_SF(sign,(sintL)exp,mant, return);
+      }
     }
 
 # RA_to_SF(x) wandelt eine rationale Zahl x in ein Short-Float um
diff -ur clisp/src/socket.d clisp-conversion/src/socket.d
--- clisp/src/socket.d	Mon Feb 24 19:15:14 2003
+++ clisp-conversion/src/socket.d	Sat Mar  1 15:17:01 2003
@@ -797,7 +797,7 @@
      #if defined(WIN32_NATIVE)
       ret = interruptible_socket_wait(fd,socket_wait_write,tvp);
      #else
-     restart_select:
+    restart_select: {
       var fd_set handle_set;
       FD_ZERO(&handle_set); FD_SET(fd,&handle_set);
       ret = select(FD_SETSIZE,NULL,&handle_set,NULL,tvp);
@@ -811,6 +811,7 @@
        return INVALID_SOCKET;
      }
     }
+    }
     { /* connected - restore blocking IO */
       var int non_blocking_io = 0;
       if (ioctl(fd,FIONBIO,&non_blocking_io) == 0)
diff -ur clisp/src/stream.d clisp-conversion/src/stream.d
--- clisp/src/stream.d	Mon Feb 24 19:15:20 2003
+++ clisp-conversion/src/stream.d	Sat Mar  1 15:17:01 2003
@@ -4754,7 +4754,7 @@
     # file (or pipe)
     {
       # try to read a byte:
-    restart_read_other:
+restart_read_other: {
       var uintB b;
       var int result = read(handle,&b,1);
       if (result<0) {
@@ -4770,6 +4770,7 @@
         return ls_avail;
       }
     }
+}
   #elif defined(AMIGAOS)
   begin_system_call();
   if (tty_p) { # interactive
@@ -5042,7 +5043,7 @@
   var object stream = *stream_;
   if (eq(TheStream(stream)->strm_rd_ch_last,eof_value)) # already EOF?
     return eof_value;
- retry:
+retry: {
   var chart c;
   #ifdef UNICODE
   var object encoding = TheStream(stream)->strm_encoding;
@@ -5099,6 +5100,7 @@
   }
   return code_char(c);
 }
+}
 
 # Determines, if a character is available on an Unbuffered-Channel-Stream.
 # listen_char_unbuffered(stream)
@@ -8654,7 +8656,7 @@
 
 # cf. rd_ch_unbuffered() :
 local object rd_ch_keyboard (const gcv_object_t* stream_) {
- restart_it:
+ restart_it: {
   var object stream = *stream_;
   if (eq(TheStream(stream)->strm_rd_ch_last,eof_value)) # EOF already?
     return eof_value;
@@ -8860,6 +8862,7 @@
     }
   }
 }
+}
 
 # UP: extends the List STACK_0 by one key-assignment.
 # can trigger GC
@@ -11237,7 +11240,7 @@
 
 # output of a character, directly.
 local void out_char (uintB c) {
- restart_it:
+ restart_it: {
   var int result = write(stdout_handle,&c,1); # try to write character
   if (result<0) {
     if (errno==EINTR)
@@ -11249,6 +11252,7 @@
     fehler(file_error,GETTEXT("cannot output to standard output"));
   }
 }
+}
 
 # output of a Capability-String.
 local void out_capstring (const char* s) {
@@ -14598,7 +14602,7 @@
   pushSTACK(TheSubr(subr_self)->name);
   fehler(type_error,GETTEXT("~: argument ~ is neither an open SOCKET-STREAM nor a positive FIXNUM"));
 
- doit:
+ doit: {
   var SOCKET sk;
   var host_data_t myname;
   begin_system_call();
@@ -14620,6 +14624,7 @@
   VALUES1(popSTACK());
   skipSTACK(2);
 }
+}
 
 # (SOCKET-SERVER-PORT socket-server)
 LISPFUNN(socket_server_port,1) {
Only in clisp-conversion/src: stream.d.orig
