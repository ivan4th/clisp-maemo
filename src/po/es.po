# Mensajes en español para GNU CLISP.
# Copyright (C) 1996 Free Software Foundation, Inc.
# Carlos Linares López <clinares@delicias.dia.fi.upm.es>, 1997.
#
# Han contribuido a esta traducción:
#
# cll - Carlos Linares López 	(Traducción)
# sv  - Santiago Vila Doncel	(Revisión)
# lsg - Leonardo Sarasúa García	(Traducción y Revisión)
#
# Agradecimientos especiales a:
#
# Bruno Haible
# Marcus Daniels
# 					(Programadores de CLisp)
#
# Enrique Melero
# 				    (Coordinador de Spanish GNU)
#
# Por haber atendido siempre mis preguntas y por mostrar tanto interés
# en esta traducción.
#
# Asimismo, quisiera expresar mi agradecimiento a las siguientes
# personas, por responder pacientemente todas mis preguntas: Joerg
# Hoehle (traductor de la versión francesa) y Juan Jordana.
#
# Por último, a toda la lista de Spanish GNU Translation Team
# (es@li.org) por sus sugerencias.
#
# NOTAS.
#
# * Los mensajes en los que se han realizado anotaciones de interés,
# bien porque haya alguna duda, bien porque contenga notas importantes
# relativas a las traducciones tienen la palabra `Duda:' al principio de
# su comentario.
#
# * Por favor, si alguien realiza alguna modificación a este archivo que
# ponga sus iniciales al final del comentario explicando el cambio y el
# motivo. Si su nombre no está en esta cabecera que lo añada poniendo
# las iniciales.
#
# * Todas las líneas que comienzan con #~ son mensajes obsoletos que no
# hace falta revisar. En cualquier caso, intentaré normalmente
# eliminarlas.
#
# $Id$
# $Log$
# Revision 1.5  2004/03/17 20:47:07  sds
# regenerated for 2.33
#
# Revision 1.4  2004/03/14 17:27:54  sds
# regenerated for 2.32.94
#
# Revision 1.3  2004/03/12 19:22:47  sds
# regenerated for 2.32.93
#
# Revision 1.2  2002/09/13 15:00:36  sds
# regenerated for 2.30
#
# Revision 1.1  2002/05/18 14:27:46  sds
# kill src/gettext; POs are now in src/po
#
# Revision 1.12  1998/09/07 18:21:38  clinares
# Traducción de todos los mensajes para la versión del 29-8-1998. Estos
# cambios, sin embargo, serán publicados en alguna nueva versión de
# septiembre de este mismo año.
#
# Revision 1.9  1997/09/18 13:36:38  clinares
# He incluído nuevas modificaciones de Leo Sarasúa.
#
# Entre las más representativas está el hecho de haber modificado
# `trama' por `marco' y `# macro carácter' por `macro carácter
# secundario'. Nuevamente gracias, Leo, ...
#
# Revision 1.8  1997/09/05 17:23:30  clinares
# He introducido todas las modificaciones propuestas por Santiago Vila a
# la versión 1.6. Además, las he adaptado para el nuevo .pot que se
# empleó en la versión 1.7.
#
# Entre los cambios más importantes está: `command' es `orden', no
# `comando'; `warning' es, preferiblemente, `atención' y, en otro caso,
# propongo que sea `advertencia', en vez de `aviso'.
#
# Revision 1.7  1997/09/03 17:51:44  clinares
# He modificado la traducción de las directivas ~P, puesto que nunca se
# escribirán versiones en español de ellas, ya que el estándar Common
# Lisp - The Language es muy específico: solo en inglés. Ni en alemán,
# ni francés, ni español, ...
#
# Además, he adaptado los cambios del POT de la versión 1.6
# (POT-Creation-Date: 1997-05-04) a la última versión que existe
# actualmente (POT-Creation-Date: 1997-09-02). Para ello, he traducido 9
# mensajes nuevos, he corregido los mensajes difusos y he borrado todos
# los obsoletos.
#
# Revision 1.6  1997/08/30 14:04:08  clinares
# El 100% de los mensajes están traducidos :)
# En total, 9 meses de trabajo (es decir, aha sido un parto!! :)
#
# Revision 1.5  1997/08/27 00:48:46  clinares
# Esta es la traducción que resulta de programar todos los cambios
# propuestos por lsg (Leonardo Sarasúa García). En total, aalrededor de
# 800 líneas!!, ahí es nada :)
#
# Muchísimas gracias, Leo. Te debo la cerveza más grande del mundo, ...
#
# ------------------------------------------------------------------
# msgfmt --statistics -c -v -o /dev/null /home/clinares/GNU/clisp.po
# 1406 mensajes traducidos.
# ------------------------------------------------------------------
#
msgid ""
msgstr ""
"Project-Id-Version: GNU clisp 1996-03-31\n"
"POT-Creation-Date: 2004-03-17 15:20:55 EST\n"
"PO-Revision-Date: 1997-08-11 18:16 MET DST\n"
"Last-Translator: Carlos Linares López <clinares@delicias.dia.fi.upm.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: spvw.d:419
msgid "could not make symbol value per-thread"
msgstr ""

# "*** - desbordamiento de la pila del programa - REINICIALIZANDO" - lsg
#
# En mi opinión, RESET debe traducirse como un imperativo - cll
#
#: spvw.d:487
msgid ""
"\n"
"*** - Program stack overflow. RESET"
msgstr ""
"\n"
"*** - Desbordamiento de la pila del programa. REINICIE"

# ¡ Toma puntilloso que soy! Lisp debería escribirse con mayúscula.
# "*** - desbordamiento de la pila de Lisp - REINICIALIZANDO" - lsg
#
# No, no, nada de REINICIALIZANDO. Debe ser un imperativo: REINICIE.
# Por ejemplo, si durante una sesión con CLisp haces:
#
# > (defun foo (a) (foo (1- a)))
# FOO
# > (foo 2)
#
# *** - Desbordamiento de la pila de Lisp. REINICIE
# >
#
# ..., pero el intérprete se queda esperando a que tú sigas tecleando,
# es decir, él solo no se pone a reiniciar nada, ...
#
# Por otra parte, tienes toda la razón, Lisp debe ir con mayúsculas :) - cll
#
#: spvw.d:498
msgid ""
"\n"
"*** - Lisp stack overflow. RESET"
msgstr ""
"\n"
"*** - Desbordamiento de la pila de Lisp. REINICIE"

#: spvw.d:617
#, fuzzy
msgid "~: malloc() failed"
msgstr "mprotect() falló."

#
# Muy bueno el apunte sobre ese acento en "cómo". Gracias, Santiago - cll
#
#: spvw.d:644
#, fuzzy
msgid ""
"Internal error: statement in file ~, line ~ has been reached!!\n"
"Please send the authors of the program a description how you produced this error!"
msgstr ""
"error interno: aen la sentencia del fichero ~, línea ~!!\n"
"¡Por favor, envíe a los autores del programa una descripción de cómo\n"
"se produjo este error!"

# ß¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:695
#, fuzzy
msgid "Unknown FSUBR signature: %d %d %d\n"
msgstr "Tipo de argumento desconocido para SUBR\n"

# ß¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:803
#, fuzzy
msgid "Unknown SUBR signature: %d %d %d %d"
msgstr "Tipo de argumento desconocido para SUBR\n"

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#: spvw.d:1479
msgid "module `%s' requires package %s.\n"
msgstr "el módulo `%s' necesita el paquete %s.\n"

#: spvw.d:1518
msgid ""
"is an ANSI Common Lisp.\n"
"Usage:  "
msgstr ""

#: spvw.d:1520
msgid ""
" [options] [lispfile [argument ...]]\n"
" When `lispfile' is given, it is loaded and `*ARGS*' is set\n"
" to the list of argument strings. Otherwise, an interactive\n"
" read-eval-print loop is entered.\n"
msgstr ""

#: spvw.d:1524
msgid "Informative output:\n"
msgstr ""

#: spvw.d:1525
msgid " -h, --help    - print this help and exit\n"
msgstr ""

#: spvw.d:1526
msgid " --version     - print the version information\n"
msgstr ""

#: spvw.d:1527
msgid " --license     - print the licensing information\n"
msgstr ""

#: spvw.d:1528
msgid "Memory image selection:\n"
msgstr ""

#: spvw.d:1529
msgid " -B lisplibdir - set the installation directory\n"
msgstr ""

#: spvw.d:1531
msgid " -K linkingset - use this executable and memory image\n"
msgstr ""

#: spvw.d:1533
msgid " -M memfile    - use this memory image\n"
msgstr ""

#: spvw.d:1534
msgid " -m size       - memory size (size = xxxxxxxB or xxxxKB or xMB)\n"
msgstr ""

#: spvw.d:1536
msgid " -s size       - stack size (size = xxxxxxxB or xxxxKB or xMB)\n"
msgstr ""

#: spvw.d:1539
msgid " -t tmpdir     - temporary directory for memmap\n"
msgstr ""

#: spvw.d:1541
msgid "Internationalization:\n"
msgstr ""

#: spvw.d:1542
msgid " -L language   - set user language\n"
msgstr ""

#: spvw.d:1543
msgid " -N nlsdir     - NLS catalog directory\n"
msgstr ""

#: spvw.d:1544
msgid " -Edomain encoding - set encoding\n"
msgstr ""

#: spvw.d:1545
msgid "Interoperability:\n"
msgstr ""

#: spvw.d:1546
msgid ""
" -q, --quiet, --silent, -v, --verbose - verbosity level:\n"
"     affects banner, *LOAD-VERBOSE*/*COMPILE-VERBOSE*,\n"
"     and *LOAD-PRINT*/*COMPILE-PRINT*\n"
msgstr ""

#: spvw.d:1549
msgid " -w            - wait for a keypress after program termination\n"
msgstr ""

#: spvw.d:1550
msgid " -I            - be ILISP-friendly\n"
msgstr ""

#: spvw.d:1551
msgid "Startup actions:\n"
msgstr ""

#: spvw.d:1552
msgid " -ansi         - more ANSI CL compliance\n"
msgstr ""

#: spvw.d:1553
msgid " -traditional  - traditional (undoes -ansi)\n"
msgstr ""

#: spvw.d:1554
msgid " -p package    - start in the package\n"
msgstr ""

#: spvw.d:1555
msgid " -C            - set *LOAD-COMPILING* to T\n"
msgstr ""

#: spvw.d:1556
msgid " -norc         - do not load the user ~/.clisprc file\n"
msgstr ""

#: spvw.d:1557
msgid " -i file       - load initfile (can be repeated)\n"
msgstr ""

#: spvw.d:1558
msgid "Actions:\n"
msgstr ""

#: spvw.d:1559
msgid " -c [-l] lispfile [-o outputfile] - compile LISPFILE\n"
msgstr ""

#: spvw.d:1560
msgid " -x expressions - execute the expressions, then exit\n"
msgstr ""

#: spvw.d:1561
msgid " lispfile [argument ...] - load lispfile, then exit\n"
msgstr ""

#: spvw.d:1562
msgid "These actions put CLISP into a batch mode, which is overridden by\n"
msgstr ""

#: spvw.d:1563
msgid " -interactive-debug - allow interaction for failed ASSERT and friends\n"
msgstr ""

#: spvw.d:1564
msgid " -repl              - enter the interactive read-eval-print loop when done\n"
msgstr ""

#: spvw.d:1565
msgid "Default action is an interactive read-eval-print loop.\n"
msgstr ""

#: spvw.d:1871
msgid "Syntax for %s: nnnnnnn or nnnnKB or nMB\n"
msgstr "Sintaxis de %s: nnnnnnn or nnnnKB or nMB\n"

#
# "%s fuera de intervalo\n"
# No me gusta del todo. A lo mejor:
# "%s fuera de limites\n" - lsg
#
# Al final me he decidido por:
#
# "%s se ha salido del rango\n"
#
# ¿No te mola más? - cll
#
#: spvw.d:1875
msgid "%s out of range\n"
msgstr "%s se ha salido del rango\n"

#: spvw.d:1888
msgid "memory size"
msgstr "tamaño de memoria"

#: spvw.d:1899
msgid "stack size"
msgstr "tamaño de la pila"

#: spvw.d:2025
msgid "CLISP: -a is deprecated, use -ansi\n"
msgstr ""

#: spvw.d:2271
msgid "Return value of malloc() = %x is not compatible with type code distribution.\n"
msgstr "El valor devuelto por malloc() = %x no es compatible con la distribución del código de tipo.\n"

# solo es con acento.
# "sólo %d bytes disponibles\n" - lsg
#
# aMadre mía!! Tienes toda la razón del mundo - cll :)
#
#: spvw.d:2277
msgid "Only %d bytes available.\n"
msgstr "Sólo quedan %d bytes disponibles.\n"

# Duda: Imagino que SP es el "Stack Pointer". Pero entonces, ¿a qu
# viene decir "SP stack"? ¿Se referirán con ello a la pila del sistema?
# - cll
#
#: spvw.d:2520
msgid "Could not determine the end of the SP stack!\n"
msgstr "No fue posible determinar el final de la pila SP!\n"

# "AVISO: No se ha especificado un fichero de inicializacion.\n" - lsg
#
# El mensaje inglés está en pretérito (specified) por eso yo he
# preferido poner "especificó" en vez de "ha especificado" - cll
#
# Pero Carlos, se ha especificado, es también pretérito,
# pretérito perfecto (compuesto), pero pretérito a fin de cuentas.
# No se ha especificado está más en la línea los demás
# mensajes de los otros ficheros .po. sv
#
# Vale, vale, ... La verdad es que a mí las dos me suenan igual de bien,
# de modo que, a tenor de la voluntad popular (dos votos contra uno),
# pues se pone como propuso Leo - cll
#
# Otra nota de interés es la siguiente: he cambiado "aviso" por
# "atención". Creo que así suena mejor. Sugerencia de Santiago - cll
#
#: spvw.d:2753
msgid ""
"\n"
"WARNING: No initialization file specified.\n"
msgstr ""
"\n"
"ATENCIÓN: No se ha especificado ningún fichero de inicialización.\n"

#: spvw.d:2754 spvw.d:2764
msgid "Please try: "
msgstr "Por favor, intente:"

# "AVISO: No se ha especificado un fichero de inicializacion.\n" - lsg
#
# El mensaje inglés está en pretérito (specified) por eso yo he
# preferido poner "especificó" en vez de "ha especificado" - cll
#
# Pero Carlos, se ha especificado, es también pretérito,
# pretérito perfecto (compuesto), pero pretérito a fin de cuentas.
# No se ha especificado está más en la línea los demás
# mensajes de los otros ficheros .po. sv
#
# Vale, vale, ... La verdad es que a mí las dos me suenan igual de bien,
# de modo que, a tenor de la voluntad popular (dos votos contra uno),
# pues se pone como propuso Leo - cll
#
# Otra nota de interés es la siguiente: he cambiado "aviso" por
# "atención". Creo que así suena mejor. Sugerencia de Santiago - cll
#
#: spvw.d:2763
#, fuzzy
msgid ""
"\n"
"WARNING: No installation directory specified.\n"
msgstr ""
"\n"
"ATENCIÓN: No se ha especificado ningún fichero de inicialización.\n"

#: spvw.d:2915
msgid ""
"\n"
"WARNING: no such package: "
msgstr ""

#: spvw.d:2995
#, fuzzy
msgid "%s: Not enough memory for Lisp.\n"
msgstr "No hay memoria suficiente para Lisp.\n"

#: spvw.d:3042 reploop.lisp:682
msgid "Bye."
msgstr "Adiós."

#: spvw.d:3050
msgid "Press a key to terminate..."
msgstr ""

# "*** - Memoria virtual agotada. REINICIALIZACION " - lsg
#
# Yo creo que el mensaje debe acabar en un imperativo: REINICIALIZAR - cll
#
#: spvw_alloca.d:47
msgid ""
"\n"
"*** - Virtual memory exhausted. RESET"
msgstr ""
"\n"
"*** - Memoria virtual agotada. REINICIE"

# "*** - Memoria agotada. REINICIALIZACION " - lsg
#
# Más de lo mismo - cll
#
#: spvw_alloca.d:49
msgid ""
"\n"
"*** - Memory exhausted. RESET"
msgstr ""
"\n"
"*** - Memoria agotada. REINICIE"

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:66 spvw_mmap.d:196 spvw_mmap.d:355 spvw_multimap.d:160
#, fuzzy
msgid "Cannot map memory to address 0x%x .\n"
msgstr "No se puede asignar la memoria a la dirección 0x%x ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:169
msgid "Cannot reserve address range at 0x%x ."
msgstr "No se puede reservar el rango de direcciones a 0x%x ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:179
msgid "Cannot reserve address range 0x%x-0x%x ."
msgstr "No se puede reservar el rango de direcciones 0x%x-0x%x ."

#: spvw_mmap.d:224
msgid "CreateFileMapping() failed."
msgstr "CreateFileMapping() falló."

#: spvw_mmap.d:232
msgid "MapViewOfFileEx(addr=0x%x,off=0x%x) failed."
msgstr "MapViewOfFileEx(dirección=0x%x,segmento=0x%x) falló."

#: spvw_mmap.d:238
msgid "MapViewOfFileEx() returned 0x%x instead of 0x%x.\n"
msgstr "MapViewOfFileEx() devolvió 0x%x en vez de 0x%x.\n"

#: spvw_mmap.d:252
msgid "VirtualFree() failed."
msgstr "VirtualFree() falló."

#: spvw_mmap.d:265
msgid "VirtualProtect() failed."
msgstr "VirtualProtect() falló."

#: spvw_mmap.d:335 spvw_multimap.d:114 spvw_multimap.d:189
#, fuzzy
msgid "Cannot open <%s>."
msgstr "No se puede abrir %s."

# "msync(0x%x,0x%x,MS_INVALIDATE) fracasó." - lsg
#
# O "falló" en vez de "fracasó". ¿Qué te parece? - cll
#
#: spvw_multimap.d:138
#, fuzzy
msgid "msync(0x%x,0x%x,MS_INVALIDATE) failed."
msgstr "msync(0x%x,0x%x,MS_INVALIDATE) falló."

#: spvw_multimap.d:198
#, fuzzy
msgid "Cannot delete <%s>."
msgstr "No se puede borrar %s ."

# He seguido la propuesta de Santiago Vila. A partir de ahora, y siempre
# que sea posible, el término "warning" se traducirá por "atención". En
# aquellos casos en que esto no es posible, lo he indicado
# explícitamente con un comentario indicando el motivo. - cll
#
#: spvw_multimap.d:216
#, fuzzy
msgid "** WARNING: ** Too little free disk space for <%s>.\n"
msgstr "** ATENCIÓN: ** Hay muy poco espacio libre en disco para %s .\n"

#: spvw_multimap.d:217
#, fuzzy
msgid "Please restart LISP with less memory (option -m).\n"
msgstr "Por favor, vuelva a ejecutar LISP con menos memoria (opción -m).\n"

#: spvw_multimap.d:225
#, fuzzy
msgid "Cannot make <%s> long enough."
msgstr "No es posible agrandar %s lo suficiente."

#: spvw_multimap.d:239
#, fuzzy
msgid "Cannot fill <%s>."
msgstr "No se puede rellenar %s ."

#: spvw_multimap.d:252 spvw_multimap.d:286
#, fuzzy
msgid "Cannot close <%s>."
msgstr "No se puede cerrar %s ."

#
# Muy buena tu sugerencia, Leo. Se queda tal y como tu propones - lsg
#
# ¿Apoyo o soporte? sv
#
# Bueno, si, tienes razón. De hecho ésta era una de esas traducciones
# "raras". El problema es que no estaba seguro de que el término
# "soporte" fuese aceptado. Pero si es así, pues perfecto - cll
#
#: spvw_multimap.d:324
msgid "Recompile your operating system with SYSV IPC support.\n"
msgstr "Recompile su sistema operativo con soporte para SYSV IPC.\n"

#
# "no se puede asignar un segmento privado en la memoria compartida" - lsg
#
#: spvw_multimap.d:336
#, fuzzy
msgid "Cannot allocate private shared memory segment of size %d."
msgstr "No se puede asignar un segmento privado en la memoria compartida."

#: spvw_multimap.d:353
msgid "Cannot map shared memory to address 0x%x."
msgstr "No se puede asignar la memoria compartida a la direccion 0x%x."

#: spvw_multimap.d:371 spvw_multimap.d:377
#, fuzzy
msgid "%s: Cannot fill shared memory."
msgstr "No se puede rellenar la memoria compartida."

#
# En este y en otros tantos mensajes, he seguido tu consejo, Leo. He
# traducido `remove' por `desechar' en todos los sitios. - cll
#
#: spvw_multimap.d:390
msgid "Cannot remove shared memory segment."
msgstr "No se puede desechar el segmento de memoria compartida."

#: spvw_fault.d:458
#, fuzzy
msgid "mprotect(0x%x,%d,%d) failed."
msgstr "mprotect() falló."

# "SIGSEGV no puede ser subsanado. Dirección del error =3D 0x%x.\n" - lsg
#
# Si, me gusta más tu traducción. Yo había puesto:
#
# "No se puede evitar SIGSEGV. Dirección de fallo = 0x%x.\n"
#
# Pero el caso es que un SIGSEGV no tiene porque evitarse puesto que es
# una señal que, para cuando sale este mensaje, ya se ha recibido. El
# problema ---realmente--- es que no fue posible "subsanar" la
# señal. Muy bien - cll
#
# De todas formas, prefiero ponerlo al revés ("No se puede subsanar" en
# vez de "... no puede ser subsanado"). Por otra parte, en vez de
# "error" prefiero "fallo" puesto que eso es exactamente de lo que se
# trata. No de un error por algo que alguien hizo mal, sino de un fallo
# del sistema, ... - cll
#
#: spvw_sigsegv.d:29
msgid ""
"\n"
"SIGSEGV cannot be cured. Fault address = 0x%x.\n"
msgstr ""
"\n"
"No se puede subsanar SIGSEGV. Dirección de fallo = 0x%x.\n"

#: spvw_sigsegv.d:63
msgid "Apollo 13 scenario: Stack overflow handling failed. On the next stack overflow we will crash!!!\n"
msgstr "Escenario Apollo 13: Falló la manipulación del desbordamiento de pila. a¡ Nos estrellaremos en el siguiente desbordamiento de pila !!!\n"

#: spvw_sigint.d:69 spvw_sigint.d:132
msgid "Ctrl-C: User break"
msgstr "Ctrl-C: Interrupción del usuario"

#: spvw_garcol.d:2225
#, fuzzy
msgid "munmap() failed."
msgstr "munmap() falló."

#: spvw_allocate.d:32
msgid "No more room for LISP objects"
msgstr "No queda espacio para almacenar más objetos LISP"

#
# "*** - no queda espacio para almacenar objetos LISP - REINICIALIZANDO" - lsg
#
# Yo sigo en mis trece, ... Debe ser un imperativo: REINICIE - cll
#
#: spvw_allocate.d:49
msgid ""
"\n"
"*** - No more room for LISP objects: RESET"
msgstr ""
"\n"
"*** - No queda espacio para almacenar más objetos LISP: REINICIE"

#: spvw_allocate.d:248 spvw_allocate.d:311 spvw_allocate.d:391
msgid "Trying to make room through a GC...\n"
msgstr "Intentando obtener más espacio a través de un GC ...\n"

#: spvw_memfile.d:243
msgid "disk full"
msgstr "el disco está lleno"

#
# "error del sistema operativo al cargar el fichero de inicialización `%s'\n" - lsg
#
# Así dicho parece que la culpa ha sido la carga del fichero de
# inicialización, cuando en realidad, el mensaje dice "durante". El
# error puede haber sido algo distinto de la carga. Por ejemplo, la
# carga puede ser correcta pero puede no cargarse en memoria (se me
# ocurre así de pronto), o cualquier otra cosa. Por eso prefiero la
# traducción:
#
# "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"
#
# - cll
#
#: spvw_memfile.d:777
#, fuzzy
msgid "%s: operating system error during load of initialization file `%s'\n"
msgstr "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"

#: spvw_memfile.d:1244
#, fuzzy
msgid "%s: Cannot map the initialization file `%s' into memory."
msgstr "No puedo escribir el fichero de inicialización en memoria."

#
# "error del sistema operativo al cargar el fichero de inicialización `%s'\n" - lsg
#
# Así dicho parece que la culpa ha sido la carga del fichero de
# inicialización, cuando en realidad, el mensaje dice "durante". El
# error puede haber sido algo distinto de la carga. Por ejemplo, la
# carga puede ser correcta pero puede no cargarse en memoria (se me
# ocurre así de pronto), o cualquier otra cosa. Por eso prefiero la
# traducción:
#
# "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"
#
# - cll
#
#: spvw_memfile.d:1510
#, fuzzy
msgid "%s: operating system error during load of initialization file `%s'"
msgstr "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"

#: spvw_memfile.d:1515
#, fuzzy
msgid "%s: initialization file `%s' was not created by this version of CLISP\n"
msgstr "el fichero de inicialización no fue creado con esta versión de LISP\n"

#: spvw_memfile.d:1518
#, fuzzy
msgid "%s: not enough memory for initialization\n"
msgstr "no hay memoria suficiente para la inicialización\n"

#
# "EVAL: la variable ~ no tiene asignado ningún valor" - lsg
#
# Bueno, he quitado lo de "asignado" porque parece de "perogrullo", pero
# lo demás se queda - cll
#
#: eval.d:837
msgid "EVAL: variable ~ has no value"
msgstr "EVAL: la variable ~ no tiene ningún valor"

#: eval.d:1424
msgid "Too many documentation strings in ~"
msgstr "Demasiadas cadenas de documentación en ~"

# Quito el guión, ya que en el mensaje siguiente lo tienes sin él. sv
# Otra posibilidad es: falta la lista lambda para ~. sv
#
# Es que de hecho, debe ir sin guión, ... evidentemente. cll
#
# Por otra parte, mejor pensado, me gusta la alternativa que das - cll
#
#: eval.d:1624
#, fuzzy
msgid "~: lambda-list for ~ is missing"
msgstr "FUNCTION: falta la lista lambda de ~"

#
# "FUNCTION: la lista lambda de ~ debe ser una lista, no un(a) ~" - lsg
#
# Lo de "un(a)" no me mola, aunque sin esa palabra el mensaje queda más
# "telegráfico", me parece más apropiado para tratarse del "diálogo con
# un ordenador" :) - cll
#
#: eval.d:1632
#, fuzzy
msgid "~: lambda-list for ~ should be a list, not ~"
msgstr "FUNCTION: la lista lambda de ~ debe ser una lista, no ~"

#: eval.d:1745
#, fuzzy
msgid "~: illegal declaration ~"
msgstr "FUNCTION: declaración inválida ~"

#: eval.d:1838
#, fuzzy
msgid "~: variable specification after ~ too long: ~"
msgstr "FUNCTION: especificacion de variable demasiado larga despues de &AUX: ~"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#: eval.d:1876
#, fuzzy
msgid "~: ~ var must be followed by ~ or ~ or end of list: ~"
msgstr "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX o del final de lista: ~"

#
# Igualmente: "FUNCTION: &REST debe ir seguido de una variable: ~" - lsg
#
# Pues si, es que cuando uno está mucho tiempo traduciendo del inglés,
# llega un momento en que empieza coger los hábitos de ese lenguaje y
# empieza a expresarse de una manera extraña, ... - cll
#
#: eval.d:1881
#, fuzzy
msgid "~: ~ must be followed by a variable: ~"
msgstr "FUNCTION: &REST debe ir seguido de una variable: ~"

#: eval.d:1974
#, fuzzy
msgid "~: incorrect variable specification after ~: ~"
msgstr "FUNCTION: especificación de variable incorrecta después de &KEY: ~"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#: eval.d:1982
#, fuzzy
msgid "~: ~ must be followed by ~ or end of list: ~"
msgstr "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX o del final de lista: ~"

#: eval.d:2012
#, fuzzy
msgid "~: variable specification after ~ too long : ~"
msgstr "FUNCTION: especificacion de variable demasiado larga despues de &AUX: ~"

#: eval.d:2032
#, fuzzy
msgid "~: badly placed lambda-list keyword ~: ~"
msgstr "La palabra clave ~ de la lista lambda está mal situada: ~"

#: eval.d:2040
#, fuzzy
msgid "~: too many parameters in the lambda-list ~"
msgstr "FUNCTION: demasiados parámetros en la lista lambda ~"

#: eval.d:2047
#, fuzzy
msgid "~: a dot in a lambda-list is allowed only for macros, not here: ~"
msgstr "FUNCTION: sólo en las macros se permite utilizar un punto en la lista lambda, no aquí: ~"

#: eval.d:2118
#, fuzzy
msgid "~: ~ is a special operator, not a function"
msgstr "APPLY: ~ es una forma especial, no una función"

#: eval.d:2129
msgid "~: ~ is a macro, not a function"
msgstr "~: ~ es una macro, no una función"

#
# "EVAL/APPLY: no se han pasado suficientes argumentos a ~" - lsg
#
# Hmmm, ... Si me gusta, es más "explicativo". Si, me gusta, si, si
# Lo único que te trastoco es lo de "pasado" por "entregado". Ya sabes,
# un toque de distinción :) - cll
#
#: eval.d:2404
msgid "EVAL/APPLY: too few arguments given to ~"
msgstr "EVAL/APPLY: no se han entregado suficientes argumentos a ~"

#
# 'Se han pasado demasiados argumentos a ~" - lsg
#
# Bueno, tu traducción es absolutamente válido. Tal vez, algo más
# informal que la mía, por aquello de "pasado" en vez de
# "entregado". Bueno, pues si te parece, esta vez lo dejo como lo tenía
# yo - cll
#
#: eval.d:2486
msgid "EVAL/APPLY: too many arguments given to ~"
msgstr "EVAL/APPLY: se han entregado demasiados argumentos a ~"

# "EVAL: no se han pasado suficientes argumentos a la forma especial ~:~" - lsg
#
# Bueno, pues te digo lo mismo que en el mensaje eval.d:2572, ... - cll
#
#: eval.d:3051
#, fuzzy
msgid "EVAL: too few parameters for special operator ~: ~"
msgstr "EVAL: no se han entregado suficientes argumentos a la forma especial ~: ~"

#
# "Se han pasado demasiados parámetros a la forma especial ~: ~" - lsg
#
# O sea, que quite lo de "para" y ponga "a". Pues vale, tienes toda la
# razón del mundo - cll
#
#: eval.d:3064
#, fuzzy
msgid "EVAL: too many parameters for special operator ~: ~"
msgstr "EVAL: se han entregado demasiados parámetros a la forma especial ~: ~"

#: eval.d:3076
#, fuzzy
msgid "EVAL: dotted parameter list for special operator ~: ~"
msgstr "EVAL: la lista de parámetros para la forma especial ~ está punteada: ~"

#
# "EVAL: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Una vez más, te digo lo mismo que en el mensaje eval.d:2572 - cll
#
#: eval.d:3136
msgid "EVAL: too few arguments given to ~: ~"
msgstr "EVAL: no se han entregado suficientes argumentos a ~: ~"

#
# "Se han pasado demasiados argumentos a ~: ~" - lsg
#
# Me gusta más "entregado" que "pasado" - cll
#
#: eval.d:3145
msgid "EVAL: too many arguments given to ~: ~"
msgstr "EVAL: se han entregado demasiados argumentos a ~: ~"

#
# "EVAL: la lista de argumentos pasada a ~ es punteada: ~" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#: eval.d:3154
msgid "EVAL: argument list given to ~ is dotted: ~"
msgstr "EVAL: la lista de argumentos entregada a ~ está punteada: ~"

#
# "EVAL: la lista de argumentos pasada a ~ es punteada: ~" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#: eval.d:3985
#, fuzzy
msgid "~: argument list given to ~ is dotted (terminated by ~)"
msgstr "EVAL: la lista de argumentos entregada a ~ está punteada: ~"

#
# "Se han pasado demasiados argumentos a ~" - lsg
#
# Una vez más, me gusta más "entregar" que "pasar" - cll
#
#: eval.d:3992
msgid "APPLY: too many arguments given to ~"
msgstr "APPLY: se han entregado demasiados argumentos a ~"

#
# "APPLY: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Pues eso, que me gusta más "entregar" - cll
#
#: eval.d:3999
msgid "APPLY: too few arguments given to ~"
msgstr "APPLY: se han entregado pocos argumentos a ~"

#
# "el símbolo ~ no tiene valor asignado" - lsg
#
# En algún otro sitio ha aparecido algo parecido a esto. Verás, como me
# parece evidente que si un símbolo no tiene valor, es que no tiene
# valor asignado, pues prefiero omitir lo de "asignado" y evitar que el
# usuario lea términos innecesarios - cll
#
#: eval.d:6429 eval.d:6443
#, fuzzy
msgid "~: symbol ~ has no value"
msgstr "el símbolo ~ no tiene valor"

#: eval.d:6456
#, fuzzy
msgid "~: assignment to constant symbol ~ is impossible"
msgstr "no pueden realizarse asignaciones sobre el símbolo constante ~"

#
# "~: se ha invocado ~ con demasiados argumentos" - lsg
#
# a¡ Traducción brillantísima !!! Te ha quedado perfecto. Lo que yo había puesto:
#
# "~: se han entregado demasiados argumentos a ~"
#
# queda como más "indio". Tu traducción me encanta - cll
#
#: eval.d:7081 control.d:2198
msgid "~: too many arguments given to ~"
msgstr "~: se ha invocado ~ con demasiados argumentos"

# Duda: tagbody es de muy difícil traducción.
#       Echando un ojo a la traducción en francés me he encontrado con que est
#       tal cual, ... De momento se queda así hasta que otros miembros del
#       equipo decidan cualquier otra cosa, ...
#
# No es que sepa lo que es, pero, si tag es etiqueta, tagbody podría ser
# "el cuerpo de la etiqueta" (¿tiene sentido esto?), con lo cual, una
# posibilidad sería (para simplificar) "el cuerpo de las etiquetas..." sv
#
# Otra de las propuestas a esta cuestión en la lista de correo
# es@li.org, ha sido: "el contenido de las etiquetas ~ ya ha sido
# abandonado". Esta traducción me gusta, ... cll
#
# ( Desafortunadamente, no recuerdo el nombre de la persona que lo
# sugirió, ... cll )
#
# "(~ ~): ya se ha salido del cuerpo de etiquetas ~" - lsg
#
# Debo rendirme a la evidencia, ... La propuesta de Leo, no solo para
# este término sino todos cuanto se refieren a la traducción de `tag' y
# `tagbody' es perfecta y, además, sigue los pasos de la de Santiago, de
# modo que "moción aceptada" :)
#
#: eval.d:7258 eval.d:7292
msgid "(~ ~): the tagbody of the tags ~ has already been left"
msgstr "(~ ~): ya se ha salido del cuerpo de etiquetas ~"

#: eval.d:7355 control.d:1931
msgid "~: there is no CATCHer for tag ~"
msgstr "~: No hay ningún capturador (CATCH) para la etiqueta de salto ~"

#: eval.d:7378
msgid "STACK corrupted"
msgstr "Pila (STACK) corrupta"

#: eval.d:7746
msgid "~: ~ is not a correct index into ~"
msgstr "~: ~ no es un índice correcto en ~"

#: eval.d:8356
msgid "undefined bytecode in ~ at byte ~"
msgstr "Código de octeto ~ indefinido en el octeto ~"

#: eval.d:8364
msgid "too many return values"
msgstr "Demasiados valores devueltos"

#: eval.d:8369
msgid "Corrupted STACK in ~ at byte ~"
msgstr "Pila corrupta en ~ en el byte ~"

#: control.d:78
#, fuzzy
msgid "~: ~ should be a lambda expression"
msgstr "~S: ~S debe ser una expresión lambda"

#: control.d:99
msgid "~: ~ has no dynamic value"
msgstr "~: ~ no tiene ningún valor dinámico"

#: control.d:198
#, fuzzy
msgid "~: odd number of arguments: ~"
msgstr "~ invocado con un número impar de argumentos: ~"

#: control.d:206
msgid "dotted list given to ~ : ~"
msgstr "lista punteada entregada a ~: ~"

#: control.d:307
#, fuzzy
msgid "~: the special operator definition of ~ must not be removed"
msgstr "~: no se debe desechar la definición de la forma especial de ~"

#: control.d:372
msgid "~: doc-strings are not allowed here: ~"
msgstr "~: aquí no se permiten cadenas de documentación: ~"

#: control.d:418
msgid "~: illegal variable specification ~"
msgstr "~: especificación inválida de variable ~"

#: control.d:545
#, fuzzy
msgid "~: symbol ~ is declared special and must not be declared a macro"
msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: control.d:551
msgid "~: symbol ~ must not be declared SPECIAL and a macro at the same time"
msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: control.d:586
msgid "~: too many variables and/or declarations"
msgstr "~: demasiadas variables y/o declaraciones"

#: control.d:844
msgid "~: ~ is not a function specification"
msgstr "~: ~ no es la especificación de una función"

#: control.d:1019
msgid "~: ~ is not a macro specification"
msgstr "~: ~ no es la especificación de una macro"

#: control.d:1026
msgid "~: macro name ~ should be a symbol"
msgstr "~: el nombre de la macro ~ debe ser un símbolo"

#: control.d:1066
#, fuzzy
msgid "~: ~ is not a function and macro specification"
msgstr "~: ~ no es la especificación de una función"

#: control.d:1073
#, fuzzy
msgid "~: function and macro name ~ should be a symbol"
msgstr "~: el nombre de la función ~ debe ser un símbolo"

#: control.d:1192
msgid "~: clause ~ should be a list"
msgstr "~: la clausula ~ debe ser una lista"

#: control.d:1222
msgid "~: missing key list: ~"
msgstr "~: falta la lista de claves: ~"

#: control.d:1231
msgid "~: the ~ clause must be the last one"
msgstr "~: la clausula ~ debe ser la última"

#: control.d:1286
msgid "~: the block named ~ has already been left"
msgstr "~: el bloque de nombre ~ ya ha sido abandonado"

#: control.d:1321
msgid "~: no block named ~ is currently visible"
msgstr "~: no hay ningún bloque visible con el nombre ~"

#: control.d:1579
msgid "~: ~ is neither tag nor form"
msgstr "~: ~ no es ni una etiqueta de salto ni una forma"

#: control.d:1621
msgid "~: illegal tag ~"
msgstr "~: etiqueta de salto inválida ~"

#: control.d:1659
msgid "~: tagbody for tag ~ has already been left"
msgstr "~: ya se ha salido del cuerpo de etiquetas de ~"

#: control.d:1673
msgid "~: no tag named ~ is currently visible"
msgstr "~: no hay ninguna etiqueta de salto visible con el nombre ~"

#: control.d:1687
msgid "~: too many values"
msgstr "~: demasiados valores"

#: control.d:1727
msgid "~: too many arguments to ~"
msgstr "~: se han entregado demasiados argumentos a ~"

#: control.d:1971
msgid "Argument ~ is not a macroexpansion environment"
msgstr "El argumento ~ no es un entorno para la expansión de macros"

#: control.d:2028
msgid "declarations ~ are not allowed here"
msgstr "las declaraciones ~ no están permitidas aquí"

#: control.d:2049
msgid "~: ~ evaluated to the values ~, not of type ~"
msgstr "~: La forma ~ ha producido los valores ~, ninguno de los cuales es del tipo ~"

#: control.d:2060
msgid "~: bad declaration ~"
msgstr "~: declaración incorrecta ~"

#: control.d:2271
msgid "no doc-strings allowed here: ~"
msgstr "no se permite la utilización de cadenas de documentación aquí: ~"

#: control.d:2290
msgid "keyword argument list ~ has an odd length"
msgstr "la lista de argumentos clave ~ tiene longitud impar"

#: control.d:2327
#, fuzzy
msgid ""
"Illegal keyword/value pair ~, ~ in argument list.\n"
"The allowed keywords are ~"
msgstr "par argumento clave/valor inválido ~, ~ en la lista de argumentos. Los parámetros clave permitidos son ~"

#: encoding.d:49
msgid "Character #\\u$$$$ cannot be represented in the character set ~"
msgstr ""

#: encoding.d:54
msgid "Character #\\u00$$$$$$ cannot be represented in the character set ~"
msgstr ""

#: encoding.d:61
msgid "incomplete byte sequence at end of buffer for ~"
msgstr ""

#: encoding.d:323
msgid "character #x$$$$$$$$ in ~ conversion, not an UTF-32 character"
msgstr ""

#: encoding.d:534
msgid "invalid byte #x$$ in ~ conversion, not a Unicode-16"
msgstr ""

#: encoding.d:546
msgid "invalid byte sequence #x$$ #x$$ in ~ conversion"
msgstr ""

#: encoding.d:561
msgid "invalid byte sequence #x$$ #x$$ #x$$ in ~ conversion"
msgstr ""

#: encoding.d:578
msgid "invalid byte sequence #x$$ #x$$ #x$$ #x$$ in ~ conversion"
msgstr ""

#: encoding.d:1383
msgid "invalid byte #x$$ in ~ conversion"
msgstr ""

#: encoding.d:1833 encoding.d:1844 encoding.d:1854 encoding.d:1865 pathname.d:3522 pathname.d:6195 pathname.d:6214 pathname.d:6249 pathname.d:7372 pathname.d:8258 stream.d:3008 stream.d:3114 stream.d:15953 hashtabl.d:1272 error.d:1052
msgid "~: illegal ~ argument ~"
msgstr "~: el argumento de ~ es inválido: ~"

#: encoding.d:2450
#, fuzzy
msgid "~: ~ is not a 1:1 encoding"
msgstr "~: ~ no es un registro"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#
#: pathname.d:676 pathname.d:719
msgid "~: host should be NIL or a string, not ~"
msgstr "~: el anfitrión debe ser, o bien NIL, o una cadena, pero no ~"

#
# Duda: he traducido hostname por "nombre del `host'". ¿Qué os parece?
#
#: pathname.d:696 pathname.d:740
msgid "~: illegal hostname ~"
msgstr "~: nombre de anfitrión inválido ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:756
msgid "~: host should be NIL, not ~"
msgstr "~: el anfitrión debe ser NIL, no ~"

#: pathname.d:866
#, fuzzy
msgid "~: argument ~ should be a pathname designator ~"
msgstr "~: el argumento ~ debe ser un flujo"

#: pathname.d:900
msgid "~: filename for ~ is unknown"
msgstr "~: el nombre de fichero de ~ es desconocido"

#: pathname.d:1350 realelem.d:170
msgid ""
"The variable ~S had an illegal value.\n"
"~S has been reset to ~S."
msgstr ""
"La variable ~S tenía un valor inválido.\n"
"~S ha sido inicializado a ~S."

#: pathname.d:1691
msgid "~: there is no user named ~"
msgstr "~: no hay ningún usuario con el nombre ~"

#: pathname.d:1750
msgid "~: there is no environment variable ~"
msgstr "~: no hay ninguna variable de entorno ~"

#: pathname.d:1906
msgid "~: syntax error in filename ~ at position ~"
msgstr "~: error de sintáxis en el nombre del fichero ~, en la posición ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:1922 pathname.d:1937
msgid "~: hosts ~ and ~ of ~ should coincide"
msgstr "~: los anfitriones ~ y ~ de ~ deben coincidir"

#: pathname.d:2097
msgid "~: argument ~ is not a logical pathname, string, stream or symbol"
msgstr "~: el argumento ~ no es un PATHNAME \"lógica\", una cadena de caracteres, un flujo o un símbolo"

#: pathname.d:2144
msgid "~: endless loop while resolving ~"
msgstr "~: bucle infinito para ~"

#: pathname.d:2171
msgid "~: unknown logical host ~ in ~"
msgstr "~: anfitrión ~ desconocido en ~"

#: pathname.d:2183
msgid "~: No replacement rule for ~ is known."
msgstr "~: No se conoce ninguna regla de sustitución para ~."

#: pathname.d:2495
msgid "~: :VERSION-argument should be NIL or a positive fixnum or :WILD or :NEWEST, not ~"
msgstr "~: el argumento :VERSION debe ser NIL, un número positivo del tipo fixnum, :WILD o :NEWEST pero no ~"

#: pathname.d:2515
msgid "~: :VERSION-argument should be NIL or :WILD or :NEWEST, not ~"
msgstr "~: el argumento :VERSION debe ser o bien NIL, o :WILD o :NEWEST, pero no ~"

#: pathname.d:2583
msgid "The value of ~S was not a pathname. ~:*~S is being reset."
msgstr "El valor de ~S no es del tipo PATHNAME. ~:*~S se reinicializará."

#: pathname.d:3329
msgid "~: on host ~, device ~ is invalid, should be NIL"
msgstr ""

# Duda: Wildcard por comodín, ..., está bien, ¿no?
#
#: pathname.d:3786
msgid "wildcards are not allowed here: ~"
msgstr "Aquí no están permitidos los comodines: ~"

#: pathname.d:3821
msgid "~: argument ~ should be ~, ~, ~, ~, ~, ~ or ~"
msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#: pathname.d:4767
msgid "~: replacement pieces ~ do not fit into ~"
msgstr "~: las piezas de intercambio ~ no caben en ~"

#: pathname.d:4846
msgid "~: ~ is not a specialization of ~"
msgstr "~: ~ no es una especialización de ~"

#: pathname.d:4894
msgid "(~ ~ ~ ~) is ambiguous: ~"
msgstr "(~ ~ ~ ~) es ambiguo: ~"

#: pathname.d:4915
msgid "nonexistent directory: ~"
msgstr "directorio inexistente: ~"

#: pathname.d:4924
#, fuzzy
msgid "~: file ~ already exists"
msgstr "~: El fichero ~ ya existe"

#: pathname.d:5140
msgid "no directory ~ above ~"
msgstr "no existe el directorio ~ bajo ~"

#: pathname.d:5147
msgid "\"..\\\\\" after \"...\\\\\" is invalid: ~"
msgstr "\"..\\\\\" después de \"...\\\\\" es inválido: ~"

# Casi lo mismo. Bueno, al menos aquí hay dos puntos. sv
#
# Tienes razón. Ahora que veo este mensaje me lío a poner dos puntos en
# los mensajes anteriores. cll
#
#: pathname.d:5325
msgid "UNIX error while GETWD: ~"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Si la tildecilla se sustituye por aquello que devolvió la orden GETWD,
# la frase resultante no tiene mucho sentido.
# Sugerencia: "La ejecución de GETWD en Unix devolvió ~" sv
#
# Hmmm, ..., podría ser, pero verás: en primer lugar, el texto que est
# asociado con la etiqueta "UNIX GETWD returned ~" es "UNIX error while
# GETWD" (fichero pathname.d, línea 6176); segundo, en CLisp se sigue la
# convención de colocar primero un mensaje y después, al final, aquello
# que originó el mensaje y, francamente, no quiero cambiar esta
# convención. Es decir, no quiero faltar al estilo original de los
# autores del programa. cll
#
# Por este motivo, creo que lo más conveniente es dejarlo como está. cll
#
#: pathname.d:5332
msgid "UNIX GETWD returned ~"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Lo mismo. sv
#
# Lo mismo también ;) cll
#
#: pathname.d:5426
msgid "UNIX REALPATH returned ~"
msgstr "Se produjo un error UNIX durante la ejecución de REALPATH: ~"

#: pathname.d:5465
msgid "~: ~ names a directory, not a file"
msgstr "~: ~ es el nombre de un directorio, no de un fichero"

#: pathname.d:5619
msgid "no file name given: ~"
msgstr "no se ha entregado ningún nombre de fichero: ~"

#: pathname.d:5630
msgid "not a directory: ~"
msgstr "no es un directorio: ~"

#: pathname.d:5675
msgid "~: file ~ does not exist"
msgstr "~: el fichero ~ no existe"

#: pathname.d:5708
msgid "~: pathname with type but without name makes no sense: ~"
msgstr "~: un PATHNAME con tipo, pero sin nombre, no tiene ningún sentido: ~"

#: pathname.d:5879
msgid "cannot delete file ~ since there is file stream open to it"
msgstr "no se puede borrar el fichero ~ puesto que hay un flujo abierto sobre el"

#: pathname.d:5930
msgid "cannot rename file ~ since there is file stream open to it"
msgstr "no se puede renombrar el fichero ~ puesto que hay un flujo abierto sobre el"

#: pathname.d:7471
msgid "root directory not allowed here: ~"
msgstr "el directorio raíz no está permitido aquí: ~"

# Duda: ¿Creando *el* directorio? ¿Creando *un* directorio? De momento,
# simplemente "Creando directorio" - cll
#
#: pathname.d:7563
msgid "Creating directory: "
msgstr "Creando directorio: "

#: pathname.d:8734
msgid "~: library directory is not known, use a command line option to specify it"
msgstr ""

# Duda: En este mensaje, el primer "~" se sustituye por el nombre de una
# función y el segundo "~" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: stream.d:269 stream.d:13454
msgid "~ on ~ is illegal"
msgstr "~ no es posible sobre el flujo ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#: stream.d:543 stream.d:597 stream.d:752
#, fuzzy
msgid "Return value ~ of call to ~ should be an integer between ~ and ~."
msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

#: stream.d:655
msgid "~: the last character read from ~ was not ~"
msgstr "~: el último carácter leído de ~ no era ~"

# Duda: A continuación vienen muchos mensajes que empiezan por "~ from
# ~". Para ayudar en su trabajo a quienes estén revisando este trabajo
# (no me canso de darte las gracias, Santiago, ..., y a quienes se
# animen) aclaro que el primer "~" se sustituye por el nombre de una
# función cuya evaluación (o ejecución, pero esto no es correcto en
# Lisp, ... se prefiere el término evaluación porque se está a nivel de
# intérprete) produce el error; el segundo "~" se refiere al nombre del
# flujo desde el cual se leyó dicha función. Luego, a continuación,
# viene el mensaje de error propiamente dicho.
#
# Por ejemplo, la siguiente instrucción en CLisp:
#
# > (read)
#
# ..., si se teclea:
#
# #<...>
#
# ..., produce el siguiente error: (en español, ya traducido)
#
# *** - READ en #<TERMINAL-STREAM>: los objetos escritos de la manera
# #<...> no pueden volverse a leer
#
# ¿De acuerdo?
#
# A continuación reproduzco un par de mails donde se explica el
# mecanismo general de estos mensajes, a propósito de la pregunta que
# puse en la lista de correo de CLisp:
#
# Mi pregunta fue:
#
# > 21. There are a few messages which begin with "~ from ~". They are
# > very easy to translate but they use a lot of prepositions, and words
# > that could be translated in masculine or feminine. So, I need some
# > real examples of their use.
#
# Las respuestas fueron:
#
#
# ---------------------------------------------------------------------------
# Look in io.d:
#     { pushSTACK(*stream_); # Wert fu:r Slot STREAM von STREAM-ERROR
#       pushSTACK(ch); # Character
#       pushSTACK(*stream_); # Stream
#       pushSTACK(S(read));
#       //: DEUTSCH "~ von ~: Gelesenes Zeichen ist kein String-Char: ~"
#       //: ENGLISH "~ from ~: character read should be a string-char: ~"
#       //: FRANCAIS "~ de ~ : le caracte!re lu n'est pas de type STRING-CHAR."
# The first ~ is the function name, the second the stream that was being
# read from or written to and the third is the character that was read/written.
#
# So it says something like "READ from #<STREAM ...>: illegal character"
#
# 						(Joerg Hoehle)
#
# ---------------------------------------------------------------------------
# A general question here: I thought gettext was coming with an Emacs
# mode called "po-mode", which helps you in translating the messages.
# In particular, there are keystroke commands for showing the C/Lisp source
# surrounding the original reference to a message. From this context,
# you should at least be able to guess the meaning of the objects which
# are substituted for the ~. Note, however, that the first ~ corresponds
# the last pushSTACK command before the string, the second ~ to the
# second-to-last pushSTACK command etc.
#
# 						(Bruno Haible)
#
# ---------------------------------------------------------------------------
#
#: stream.d:661
msgid "~ from ~ without ~ before it"
msgstr "~ en ~ sin ~ antes de él"

#: stream.d:904
msgid "~: cannot output to ~"
msgstr "~: no se puede escribir en ~"

#: stream.d:915
#, fuzzy
msgid "~: cannot output ~ into ~, not of type ~"
msgstr "~: no se puede escribir en ~"

#: stream.d:933
msgid "integer ~ is out of range, cannot be output onto ~"
msgstr "el entero ~ está fuera del dominio, no puede imprimirse en ~"

#: stream.d:993
#, fuzzy
msgid "~: argument ~ should be an input stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: stream.d:1005
#, fuzzy
msgid "~: argument ~ should be an output stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: stream.d:1291 lisparit.d:1552
#, fuzzy
msgid "~: argument should be a ~, not ~"
msgstr "~: el argumento debe ser una cadena de caracteres, no ~"

#: stream.d:2132 stream.d:2578
msgid "~ is beyond the end because the string ~ has been adjusted"
msgstr "~ está más allá del final porque la cadena ~ ha sido ajustada"

#: stream.d:2237
#, fuzzy
msgid "~: ~ is not an input ~"
msgstr "~: ~ no es un par"

#: stream.d:2308 charstrg.d:2805
#, fuzzy
msgid "~: ~ argument must be a subtype of ~, not ~"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: stream.d:2356
#, fuzzy
msgid "~: ~ is not an output ~"
msgstr "~: ~ no es un par"

# Duda: He traducido `fill pointer' por "puntero de relleno". En
# realidad, los `fill-pointer' son exactamente, eso:
#
# "The fill pointer constitutes the "active length" of the vector; all
# vector elements whose index is less than the fill pointer are active,
# and the others are inactive." (Guy L. Steele, Jr; Common Lisp, The
# Language - 2nd Edition; pag. 454).
#
#: stream.d:2391
msgid "~: argument ~ should be a string with fill pointer"
msgstr "~: El argumento ~ debe ser una cadena con un puntero de relleno"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:2668
msgid "~: ~ is not a buffered input stream"
msgstr "~: ~ no es un flujo de entrada con buffer"

#: stream.d:2928
msgid "~: stream must be a generic-stream, not ~"
msgstr "~: el flujo debe ser un `generic-stream', no ~"

#: stream.d:3510
msgid "~: Ctrl-C: User break"
msgstr "~: Ctrl-C: Interrupción del usuario"

#: stream.d:3590
#, fuzzy
msgid "unknown character set ~"
msgstr "Registro desconocido: ~S"

#: stream.d:5601
msgid "Unbuffered streams need an ~ with a bit size being a multiple of 8, not ~"
msgstr ""

#: stream.d:5948
msgid "Closed ~ because disk is full."
msgstr "Se ha cerrado ~ porque el disco está lleno."

#: stream.d:6065
msgid "cannot position ~ beyond EOF"
msgstr "no es posible colocarse en ~ más allá de EOF"

# Duda: lo del fichero `regular' por `normal'. De hecho, yo juraría que
# en la asignatura de Sistemas Operativos, en mi Facultad, los
# llamábamos "ficheros normales". ¿Qué tal os suena?.
#
#: stream.d:7514
#, fuzzy
msgid "~: argument ~ ~ was specified, but ~ is not a regular file."
msgstr "~: ~ no es un fichero normal."

#: stream.d:7547
msgid "~: arguments ~ ~ and ~ ~ were specified, but ~ is not a regular file."
msgstr ""

# Duda: aqui he traducido de la version francesa (no se frances, pero
# por lo que parece que pone, ...)
#
#: stream.d:7603
msgid "file ~ is not an integer file"
msgstr "el fichero ~ no tiene el formato de un fichero de enteros"

#: stream.d:8651 stream.d:15413
#, fuzzy
msgid "Return value ~ of call to ~ is not a ~."
msgstr "El valor de ~ no es un flujo: ~"

#: stream.d:8672
#, fuzzy
msgid "Return value ~ of call to ~ contains ~ which is not a ~."
msgstr "El valor de ~ no es un flujo: ~"

#: stream.d:9815
msgid "~: argument ~ should be a window stream"
msgstr "~: el argumento ~ debe ser un WINDOW-STREAM"

#: stream.d:10364
msgid "cannot output to standard output"
msgstr "no se puede escribir en la salida estándar"

#: stream.d:11555
msgid "environment has no TERM variable"
msgstr "no existe ninguna variable de entorno TERM"

#: stream.d:11560
msgid "terminal type ~ unknown to termcap"
msgstr "No existe ninguna entrada para el tipo de terminal ~ en termcap"

# Duda: Juan Jordana (de la lista de CLisp) propone usar la expresión:
#
# 	Terminal incompleta (o errónea): Terminal de impresora.
#
# 	y me gusta, salvo que prefiero decir a continuación algo del
# 	tipo "usando el modo de impresora" o algo así, ¿no os parece
# 	mejor?
#
#: stream.d:11573
msgid "insufficient terminal: hardcopy terminal"
msgstr "terminal insuficiente: usando el modo de impresora"

# Duda: ¿Pues qué voy a decir? La traducción siguiente es una auténtica
# traducción libre. De todos modos, tanto la versión francesa como la
# alemana (aunque no sé ni alemán ni francés) hacen ---por lo visto---,
# lo que yo: una traducción libre.
#
#: stream.d:11577
msgid "insufficient terminal: overstrikes, cannot clear output"
msgstr "teminal insuficiente: no se puede inicializar la salida"

#: stream.d:11581
msgid "insufficient terminal: cannot scroll"
msgstr "terminal insuficiente: no se puede desplazar la pantalla"

#: stream.d:11586
msgid "insufficient terminal: cannot clear screen"
msgstr "terminal insuficiente: no se puede borrar la pantalla"

#: stream.d:11590
msgid "insufficient terminal: cannot position cursor randomly"
msgstr "terminal insuficiente: no se puede situar el cursor aleatoriamente"

#: stream.d:12051
msgid "~: package SCREEN is not implemented"
msgstr "~: el paquete SCREEN no está implementado"

# Duda: he dejado `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: stream.d:13174
msgid "host should be string, not ~"
msgstr "el anfitrión debe ser una cadena de caracteres y no ~"

# Duda: Pues otra vez como siempre, ..., he dejado `display' tal
# cual. Pienso que todo el mundo sabe lo que es un `display' ¿no?
#
# Por otra parte (como ya sucedió en un mensaje anterior), ..., `fixnum'
# por ser el nombre de un subtipo (o tipo, si se quiere) en Lisp, est
# sin traducir, ...
#
#: stream.d:13181
msgid "display should be a nonnegative fixnum, not ~"
msgstr "el `display' debe ser un entero del tipo FIXNUM >=0, y no ~"

#: stream.d:13244
msgid "~: stream must be a socket-stream, not ~"
msgstr "~: el flujo debe ser un `socket-stream' y no ~"

#: stream.d:13255
msgid "~: argument ~ should be a vector of type (ARRAY (UNSIGNED-BYTE 8) (*))"
msgstr "~: el argumento ~ debe ser un vector del tipo (ARRAY (UNSIGNED-BYTE 8) (*)) "

#: stream.d:13277 stream.d:16094 stream.d:16154 stream.d:16208 stream.d:16269 io.d:987
msgid "~: input stream ~ has reached its end"
msgstr "~: el flujo de entrada ~ ha alcanzado su final"

#: stream.d:13449 record.d:211 record.d:428 record.d:573 record.d:614 record.d:686 record.d:770 sequence.d:292 error.d:717 error.d:718 error.d:742 error.d:752 error.d:783 error.d:836 error.d:846 error.d:892 error.d:1120 lisparit.d:335 lisparit.d:352 lisparit.d:369 lisparit.d:386
#, fuzzy
msgid "~: ~ is not a ~"
msgstr "~: ~ no es un par"

#: stream.d:13507
#, fuzzy
msgid "~: argument ~ is neither an open SOCKET-STREAM nor a positive FIXNUM"
msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#: stream.d:13723
#, fuzzy
msgid "~: argument ~ is not an open SOCKET-STREAM"
msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#: stream.d:13734
msgid "~: argument ~ is not a SOCKET-STREAM"
msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#: stream.d:13753 stream.d:16427
#, fuzzy
msgid "~: argument ~ is not an open ~"
msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#: stream.d:13940
#, fuzzy
msgid "~: list ~ is too long (~ maximum)"
msgstr "~: la secuencia ~ es demasiado larga"

#: stream.d:14131
#, fuzzy
msgid "~: argument ~ should be ~."
msgstr "~: el argumento ~ debe ser un flujo"

#: stream.d:14306
#, fuzzy
msgid "Invalid direction ~ for handle ~"
msgstr "Sintaxis inválida en la forma ~S: ~S."

#: stream.d:14332
#, fuzzy
msgid "~: ~ should be a handle, handle stream, or direction"
msgstr "~S: ~S debe ser una expresión lambda"

#: stream.d:14519
msgid "The value of ~ is not a stream: ~"
msgstr "El valor de ~ no es un flujo: ~"

#: stream.d:14521
msgid "The value of ~ is not an appropriate stream: ~"
msgstr "El valor de ~ no es un flujo apropiado: ~"

#: stream.d:14533
#, fuzzy
msgid "The value of ~ was not an appropriate stream: ~. It has been changed to ~."
msgstr "El valor de ~ no era un flujo: ~. Ha sido cambiado por ~."

#: stream.d:14546
msgid "readline library: out of memory."
msgstr "biblioteca readline: la memoria ha sido agotada."

#: stream.d:14850
#, fuzzy
msgid "~: The ~ of ~ cannot be changed from ~ to ~."
msgstr "~: ~ no puede convertirse al tipo ~"

#: stream.d:15906
msgid "Return value ~ of call to ~ is not a fixnum >= 0 or NIL."
msgstr ""

#: stream.d:15920
msgid "~ needs an ~ with a bit size being a multiple of 8, not ~"
msgstr ""

#: stream.d:15968
#, fuzzy
msgid "~: illegal endianness argument ~"
msgstr "~: el argumento de ~ es inválido: ~"

#: stream.d:16076
#, fuzzy
msgid "~: argument ~ does not contain a valid OS stream handle"
msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#: stream.d:16077
msgid "~: ~: buffered pipe-input-streams are not supported"
msgstr ""

#: stream.d:16078
#, fuzzy
msgid "~: ~: stream of wrong direction"
msgstr "~: ~ no es una función"

#: stream.d:16344 stream.d:16354
#, fuzzy
msgid "~ is not a ~, cannot be output onto ~"
msgstr "~ no es un entero, no puede escribirse en ~"

#: stream.d:16457
#, fuzzy
msgid "~: position argument should be ~ or ~ or a nonnegative integer, not ~"
msgstr "~: el argumento de posición debe ser ~, ~ o un número no negativo del tipo FIXNUM, pero no ~"

#: io.d:519
msgid "The value of ~ was not a readtable. It has been reset."
msgstr "El valor de ~ no es una tabla de lectura. Ha sido inicializado/a."

#: io.d:602 hashtabl.d:1475 error.d:918 error.d:928 error.d:945 error.d:958 error.d:988
#, fuzzy
msgid "~: argument ~ is not a ~"
msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
# Al final, por iniciativa de Leo, he cambiado `# macro carácter', que
# no me gustaba demasiado por `macro carácter secundario', que me parece
# mucho mejor. - cll
#
#: io.d:755
msgid "~: ~ is a dispatch macro character"
msgstr "~: ~ es un macro carácter secundario"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:808
msgid "~: ~ is not a dispatch macro character"
msgstr "~: ~ no es un macro carácter secundario"

#: io.d:831
msgid "~: digit $ not allowed as sub-char"
msgstr "~: el dígito $ no está permitido como un sub-carácter"

#: io.d:878
msgid "~: new value ~ should be ~, ~, ~ or ~."
msgstr "~: el nuevo valor ~ debe ser ~, ~, ~ o ~."

#: io.d:909
msgid ""
"The value of ~ should be an integer between 2 and 36, not ~.\n"
"It has been reset to 10."
msgstr ""
"El valor de ~ debe ser un entero entre 2 y 36, no ~.\n"
"Ha sido inicializado a 10."

#: io.d:955
#, fuzzy
msgid "~ from ~: character read should be a character: ~"
msgstr "~ en ~: el carácter leído debe ser un STRING-CHAR: ~"

#: io.d:1000
msgid "~: input stream ~ ends within an object. Last opening parenthesis probably in line ~."
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto. El último paréntesis abierto es, probablemente, el de la línea ~."

#: io.d:1004
msgid "~: input stream ~ ends within an object"
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto"

#: io.d:1280
msgid "~ from ~: illegal character ~"
msgstr "~ en ~: carácter inválido ~"

#
# Duda: Lo mismo de antes, he dejado `token' sin traducir
#
#: io.d:1291
msgid "~: input stream ~ ends within a token after single escape character"
msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape simple"

#
# Duda: A ver, ¿la palabra `token'?
#       Mientras no se os ocurra algo mejor, lo he dejado en inglés, ...
#
#: io.d:1333
msgid "~: input stream ~ ends within a token after multiple escape character"
msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape múltiple"

#: io.d:1859
msgid "~ from ~: ~ has no macro character definition"
msgstr "~ en ~: ~ no tiene ninguna definición de macro carácter"

#: io.d:1872
msgid "~ from ~: macro character definition for ~ may not return ~ values, only one value."
msgstr "~ en ~: la definición del macro carácter para ~ no puede devolver ~ valores, sólo puede ser uno."

#: io.d:1894
msgid "~: input stream ~ ends within read macro beginning to ~"
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba una macro de lectura en ~"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:1926
msgid "~ from ~: After ~ is ~ an undefined dispatch macro character"
msgstr "~ en ~: Después de ~ está ~, que no es un macro carácter secundario"

#: io.d:1939
msgid "~ from ~: dispatch macro character definition for ~ after ~ may not return ~ values, only one value."
msgstr "~ en ~: la definición del macro carácter secundario de ~ después de ~ sólo puede devolver un valor, no ~"

# Duda: He traducido `token' tal cual, ... Santiago, imagino que la
# palabra token se queda tal cual. Quiero decir, ¿es necesario lo de las
# comillas? - cll
#
#: io.d:2004
msgid "~ from ~: a token consisting only of dots cannot be meaningfully read in"
msgstr "~ en ~: no puede leerse correctamente un `token' que consiste únicamente en puntos"

# Duda: Todo el mundo sabe que `colon' es el signo de dos puntos
# `:'. Bueno, pues la traducción del siguiente mensaje podría ser algo
# del estilo: "demasiados signos de dos puntos en el token ...", sin
# embargo, me ha parecido mejor poner los dos puntos directamente, ...
#
#: io.d:2109
msgid "~ from ~: too many colons in token ~"
msgstr "~ en ~: demasiados `:' en el `token' ~"

#: io.d:2156
msgid "~ from ~: there is no package with name ~"
msgstr "~ en ~: no existe ningún paquete con el nombre ~"

#: io.d:2182
msgid "~ from ~: ~ has no external symbol with name ~"
msgstr "~ en ~: ~ no tiene ningún símbolo externo con el nombre ~"

#: io.d:2220
msgid "~ from ~: token \".\" not allowed here"
msgstr "~ en ~: el `token' \".\" no está permitido aquí"

#: io.d:2265 io.d:6205
msgid "~: the value of ~ has been arbitrarily altered"
msgstr "~: el valor de ~ ha sido arbitrariamente alterado"

#: io.d:2279
msgid "~: no entry for ~ from ~ in ~ = ~"
msgstr "~: no existe ninguna entrada para ~ de ~ en ~ = ~"

#: io.d:2485
msgid "~ from ~: illegal end of dotted list"
msgstr "~ en ~: fin de lista punteada inválido"

#: io.d:2554
msgid "~ from ~: an object cannot start with ~"
msgstr "~ en ~: un objeto no puede comenzar por ~"

#: io.d:2657
msgid "~: input stream ~ ends within a string"
msgstr "~: el flujo de entrada ~ termina con una cadena"

#: io.d:2716
msgid "~ from ~: no number allowed between # and $"
msgstr "~ en ~: no debe haber ningún número entre # y $"

#: io.d:2809
msgid "~: input stream ~ ends within a comment #$ ... $#"
msgstr "~: el flujo de entrada ~ termina dentro un comentario #$ ... $#"

#: io.d:2888
#, fuzzy
msgid "~ from ~: font number ~ for character is too large, should be = 0"
msgstr "~ en ~: el número ~ para la fuente de caracteres es demasiado grande, debe ser < ~"

#: io.d:2953
msgid "~ from ~: there is no character with name ~"
msgstr "~ en ~: no hay ningún carácter con el nombre ~"

#: io.d:3012
msgid "~ from ~: token ~ after #$ is not a rational number in base ~"
msgstr "~ en ~: el `token' ~ después de #$ no es un número racional en base ~"

#: io.d:3082
msgid "~ from ~: the number base must be given between # and R"
msgstr "~ en ~: el número de la base debe estar entre # y R"

#: io.d:3095
msgid "~ from ~: The base ~ given between # and R should lie between 2 and 36"
msgstr "~ en ~: La base ~ entre # y R debe estar entre 2 y 36"

#: io.d:3141
msgid "~ from ~: bad syntax for complex number: #C~"
msgstr "~ en ~: sintaxis incorrecta del número complejo: #C~"

#: io.d:3172
msgid "~ from ~: token expected after #:"
msgstr "~ en : ~: se esperaba un `token' después de #:"

#: io.d:3199
msgid "~ from ~: token ~ after #: should contain no colon"
msgstr "~ en ~: el `token' ~ después de #: no debe contener dos puntos"

#: io.d:3250
msgid "~ from ~: only zeroes and ones are allowed after #*"
msgstr "~ en ~: sólo se permiten ceros y unos después de #*"

#: io.d:3277
msgid "~ from ~: bit vector is longer than the explicitly given length ~"
msgstr "~ en ~: la longitud del vector de bits es mayor que la longitud explícitamente indicada ~"

#: io.d:3285
msgid "~ from ~: must specify element of bit vector of length ~"
msgstr "~ en ~: debe especificar un elemento para el vector de bits de longitud ~"

#: io.d:3361
msgid "~ from ~: vector is longer than the explicitly given length ~"
msgstr "~ en ~: el vector tiene una longitud mayor que la explícitamente indicada ~"

#: io.d:3369
msgid "~ from ~: must specify element of vector of length ~"
msgstr "~ en ~: debe especificar un elemento para el vector de longitud ~"

#: io.d:3451
msgid "~ from ~: bad syntax for array: #A~"
msgstr "~ en ~: sintaxis incorrecta en la matriz: #A~"

#: io.d:3514
msgid "~ from ~: ~ = ~ does not allow the evaluation of ~"
msgstr "~ en ~: ~ = ~ no permite la evaluación de ~"

#: io.d:3636
msgid "~ from ~: a number must be given between # and $"
msgstr "~ en ~: debe indicarse un número entre # y $"

#: io.d:3645
msgid "~ from ~: label #~? too large"
msgstr "~ en ~: la etiqueta #~? es demasiado grande"

# Duda: En Common Lisp existe lo que se denominan "Listas de asociación"
# (Common Lisp, The Language, 2nd Edition - Guy L. Steel, página 431) o,
# en inglés, "Association Lists" que abreviadamente se conocen como
# "alist" o "a-list". En realidad, aunque en español, mucha gente dice
# "alistas", esto no me parece correcto y me parece mucho más formal
# decir "listas de asociación".
#
# De hecho, el término "listas de asociación" será facílisimamente
# reconocible por el programador, mientras que "alista" exige estar un
# poquito más experimentado con el Lisp.
#
# Más aún, los traductores del libro "Lisp" (3ra edición) de Winston y
# Horn, utilizan la expresión "lista de asociación" en la presentación
# de la función ASSOC en la página 34, aunque luego también se refieran
# a ellas como "listas-a".
#
#: io.d:3666
msgid "~ from ~: the value of ~ has been altered arbitrarily, it is not an alist: ~"
msgstr "~ en ~: el valor de ~ ha sido modificado arbitrariamente, no es una lista de asociación: ~"

#: io.d:3684
msgid "~ from ~: label #~= may not be defined twice"
msgstr "~ en ~: la etiqueta #~= no puede definirse dos veces"

#: io.d:3709
msgid "~ from ~: #~= #~# is illegal"
msgstr "~ en ~: #~= #~# no está permitido"

#: io.d:3732
msgid "~ from ~: undefined label #~#"
msgstr "~ en ~: la etiqueta #~# no está definida"

#: io.d:3747
msgid "~ from ~: objects printed as #<...> cannot be read back in"
msgstr "~ en ~: los objetos escritos de la manera #<...> no pueden volverse a leer"

#: io.d:3763
msgid "~ from ~: objects printed as # in view of ~ cannot be read back in"
msgstr "~ en ~: los objetos escritos como # a causa de ~ no pueden volverse a leer"

# Duda: `feature' puede ser característica, propiedad, ... Yo me he
# decidido por la última. Sin embargo, ¿hay algún término oficial para
# esta palabra (muy común, por cierto)?
#
#: io.d:3832
msgid "~ from ~: illegal feature ~"
msgstr "~ en ~: propiedad inválida ~"

#: io.d:3956
msgid "~ from ~: #S must be followed by the type and the contents of the structure, not ~"
msgstr "~ en ~: #S debe estar seguido del tipo y contenidos de la estructura, no ~"

#: io.d:3968
msgid "~ from ~: the type of a structure should be a symbol, not ~"
msgstr "~ en ~: el tipo de una estructura debe ser un símbolo, no ~"

#: io.d:3979 io.d:4003
msgid "~ from ~: bad ~"
msgstr "~ en ~: ~ es incorrecto"

#: io.d:4034
msgid "~ from ~: no structure of type ~ has been defined"
msgstr "~ en ~: no se ha definido ninguna estructura del tipo ~"

#: io.d:4043
msgid "~ from ~: bad ~ for ~"
msgstr "~ en ~: ~ es incorrecto en ~"

#: io.d:4054
msgid "~ from ~: structures of type ~ cannot be read in, missing constructor function"
msgstr "~ en ~: las estructuras del tipo ~ no pueden leerse, no se conoce la función de construcción"

#: io.d:4075
msgid "~ from ~: a structure ~ may not contain a component \".\""
msgstr "~ en ~: una estructura ~ no debe contener un componente \".\""

#: io.d:4086
msgid "~ from ~: ~ is not a symbol, not a slot name of structure ~"
msgstr "~ en ~: ~ no es un símbolo, ni el nombre de una ranura ni una estructura ~"

#: io.d:4095
msgid "~ from ~: missing value of slot ~ in structure ~"
msgstr "~ en ~: falta el valor de la ranura ~ en la estructura ~"

#
# Duda: slots se queda tal cual, ...
#
# De acuerdo con la lista spanglish, `slot' se traducirá, en todo el
# CLisp, como "ranura".
#
#: io.d:4115
msgid "~ from ~: too many slots for structure ~"
msgstr "~ en ~: hay demasiadas ranuras en la estructura ~"

#
# "~ en ~: sintaxis inválida del vector de código de recinto tras #~Y" - lsg
#
# Hmmm, no me acaba de gustar, ... - cll
#
#: io.d:4159
msgid "~ from ~: illegal syntax of closure code vector after #~Y"
msgstr "~ en ~: sintaxis inválida del vector de código de la cerradura después de #~Y"

#: io.d:4208
msgid "~ from ~: object #Y~ has not the syntax of a compiled closure"
msgstr "~ en ~: el objeto #Y~ no tiene la sintaxis de una cerradura compilada"

#
# pathname NO es array!
# "~ en ~: sintaxis incorrecta en nombre de path: #A~" - lsg
#
# Si, es verdad, aquí se me había ido la mano, ...
#
# Además, PATHNAME no se traduce puesto que, o bien se refiere al tipo
# de datos PATHNAME o a la función PATHNAME (en este caso, al tipo de
# datos). Como ambos términos están definidos en el estándar de Common
# Lisp: Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr., pues
# no se traduce y se pone en mayúsculas para distinguirlo de otros
# términos. - cll
#
#: io.d:4347
msgid "~ from ~: bad syntax for pathname: #P~"
msgstr "~ en ~: la sintaxis del PATHNAME: #P~ es incorrecta"

# Nota: El siguiente mensaje se debe a la función PEEK-CHAR (Common
# Lisp, The Language - 2nd Edition; Guy L. Steele, Jr; pag. 574), que
# realiza la lectura del siguiente objeto de un flujo de caracteres
# según el valor de su primer argumento opcional `peek-type' que solo
# puede valer, como reza el mensaje, NIL, T o un carácter.
#
#: io.d:4582
msgid "~: peek type should be NIL or T or a character, not ~"
msgstr "~: el tipo del PEEK solo puede ser NIL, T o un carácter, y no ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#: io.d:4726
msgid "~: ~ argument should be an integer between 2 and 36, not ~"
msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

# "~: la cadena ~ no tiene sintaxis de entero" - lsg
#
# He cambiado lo "de entero" por "de un número entero", que parece más
# inteligible - cll
#
#: io.d:4825
#, fuzzy
msgid "~: substring ~ does not have integer syntax at position ~"
msgstr "~: la cadena ~ no tiene la sintaxis de un número entero"

#: io.d:4973
#, fuzzy
msgid "~: Despite ~, ~ cannot be printed readably."
msgstr "~: A pesar de ~, ~ no puede imprimirse de manera legible."

#: io.d:4999
msgid ""
"~: the value ~ of ~ is neither ~ nor ~ nor ~.\n"
"It is reset to ~."
msgstr ""
"~: el valor ~ de ~ no es ~ ni ~ ni ~.\n"
"Ha sido inicializado a ~."

#: io.d:5510
msgid "~: must be a positive integer or NIL, not ~"
msgstr "~: debe ser un número positivo entero o NIL, pero no ~"

# "~: espacio insuficiente en la pila para realizar un análisis de circularidad" - lsg
#
# Vale - cll
#
#: io.d:6536
msgid "~: not enough stack space for carrying out circularity analysis"
msgstr "~: no hay espacio suficiente en la pila para realizar un análisis de circularidad"

#: io.d:8067
msgid "~: bad ~"
msgstr "~: incorrecto ~"

#: io.d:9012
msgid "~: an unknown record type has been generated!"
msgstr "~: se ha generado un tipo de registro desconocido!"

#: io.d:9531
#, fuzzy
msgid "~: argument ~ is too large"
msgstr "~: el argumento ~ no es un string"

#: io.d:9551
#, fuzzy
msgid "~: argument ~ should be ~ or ~."
msgstr "~: el argumento ~ debe ser un flujo"

#: io.d:9592
#, fuzzy
msgid "~: argument ~ should be ~, ~, ~ or ~."
msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#
# aLarge no es largo, sino grande!! - lsg
#
# Tienes toda la razón, ya lo he cambiado en todos los mensajes - cll
#
#: array.d:230
msgid "index too large"
msgstr "índice demasiado grande"

# FIXME. Esto no cabe en 80 columnas. Comunicar al autor (?) sv
#
# "Una formación ha sido acortada mediante un ajuste al trasladar otra formación hacia ella"
# O bien, para que quepa en 80 columnas:
# "Una formación ha sido acortada al trasladar otra formación hacia ella" - lsg
#
# Yo había puesto:
#
# "Una matriz ha sido acortada debido a un ajuste cuando otra se ha desplazado "
# "hacia ella"
#
# Y ciertamente me gusta más tu traducción, salvo que en vez de
# formaciones hay que hablar de matrices, ¿no crees? - cll
#
#: array.d:235
msgid "An array has been shortened by adjusting it while another array was displaced to it."
msgstr "Una matriz ha sido acortada al trasladar otra matriz ella"

# "~: ~ no es una formación" - lsg
#
# Aunque en la lista de spanglish.txt pone "formación", en este caso
# creo que será mucho más conveniente poner "matriz" porque de hecho,
# los mensajes se refieren a matrices, ... - cll
#
#: array.d:315
msgid "~: ~ is not an array"
msgstr "~: ~ no es una matriz"

#: array.d:344 foreign.d:2216
msgid "~: got ~ subscripts, but ~ has rank ~"
msgstr "~: se encontraron ~ subíndices, pero ~ tiene rango ~"

#: array.d:356 foreign.d:2231
msgid "~: subscripts ~ for ~ are not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: los subíndices ~ de ~ no son del tipo '(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:378 foreign.d:2240
msgid "~: subscripts ~ for ~ are out of range"
msgstr "~: los subíndices ~ de ~ han excedido el rango"

#: array.d:431
msgid "~: index ~ for ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: el índice ~ de ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:446
msgid "~: index ~ for ~ is out of range"
msgstr "~: el índice ~ de ~ ha excedido el rango"

#: array.d:494
msgid "~: cannot retrieve values from an array of element type NIL"
msgstr ""

#: array.d:537
msgid "~: ~ does not fit into ~, bad type"
msgstr "~: ~ no cabe en ~, tipo incorrecto"

#: array.d:541
#, fuzzy
msgid "~: ~ cannot be stored in an array of element type NIL"
msgstr "~: ~ no puede convertirse al tipo ~"

#: array.d:882
msgid "~: ~ is not an nonnegative integer less than the rank of ~"
msgstr "~: ~ no es un entero no negativo menor que el rango de ~"

#: array.d:1057
msgid "~: ~ is not an array of bits"
msgstr "~: ~ no es una matriz de bits"

#: array.d:1858
msgid "~: The arguments ~ and ~ should be arrays of bits with the same dimensions"
msgstr "~: Los argumentos ~ y ~ deben ser matrices de bits de la misma dimensión"

#: array.d:1867
msgid "~: The arguments ~, ~ and ~ should be arrays of bits with the same dimensions"
msgstr "~: Los argumentos ~, ~ y ~ deben ser matrices de bits de la misma dimensión"

#: array.d:3596
msgid "~: vector ~ has no fill pointer"
msgstr "~: el vector ~ no tiene ningún puntero de relleno"

#: array.d:3643
msgid "~: ~ has length zero"
msgstr "~: ~ tiene longitud nula"

#: array.d:3655
msgid "~: extending the vector by ~ elements makes it too long"
msgstr "~: ampliar el vector en ~ elementos, lo hace muy grande"

#: array.d:3676
msgid "~ works only on adjustable arrays, not on ~"
msgstr "~ funciona sólo con matrices ajustables, no con ~"

#: array.d:3693
msgid "~: extension ~ should be a positive fixnum"
msgstr "~: la extensión ~ debe ser un número positivo del tipo FIXNUM"

#: array.d:3783
msgid "~: cannot push ~ into array ~ (bad type)"
msgstr "~: no se puede introducir ~ en la matriz ~ (tipo incorrecto)"

#: array.d:3848
msgid "~: dimension ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: la dimensión ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:4099
msgid "~: dimensions ~ produce too large total-size"
msgstr "~: las dimensiones ~ producen un tamaño total demasiado grande"

#: array.d:4136
msgid "~: ambiguous, more than one initialization specified"
msgstr "~: ambiguo, se ha especificado más de una inicialización"

#: array.d:4145
msgid "~: ~ must not be specified without ~"
msgstr "~: ~ no debe especificarse sin ~"

#: array.d:4203
msgid "~: the initial-element ~ is not of type ~"
msgstr "~: el INITIAL-ELEMENT ~ no es del tipo ~"

#: array.d:4287
msgid "~: ~ is of incorrect length"
msgstr "~: ~ no tiene la longitud correcta"

#: array.d:4311
msgid "~: ~-argument ~ is not an array"
msgstr "~: El ~ argumento ~ no es una matriz"

#: array.d:4328
msgid "~: ~-argument ~ does not have element type ~"
msgstr "~: El ~ argumento ~ no tiene como tipo de elemento ~"

#: array.d:4343
msgid "~: ~-argument ~ is not of type `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"
msgstr "~: El ~ argumento ~ no es del tipo `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"

#: array.d:4353
msgid "~: array-total-size + displaced-offset (= ~) exceeds total size ~ of ~-argument"
msgstr "~: array-total-size + displaced-offset (= ~) excede el tamaño total ~ del ~ argumento"

#: array.d:4374
msgid "~: fill-pointer ~ should be a nonnegative fixnum"
msgstr "~: El puntero de relleno ~ debe ser un número no negativo del tipo FIXNUM"

#: array.d:4381
msgid "~: fill-pointer argument ~ is larger than the length ~"
msgstr "~: El argumento FILL-POINTER ~ es mayor que la longitud ~"

#
# "~: el rango intentado ~ es demasiado grande" - lsg
#
# De acuerdo - cll
#
#: array.d:4448
msgid "~: attempted rank ~ is too large"
msgstr "~: el rango intentado ~ es demasiado grande"

#: array.d:4461
msgid "~: ~ may not be specified for an array of rank ~"
msgstr "~: ~ no debe especificarse para una matriz de rango ~"

#: array.d:4656
msgid "~: rank ~ of array ~ cannot be altered: ~"
msgstr "~: no es posible cambiar el rango ~ de la matriz ~: ~"

#
# "~: los elementos de la formación ~ no son de tipo ~" - lsg
#
# Una excelente traducción. Lo único que hago es cambiar "formación" por
# "matriz" y listo - cll
#
#: array.d:4676
msgid "~: array ~ does not have element-type ~"
msgstr "~: los elementos de la matriz ~ no son del tipo ~"

#: array.d:4780
msgid "~: cannot displace array ~ to itself"
msgstr "~: no se puede desplazar la matriz ~ hacia ella misma"

#: array.d:4802
msgid "~: array ~ has no fill-pointer"
msgstr "~: la matriz ~ no tiene ningún puntero de relleno"

#: array.d:4816
msgid "~: the fill-pointer of array ~ is ~, greater than ~"
msgstr "~: el puntero de relleno de la matriz ~ es ~ que es mayor que ~"

# ... de la misma forma que uno no pone "START Índice" sv
#
# Si, si, ..., tienes toda la razón, ... cll
#
#: array.d:4947
msgid "Illegal START index ~ for ~"
msgstr "Índice START ~ inválido en ~"

#: array.d:4977
msgid "Illegal END index ~ for ~"
msgstr "Índice END ~ inválido en ~"

#: array.d:4988
msgid "~: invalid bit-vector length ~"
msgstr "~: la longitud de BIT-VECTOR ~ es inválida"

# Duda: hash lo he traducido por hash. ¿Alguna sugerencia? ¿Tablas de
# acceso rápido, o algo así?. Tened en cuenta que en Common Lisp, las
# tablas hash son una estructura bien definida que cuenta con sus
# propias instrucciones. A mí me gusta tal cual, ...
# Sugerencia: tabla de `hash'. sv
#
# No, no, no, no, ... :) `hash table' es `tabla hash'. Si se quiere,
# podríamos traducir la palabra `hash' pero si se deja es `tabla
# hash'. Todos los informáticos las llamamos así. Jamás he oído `Tabla
# *de* hash' cll
#
#: hashtabl.d:1084
msgid "Hash table size ~ too large"
msgstr "La tabla hash ~ es demasiado grande"

#
# "error interno al redimensionar ~" - lsg
#
# Me gusta, salvo que el error ocurre "durante" - cll
#
#: hashtabl.d:1129
msgid "internal error occured while resizing ~"
msgstr "error interno durante el redimensionamiento de ~"

#: hashtabl.d:1226
#, fuzzy
msgid "~: argument ~ should be ~, ~, ~, ~ or ~."
msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#: hashtabl.d:1288
#, fuzzy
msgid "~: ~ argument should be a fixnum >=0, not ~"
msgstr "~ : El argumento debe ser del tipo FIXNUM >=0 y no ~"

#: hashtabl.d:1310
#, fuzzy
msgid "~: ~ argument should be an integer or a float > 1, not ~"
msgstr "~: el argumento debe ser un entero, no ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#: hashtabl.d:1353
#, fuzzy
msgid "~: ~ argument should be a real between 0 and 1, not ~"
msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

#: hashtabl.d:1433
msgid "~: internal error while building ~"
msgstr "~: error interno durante la construcción de ~"

#: list.d:1047
msgid "~: ~ is not a pair"
msgstr "~: ~ no es un par"

#: list.d:1730
msgid "~: lists ~ and ~ are not of same length"
msgstr "~: las listas ~ y ~ no son de la misma longitud"

#: list.d:1930
msgid "~: index ~ too large for ~"
msgstr "~: el índice ~ es demasiado grande para ~"

#: list.d:1988
msgid "~: start index ~ too large for ~"
msgstr "~: el índice :START ~ es demasiado grande para ~"

#: list.d:2031
msgid "~: end index ~ too large for ~"
msgstr "~: el índice :END ~ es demasiado grande para ~"

#: package.d:335
msgid "symbol ~ cannot be deleted from symbol table"
msgstr "el símbolo ~ no puede ser borrado de la tabla de símbolos"

#: package.d:594
msgid "Please choose:"
msgstr "Por favor, escoja:"

#: package.d:645
msgid "Please choose one of ~:{~A~:^, ~} ."
msgstr "Por favor, elija uno/a de ~:{~A~:^, ~} ."

#: package.d:708
msgid "~ inconsistent: symbol ~ is a shadowing symbol but not present"
msgstr "inconsistencia en ~: el símbolo ~ es un símbolo que eclipsa a otro/s, sin embargo no está presente."

#: package.d:741
msgid "Ignore the lock and proceed"
msgstr ""

#: package.d:742
msgid "~A(~S): ~S is locked"
msgstr ""

#: package.d:961
#, fuzzy
msgid "symbol ~A from ~A will become a shadowing symbol"
msgstr "el símbolo ~A del paquete #<PACKAGE ~A> se convertirá en un símbolo que eclipsa a otro"

#: package.d:991
msgid "You may choose the symbol in favour of which to resolve the conflict."
msgstr "Puede elegir el símbolo en favor del cual se resolverá el conflicto."

#: package.d:995
msgid "uninterning ~S from ~S uncovers a name conflict."
msgstr "Al sacar ~S de ~S se ha puesto de manifiesto un conflicto entre nombres."

#: package.d:1058 package.d:1252
msgid "You may choose how to proceed."
msgstr "Puede elegir cómo continuar."

#: package.d:1060
msgid "importing ~S into ~S produces a name conflict with ~S and other symbols."
msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S y otros símbolos."

#: package.d:1061
msgid "importing ~S into ~S produces a name conflict with ~S."
msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S."

#
# publicar está mal y ademas no es consistente con el mensaje d:329 en el que dice 'sacar'
# En este y en otros mensajes, el texto no es una orden dada al usuario, sino una opción que
# se le ofrece. Por tanto, no debe traducirse como un imperativo (impórtelo)  sino en
# infinitivo (importarlo). Pero deberías confirmar esto. - lsg
#
# Si, creo que tienes toda la razón, ... Entonces pongo `sacar' que
# aunque suene muy burro, creo que es muy, muy claro, ...
#
#: package.d:1067
msgid "((\"I\" \"import it and unintern the other symbol\" T) (\"N\" \"do not import it, leave undone\" NIL))"
msgstr "((\"I\" \"impórtarlo y sacar el otro símbolo\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Aquí tengo la misma duda anterior - lsg
#
#: package.d:1071
msgid "((\"I\" \"import it, unintern one other symbol and shadow the other symbols\" T) (\"N\" \"do not import it, leave undone\" NIL))"
msgstr "((\"I\" \"importarlo, sacar uno de los otro símbolos y eclipsar el resto\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Lo mismo de antes - lsg
#
#: package.d:1075
msgid "((\"I\" \"import it and shadow the other symbol\" T) (\"N\" \"do nothing\" NIL))"
msgstr "((\"I\" \"importarlo y eclipsar el otro símbolo\" T) (\"N\" \"no hacer nada\" NIL))"

#: package.d:1180
msgid "UNEXPORT in ~ is illegal"
msgstr "UNEXPORT en ~ es inválido"

#
# "UNEXPORT sólo funciona con símbolos accesibles, no con ~ en ~" - lsg
#
# Ya, o sea, que cambie "sobre" por "con". Vale, me gusta mucho más tu
# mensaje que el mío - cll
#
#: package.d:1199
msgid "UNEXPORT works only on accessible symbols, not on ~ in ~"
msgstr "UNEXPORT sólo funciona sobre símbolos accesibles, no con ~ en ~"

#: package.d:1253
msgid "symbol ~S should be imported into ~S before being exported."
msgstr "el símbolo ~S debe ser importado a ~S antes de ser exportado."

#
# La misma cuestión anterior entre imperativo e infinitivo - lsg
#
#: package.d:1259
msgid "((\"I\" \"import the symbol first\" T) (\"N\" \"do nothing, do not export the symbol\" NIL))"
msgstr "((\"I\" importar el símbolo primero\" T) (\"N\" \"no hacer nada, no exportar el símbolo\"))"

#: package.d:1295
msgid "You may choose in favour of which symbol to resolve the conflict."
msgstr "Puede elegir en favor de qué símbolo se debe resolver el conflicto."

#
# El segundo from deberia ser 'de', porque quiere decir que un símbolo
# a de un paquete A entra en conflicto con el símbolo b _del_ paquete
# B. Luego, debe ser 'de'.
#
#: package.d:1296
msgid "exporting ~S from ~S produces a name conflict with ~S from ~S."
msgstr "la exportación de ~S desde ~S produce un conflicto de nombres con ~S de ~S."

#: package.d:1303
msgid "Which symbol should be accessible in ~S ?"
msgstr "¿ Qué símbolo debe ser accesible en ~S ?"

#: package.d:1309
msgid "the symbol to export, "
msgstr "el símbolo a exportar, "

#: package.d:1321
msgid "the old symbol, "
msgstr "El símbolo original, "

#: package.d:1567
msgid "You may choose for every conflict in favour of which symbol to resolve it."
msgstr "Puede elegir en favor de qué símbolo se debe resolver cada conflicto."

#
# Es una traducción un poco libre (literalmente sería "el nombre = ~S
# entra en conflicto...."), pero ésta me parece más corta y correcta. - lsg
#
#: package.d:1571
msgid "~S name conflicts while executing USE-PACKAGE of ~S into package ~S."
msgstr "Conflicto de nombre ~S al ejecutar USE-PACKAGE de ~S al paquete ~S"

#: package.d:1583
msgid "which symbol with name ~S should be accessible in ~S ?"
msgstr "¿ Qué símbolo con nombre ~S debe ser accesible en ~S ?"

#: package.d:1827
msgid "The value of *PACKAGE* was not a package. Old value ~. New value ~."
msgstr "El valor de *PACKAGE* no era un paquete. Valor anterior ~. Nuevo valor ~."

#: package.d:1846
#, fuzzy
msgid "~: Package ~ has been deleted."
msgstr "El paquete ~ ha sido borrado."

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~S.",
# pienso que "No hay ningún paquete con el nombre ~S" es ligeramente
# mejor, ¿qué te parece? - cll
#
#: package.d:1858
#, fuzzy
msgid "~: There is no package with name ~"
msgstr "~S: No hay ningún paquete con el nombre ~S."

#: package.d:1875
msgid "~: argument should be a package or a package name, not ~"
msgstr "~: el argumento debe ser un paquete o el nombre de un paquete, no ~"

#: package.d:1986
msgid "~: there is already a package named ~"
msgstr "~: ya hay un paquete llamado ~"

#
# "~: el argumento debe ser un símbolo o una lista de símbolos, no ~" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: package.d:2221
msgid "~: argument should be a symbol or a list of symbols, not ~"
msgstr "~: el argumento debe ser un símbolo o una lista de símbolos, no ~"

#: package.d:2337
msgid "a package with name ~S already exists."
msgstr "ya existe un paquete con el nombre ~S."

#: package.d:2362
msgid "You can input another name."
msgstr "Puede introducir otro nombre."

#
# Si fuera inglés corriente, estaría bien tu traducción, pero es inglés
# 'telegráfico', y en realidad quieren decir lo que te he escrito, es
# decir, 'nuevo' afecta a 'nombre', no a 'paquete'.
#
# Eres un gran maestro, algo así como un quinto dan de las traducciones,
# ... ¡Tienes toda la razón! :) - cll
#
#: package.d:2363
msgid "Please input new package name:"
msgstr "Por favor, introduzca un nuevo nombre de paquete:"

#: package.d:2371
msgid "You can input another nickname."
msgstr "Puede introducir otro apodo."

#: package.d:2372
msgid "Please input new package nickname:"
msgstr "Por favor, introduzca un nuevo apodo de paquete:"

#: package.d:2428
msgid "Cannot change the case sensitiveness of ~."
msgstr "No es posible cambiar las mayúsculas/minúsculas de ~."

# Ojo con el ignorar. sv
#
# No, ya te he puesto antes las acepciones de esta palabra y esta vez,
# viene al caso, ... cll
#
# O sea, que estás 'ignorando ' la sugerencia de sv, ;-) - lsg
#
# Muy bueno, muy bueno, ... :) Santiago, por aquí hay mucho cachondeo :) - cll
#
#
#: package.d:2493
msgid "Ignore."
msgstr "Ignorar."

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~S.",
# pienso que "No hay ningún paquete con el nombre ~S" es ligeramente
# mejor, ¿qué te parece? - cll
#
#: package.d:2494
msgid "~S: There is no package with name ~S."
msgstr "~S: No hay ningún paquete con el nombre ~S."

#: package.d:2522
msgid "~*Delete ~S anyway."
msgstr ""

#
# Leo, en vez de "está siendo utilizado", ¿no crees que es mejor "es
# utilizado"? - cll
#
# Propongo *se utiliza*, es mucho más español. sv
#
# Pero, ¿cómo pones algo así? "~S se utiliza en ~{~S~^, ~}.", ¿por
# ejemplo? Es que el problema es que no ~S (el primero) no "se utiliza"
# en la segunda expresión, sino que la segunda expresión es una que
# emplea a la primera. No se si me explico, ...
#
# En cualquier caso, creo que tienes toda la razón al decir "es mucho
# más español", es que de hecho la expresión "es utilizado" aunque es
# correcta, no parece muy española, por favor, ¿sugerencias? - cll
#
#: package.d:2523
msgid "~S: ~S is used by ~{~S~^, ~}."
msgstr "~S: ~S es utilizado por ~{~S~^, ~}."

#: package.d:2680
#, fuzzy
msgid "~: ~ is not using ~"
msgstr "Esto no es una cadena: ~"

#: record.d:32
msgid "~: ~ is not a valid index into ~"
msgstr "~: ~ no es un índice válido en ~"

#: record.d:40
msgid "~: ~ is not a record"
msgstr "~: ~ no es un registro"

#: record.d:96 charstrg.d:2820
#, fuzzy
msgid "~: ~ ~ should be of type ~"
msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#: record.d:129
msgid "~: ~ is not a structure of type ~"
msgstr "~: ~ no es una estructura del tipo ~"

#: record.d:176
#, fuzzy
msgid "~: Slot ~ of ~ has no value"
msgstr "~: Una ranura de ~ no tiene valor"

#: record.d:276
msgid "~: ~ is not a closure"
msgstr "~: ~ no es una cerradura"

#: record.d:286
msgid "~: This is not a compiled closure: ~"
msgstr "~: No se trata de una cerradura compilada: ~"

#: record.d:354
msgid "~ is not a valid code-vector byte"
msgstr "~ no es un byte CODE-VECTOR válido"

#: record.d:365
#, fuzzy
msgid "~: invalid side-effect class ~ for function ~"
msgstr "~S: especificación inválida de ranura y función de acceso: ~S"

#: record.d:385
msgid "~: invalid code-vector ~"
msgstr "~: CODE-VECTOR inválido ~"

#: record.d:393
msgid "~: function ~ is too big: ~"
msgstr "~: la función ~ es demasiado grande: ~"

#: record.d:448
#, fuzzy
msgid "~: This is not a prototype of a generic function: ~"
msgstr "~: Ésta no es una función genérica: ~"

#: record.d:1444
msgid "~ method for ~ returned ~"
msgstr ""

#: sequence.d:236
msgid "There are no sequences of type ~"
msgstr "No hay secuencias del tipo ~"

#: sequence.d:322
msgid "~: sequence type forces length ~, but result has length ~"
msgstr ""

#: sequence.d:333
msgid "~: ~ should be an integer >=0, not ~"
msgstr "~: ~ debe ser un entero >=0, no ~"

#: sequence.d:377 sequence.d:404
msgid "~: ~ = ~ should not be greater than ~ = ~"
msgstr "~: ~ = ~ no debe ser mayor que ~ = ~"

#: sequence.d:549
msgid "~: the index should be a fixnum >=0, not ~"
msgstr "~: el índice debe ser un número >=0 del tipo FIXNUM, no ~"

#: sequence.d:832 sequence.d:1148
msgid "~: bad length ~"
msgstr "~: longitud incorrecta ~"

#: sequence.d:946
msgid "~: size should be an integer >=0, not ~"
msgstr "~: el tamaño debe ser un entero >=0, no ~"

#: sequence.d:953
msgid "~: :update must not be specified without :initial-element"
msgstr "~: no debe especificarse :update sin :initial-element"

#: sequence.d:2006
msgid "~: Must not specify both arguments to :TEST and :TEST-NOT"
msgstr "~: Los argumentos :TEST y :TEST-NOT no deben tener valor simultáneamente"

#: sequence.d:2125
msgid "~: sequence ~ is too long"
msgstr "~: la secuencia ~ es demasiado larga"

#: sequence.d:2594
msgid "too long sequence ~"
msgstr "secuencia demasiado larga ~"

#: charstrg.d:1458
msgid "~: the radix must be an integer between 2 and 36, not ~"
msgstr "~: la base debe ser un entero entre 2 y 36, no ~"

#: charstrg.d:1803
msgid "~: the code argument should be an integer, not ~"
msgstr "~: el argumento del código debe ser un entero y no ~"

# "~: no se puede convertir ~ al tipo character"
#
# No sé si traducir la palabra character, puesto que es una palabra
# clave en Lisp. - lsg
#
# Yo ya había traducido este mensaje como:
#
# "~: ~ no puede convertirse a un carácter"
#
# Pero el tuyo me gusta mucho más, salvo que `character', puesto que es
# un término definido en el estándar Common Lisp, debe ir en mayúsculas
# - cll
#
#: charstrg.d:1824
msgid "~: cannot coerce ~ to a character"
msgstr "~: no se puede convertir ~ al tipo CHARACTER"

#: charstrg.d:1857
msgid "~: the weight argument should be an integer, not ~"
msgstr "~: el argumento de ponderación debe ser un entero, y no ~"

#: charstrg.d:1893
msgid "~: argument should be an integer, not ~"
msgstr "~: el argumento debe ser un entero, no ~"

#: charstrg.d:1911
msgid "~: index should be an integer, not ~"
msgstr "~: el índice debe ser un entero, no ~"

#: charstrg.d:1914
msgid "~: ~-index should be an integer, not ~"
msgstr "~: el índice ~ debe ser un entero, no ~"

#: charstrg.d:1925
msgid "~: index should be NIL or an integer, not ~"
msgstr "~: el índice debe ser NIL o un entero, no ~"

#: charstrg.d:1928
msgid "~: ~-index should be NIL or an integer, not ~"
msgstr "~: el índice ~ debe ser NIL o un entero, no ~"

#: charstrg.d:1939
msgid "~: index should not be negative: ~"
msgstr "~: el índice no debe ser negativo: ~"

#: charstrg.d:1942
msgid "~: ~-index should not be negative: ~"
msgstr "~: el índice ~ no debe ser negativo: ~"

#: charstrg.d:1960
msgid "~: index ~ should not be greater than the length of the string"
msgstr "~: el índice ~ no debe ser mayor que la longitud de la cadena"

#: charstrg.d:1963
msgid "~: ~-index ~ should not be greater than the length of the string"
msgstr "~: el índice ~ = ~ no debe ser mayor que la longitud de la cadena"

#: charstrg.d:1982
msgid "~: index ~ should be less than the length of the string"
msgstr "~: el índice ~ debe ser menor que la longitud de la cadena"

#: charstrg.d:1985
msgid "~: ~-index ~ should be less than the length of the string"
msgstr "~: el índice ~ = ~ debe ser menor que la longitud de la cadena"

#: charstrg.d:2127
#, fuzzy
msgid "~: :START-index ~ must not be greater than :END-index ~"
msgstr "~: El índice :start ~ no debe ser mayor que el índice :end ~"

#: charstrg.d:2203
#, fuzzy
msgid "~: argument ~ should be a string, a symbol or a character"
msgstr "~: el argumento ~ debe ser del tipo string o string-char, o un símbolo"

#: charstrg.d:2241 charstrg.d:3258
msgid "~: :start-index ~ must not be greater than :end-index ~"
msgstr "~: El índice :start ~ no debe ser mayor que el índice :end ~"

#: charstrg.d:2290
msgid "~: :start1-index ~ must not be greater than :end1-index ~"
msgstr "~: El índice start1 ~ no debe ser mayor que el índice :end1 ~"

#: charstrg.d:2311
msgid "~: :start2-index ~ must not be greater than :end2-index ~"
msgstr "~: El índice :start2 ~ no debe ser mayor que el índice :end2 ~"

#: charstrg.d:2791
msgid "~: the string length ~ should be nonnegative fixnum"
msgstr ""
"~: la longitud de la cadena de caracteres ~ debe ser un número no negativo\n"
"del tipo FIXNUM"

#
# Duda: esta traducción ha sido muy difícil, y está basada en la
# traducción francesa que dice: "~: Mauvais mode de saut d'environnement
# ~."
#
#: debug.d:759
msgid "~: bad frame climbing mode ~"
msgstr "~: modo de salto de marco incorrecto"

#: debug.d:776
msgid "~: ~ is not a stack pointer"
msgstr "~: ~ no es un puntero de pila"

#: debug.d:966
msgid "~: ~ is not a pointer to an EVAL/APPLY frame"
msgstr "~: ~ no es un puntero a un marco de tipo EVAL/APPLY"

#: debug.d:1066
msgid ""
"\n"
"APPLY frame with breakpoint for call "
msgstr ""
"\n"
"marco APPLY con punto de ruptura para invocar "

#: debug.d:1070
msgid ""
"\n"
"APPLY frame for call "
msgstr ""
"\n"
"marco APPLY para invocar "

#: debug.d:1088
msgid ""
"\n"
"EVAL frame with breakpoint for form "
msgstr ""
"\n"
"marco EVAL con punto de ruptura para la forma "

#: debug.d:1092
msgid ""
"\n"
"EVAL frame for form "
msgstr ""
"\n"
"marco EVAL para la forma "

#
# A ver aquí, que hay mogollón, hay mogollón, ...
#
# Leo, tu opinas que aquí deberíamos traducir:
#
# "variables con vinculación de recintos (~ = dinámicamente):"
#
# Sin embargo, yo creo que lo más correcto es:
#
# "trama de ligadura de las variables (~ = dinámicamente):"
#
# Puesto que esto se refiere al tipo de tramas que hay en la pila,
# cuando ésta está siendo examinada. De hecho, la traducción francesa
# es:
#
# "Le «frame» de liaison de variables (~ signifiant dynamique) lie :"
#
# ..., que viene a ser algo como lo que he puesto yo. - cll
#
#: debug.d:1098
msgid ""
"\n"
"frame binding variables (~ = dynamically):"
msgstr ""
"\n"
"marco de ligadura de las variables (~ = dinámicamente):"

#: debug.d:1115
msgid ""
"\n"
"CALLBACK frame"
msgstr ""
"\n"
"marco CALLBACK"

#: debug.d:1120
msgid ""
"\n"
"frame binding variables "
msgstr ""
"\n"
"marco de ligadura de las variables"

#: debug.d:1123 debug.d:1149
msgid " binds (~ = dynamically):"
msgstr " vincula (~ = dinámicamente):"

#: debug.d:1145
msgid ""
"\n"
"frame binding functions "
msgstr ""
"\n"
"marco de ligadura de las funciones "

# Un poco más en español podría ser: "Entorno siguiente: " sv
#
# Hmmm, ..., aquí no estoy de acuerdo contigo. No me suena bien lo del
# "Entorno siguiente", ... cll
#
#: debug.d:1168 debug.d:1238
msgid ""
"\n"
"  Next environment: "
msgstr ""
"\n"
"  Siguiente entorno: "

#: debug.d:1194
msgid ""
"\n"
"compiled tagbody frame for "
msgstr ""
"\n"
"marco compilado del cuerpo de etiquetas de salto para "

#: debug.d:1198
msgid ""
"\n"
"compiled block frame for "
msgstr ""
"\n"
"marco de bloque compilado para "

#: debug.d:1204
msgid ""
"\n"
"block frame "
msgstr ""
"\n"
"marco de bloque"

#: debug.d:1207
msgid ""
"\n"
"nested block frame "
msgstr ""
"\n"
"marco anidado de bloque"

#: debug.d:1212
msgid " for "
msgstr " para "

#: debug.d:1217
msgid ""
"\n"
"tagbody frame "
msgstr ""
"\n"
"marco de cuerpo de etiquetas de salto"

# Duda: Aquí lo de `nested' es bastante puñetero. Creo que no debe
# traducirse por `anidado' (que no tendría demasiado sentido, creo),
# sino por `encajada', haciendo referencia a la trama a la que se llega
# por el uso de las etiquetas de salto, ...
#
# Sin embargo, no estoy demasiado seguro, ... aSocorro!! - cll
#
# A propósito de esta cuestión, pregunté en la lista de correo de CLisp:
#
# > `nested' have various meanings. It can mean that one thing is `into'
# > other one or that one thing is `joined' with other one. In this
# > message, I think you are talking about the frame you arrive when using
# > a tag, as if you were `joining' a new frame, is it so?
#
# Y la respuesta de Bruno Haible fue:
#
# No. In CLISP it's yet another (maybe new?) meaning. Interpretation frames
# are normally built up in the stack. However, when a closure is created,
# some parts of the frames must be moved out to the heap, so that the
# closure points to valid data, called "environment", even after the frame
# has been deestablished. We called this process "nesting" of a frame.
# Any better vocabulary? Can you propose a good german or french translation?
#
# Asi que, la verdad, "anidado" me parece correcto. Para ello, imaginaos
# una trama (o marco), de la que se "re-elabora" una parte denominada
# "entorno" pero que solo tiene sentido dentro de esta trama (o marco),
# puesto que se ha levantado un `closure'. - cll
#
#: debug.d:1220
msgid ""
"\n"
"nested tagbody frame "
msgstr ""
"\n"
"marco anidado del cuerpo de etiquetas de salto"

#: debug.d:1225
msgid " for"
msgstr " para"

#: debug.d:1251
msgid "~: environment is not an alist"
msgstr "~: el entorno no es una a-lista"

#
# Ésta estaba claramente mal - lsg
#
#: debug.d:1267
msgid ""
"\n"
"catch frame for tag "
msgstr ""
"\n"
"marco de captura para la etiqueta "

# Handler, otra buena.. Sugerencias? - lsg
#
# Duda: ¿cómo traducir `handler'?
#
# Pues bien, he elegido el término `manipulador' puesto que eso es,
# precisamente, lo que es un `handler' en Common Lisp. De hecho, el
# estándar Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr.,
# en la página 872 dice:
#
# "The process of signaling involves the search for an invocation of a
# handler, a piece of code that will attempt to deal appropiately with
# the situation"
#
# Y atención a la siguiente observación: (en la misma página, a
# continuación del párrafo anterior)
#
# "If a handle is found, it may either handle the situation, by
# performing some non-local transfer of control, or decline to handle
# it, by failing to perform a non-local transfer of control. If it
# declines, other handlers are sought".
#
# En fin, a la vista de esta definición y de la siguiente aclaración,
# propongo `manejador' para su traducción - cll
#
#: debug.d:1272
msgid ""
"\n"
"handler frame for conditions"
msgstr ""
"\n"
"marco de manipulación (HANDLER) para las condiciones"

#
# Estaba mal. Yo pondria: "recinto de unwind-protect" - lsg
#
# Y yo creo que si cambiamos `recinto' por `trama' ya es la leche de
# perfecto ;) - cll
#
# Leo, como puedes ver he cambiado en todos lados `trama' por `marco' - cll
#
#: debug.d:1285
msgid ""
"\n"
"unwind-protect frame"
msgstr ""
"\n"
"marco `unwind-protect'"

# Duda: Lo de `driver' lo dejo sin traducir, ...
#
# En la traducción francesa está sin traducir y en el estándar de Common
# Lisp no se hace ni la mas mínima referencia a algo que se llame así.
#
# "recinto de driver" - lsg
#
# Vale, ¡pero vamos!, que cambio `recinto' por `trama' - cll
#
#: debug.d:1289
msgid ""
"\n"
"\n"
"driver frame"
msgstr ""
"\n"
"\n"
"marco `driver'"

# "Entornos con vinculación de recintos" - lsg
#
# Aquí volvemos un poco a lo del mensaje constobj.d:915 Según creo,
# estos mensajes se refieren al tipo de tramas que hay en la pila, no se
# trata de un entorno (en el sentido que en Lisp tiene esta palabra).
#
# La traducción francesa dice:
#
# "«frame» de liaison d'environnements"
#
# ¿Que os parece?
#
#: debug.d:1293 debug.d:1298 debug.d:1303 debug.d:1308 debug.d:1313 debug.d:1318 debug.d:1325
msgid ""
"\n"
"frame binding environments"
msgstr ""
"\n"
"marco de ligadura del entorno"

#: debug.d:1340
msgid "~: unknown frame type"
msgstr "~: tipo de marco desconocido"

#: error.d:57
msgid "Unprintable error message"
msgstr "Mensaje de error no imprimible"

#: error.d:653
msgid "~: User break"
msgstr "~: Interrupción del usuario"

#: error.d:656
#, fuzzy
msgid "Continue execution"
msgstr "continuar la búsqueda"

#: error.d:658
#, fuzzy
msgid "~S: User break"
msgstr "~: Interrupción del usuario"

#: error.d:726 error.d:727
#, fuzzy
msgid "~: ~ comes from a previous Lisp session and is invalid"
msgstr "~ proviene de una sesion anterior de Lisp y es inválido"

#: error.d:767
msgid "~: A true list must not end with ~"
msgstr "~: Una auténtica lista no debe finalizar con ~"

# me comería el "y por ello", todo el mundo lo entenderá, y además no
# está en el original. sv
#
# No sólo eso, sino que además el mensaje queda demasiado largo. Ser
# mucho más cómodo, para quien esté trabajando, ver mensajes cortos,
# ... sugerencia aceptada. cll
#
#: error.d:804
#, fuzzy
msgid "~: ~ is a constant, may not be used as a variable"
msgstr "FUNCTION: ~ es una constante, no puede usarse como una variable"

# Duda: Nótese cómo la traducción dice `declararse SPECIAL'. Esto es
# así, porque en Common Lisp existe SPECIAL para declarar variables
# especiales. Por eso, si digo `declararse SPECIAL' estoy diciendo
# `declararse especial con SPECIAL', pero esto último me parece muy
# rebuscado, ¿o es lo correcto?
#
# La traducción es perfectamente fiel. Déjala así. sv
#
# Además, he quitado el "por ello". cll
#: error.d:820
#, fuzzy
msgid "~: ~ is not a symbol, cannot be declared ~"
msgstr "FUNCTION: ~ no es un símbolo, no puede declararse SPECIAL"

#: error.d:856
msgid "~: ~ may not be used as an environment"
msgstr "~: ~ no puede usarse como un entorno"

#: error.d:866 error.d:876
msgid "~: argument ~ should be a nonnegative fixnum"
msgstr "~: el argumento ~ debe ser un número no negativo del tipo fixnum"

#: error.d:904
#, fuzzy
msgid "~: ~ is not a non-negative ~"
msgstr "~: ~ no es el nombre de una función"

#: error.d:967
msgid "Attempt to modify a read-only string: ~"
msgstr ""

#: error.d:978
#, fuzzy
msgid "~: argument ~ is neither a string nor an integer"
msgstr "~: el argumento ~ no es un string"

#: error.d:999
msgid "~: argument ~ should be a stream of type ~"
msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#: error.d:1053
#, fuzzy
msgid "~: argument ~ is not a character set"
msgstr "~: el argumento ~ no es un carácter"

#: error.d:1071
#, fuzzy
msgid "~: keyword arguments in ~ should occur pairwise"
msgstr "EVAL/APPLY: los argumentos clave de ~ deben aparecer por pares"

#: error.d:1083
#, fuzzy
msgid "~: ~ marker ~ is not a ~"
msgstr "~: ~ no es un par"

#
# Yo pondría un guión entre argumento y clave. - lsg
#
# Hmm, o sea `argumento-clave'. No, no me gusta y de hecho, en el
# "Vocabulario bilingüe de términos técnicos" de "Lisp" (3ra edición) de
# Winston y Horn, los traductores al español ponen en la página 649:
#
# keyword arguments - argumentos clave
#
# sin guión por medio - cll
#
#: error.d:1106
msgid ""
"~: illegal keyword/value pair ~, ~ in argument list.\n"
"The allowed keywords are ~"
msgstr ""
"~: par argumento clave/valor inválido ~, ~ en la lista de argumentos.\n"
"Los parámetros clave permitidos son ~"

#: error.d:1155
msgid "~: undefined function ~"
msgstr "~: la función ~ no está definida"

#: error.d:1203
msgid "~: ~ is not a function name"
msgstr "~: ~ no es el nombre de una función"

#: error.d:1219
msgid ""
"~: argument ~ is not a function.\n"
"To get a function in the current environment, write (FUNCTION ...).\n"
"To get a function in the global environment, write (COERCE '... 'FUNCTION)."
msgstr ""

#: error.d:1233
#, fuzzy
msgid "EVAL/APPLY: Too many arguments (~ instead of at most ~) given to ~"
msgstr "~: Demasiados argumentos (~ en vez de ~) para ~"

#: error.d:1236
#, fuzzy
msgid "~: Too many arguments (~ instead of at most ~) given to ~"
msgstr "~: Demasiados argumentos (~ en vez de ~) para ~"

#: error.d:1251
#, fuzzy
msgid "EVAL/APPLY: Too few arguments (~ instead of at least ~) given to ~"
msgstr "~: Muy pocos argumentos (~ en vez de, al menos, ~) para ~"

#: error.d:1254
#, fuzzy
msgid "~: Too few arguments (~ instead of at least ~) given to ~"
msgstr "~: Muy pocos argumentos (~ en vez de, al menos, ~) para ~"

#: error.d:1269 error.d:1286
msgid "~: ~ is not an 8-bit number"
msgstr "~: ~ no es un número de 8 bits"

#: error.d:1303 error.d:1320
msgid "~: ~ is not a 16-bit number"
msgstr "~: ~ no es un número de 16 bits"

#: error.d:1337 error.d:1354
msgid "~: ~ is not an 32-bit number"
msgstr "~: ~ no es un número de 32 bits"

#: error.d:1371 error.d:1388
msgid "~: ~ is not an 64-bit number"
msgstr "~: ~ no es un número de 64 bits"

#: error.d:1409
msgid "~: ~ is not an `unsigned int' number"
msgstr "~: ~ no es un número del tipo `unsigned int'"

#: error.d:1430
msgid "~: ~ is not an `int' number"
msgstr "~: ~ no es un número del tipo `int'"

#: error.d:1451
msgid "~: ~ is not a `unsigned long' number"
msgstr "~: ~ no es un número del tipo `unsigned long'"

#: error.d:1472
msgid "~: ~ is not a `long' number"
msgstr "~: ~ no es un número del tipo `long'"

#: error.d:1489
msgid "~: ~ is not a single-float"
msgstr "~: ~ no es un SINGLE-FLOAT"

#: error.d:1506
msgid "~: ~ is not a double-float"
msgstr "~: ~ no es un DOUBLE-FLOAT"

#: errunix.d:56
msgid "Invalid multibyte or wide character"
msgstr ""

#: errunix.d:63
msgid "Operation not permitted"
msgstr "Operación no permitida"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
# "No existe ese archivo o directorio" - lsg
#
# Pues si, me gusta más la traducción de Leo, que la de Enrique, salvo
# que, tal y como tu mismo apuntas, Leo, se debe decir "fichero" y no
# "archivo" - cll
#
#: errunix.d:69
msgid "No such file or directory"
msgstr "No existe ese fichero o directorio"

#: errunix.d:75
msgid "No such process"
msgstr "No existe tal proceso"

#: errunix.d:81
msgid "Interrupted system call"
msgstr "Llamada al sistema interrumpida"

# Sugerencia: E/S. sv
#
# Vaya, tu sugerencia es tan informática que me impresiona que se me
# haya escapado. cll
#
#: errunix.d:87
msgid "I/O error"
msgstr "Error de E/S"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:93
msgid "No such device or address"
msgstr "Dispositivo no configurado"

#: errunix.d:99
msgid "Arg list too long"
msgstr "Lista de argumentos demasiado larga"

#: errunix.d:105
msgid "Exec format error"
msgstr "Formato de programa no ejecutable"

#: errunix.d:111
msgid "Bad file number"
msgstr "Número de fichero incorrecto"

# Sugerencia: No hay ningún proceso hijo. sv
#
# Bueno, Enrique tradujo este mensaje como "Ningún proceso hijo" en libc
# asi que, si te parece bien, lo pondré como él puesto que lo suyo es
# una traducción ya aceptada y que además, resulta de mezclar lo que yo
# he puesto y de tu sugerencia. cll
#
#: errunix.d:117
msgid "No child processes"
msgstr "Ningún proceso hijo"

#: errunix.d:123
msgid "No more processes"
msgstr "No hay más procesos"

#: errunix.d:129
msgid "Not enough memory"
msgstr "No hay memoria suficiente"

#: errunix.d:135
msgid "Permission denied"
msgstr "Permiso denegado"

#: errunix.d:141
msgid "Bad address"
msgstr "Dirección incorrecta"

# Pongo esto un poco más en español.
# Antes decía "Dispositivo de bloque requerido".
# Por cierto, en otros sitios hemos puesto "dispositivo de bloques".
# ¿cómo es? sv
#: errunix.d:147
msgid "Block device required"
msgstr "Se requiere un dispositivo de bloque"

#: errunix.d:153
msgid "Device busy"
msgstr "Dispositivo ocupado"

#: errunix.d:159
msgid "File exists"
msgstr "El fichero ya existe"

#: errunix.d:165
msgid "Cross-device link"
msgstr "Enlace cruzado entre dispositivos"

#: errunix.d:171
msgid "No such device"
msgstr "No existe tal dispositivo"

#: errunix.d:177
msgid "Not a directory"
msgstr "No es un directorio"

#: errunix.d:183
msgid "Is a directory"
msgstr "Es un directorio"

# ¿Por qué no inválido? La palabra existe.
# Un día os tengo que enviar un trozo de "1984" de Orwell,
# que habla de "neolengua", el único idioma del mundo que tiene
# cada vez menos palabras, en vez de más... sv
#
# a¡Por supuestísimo!!! Tienes toda la razón del mundo. De hecho, si
# echas un ojo al resto de los mensajes verás que yo siempre he
# traducido "invalid" por "inválido" salvo en tres ocasiones: en dos
# preferí la expresión "no es correcto" y en la otra lo dejé como "no es
# válido" en vez de "no válido" que, además, suena horrible.
#
# A propósito del trozo de "1984", venga, ya estoy esperando :) - cll
#
#: errunix.d:189
msgid "Invalid argument"
msgstr "Argumento inválido"

#: errunix.d:195
msgid "File table overflow"
msgstr "Desbordamiento de la tabla de ficheros"

#: errunix.d:201
msgid "Too many open files"
msgstr "Demasiados ficheros abiertos"

#: errunix.d:207
msgid "Inappropriate ioctl for device"
msgstr "El dispositivo no acepta la llamada `ioctl'"

#: errunix.d:213
msgid "Text file busy"
msgstr "Fichero de texto en uso"

#: errunix.d:219
msgid "File too large"
msgstr "Fichero demasiado grande"

#: errunix.d:225
msgid "No space left on device"
msgstr "No queda espacio en el dispositivo"

#: errunix.d:231
msgid "Illegal seek"
msgstr "Desplazamiento inválido"

#: errunix.d:237
msgid "Read-only file system"
msgstr "Sistema de ficheros de sólo lectura"

#: errunix.d:243
msgid "Too many links"
msgstr "Demasiados enlaces"

#: errunix.d:249
msgid "Broken pipe, child process terminated or socket closed"
msgstr ""

#: errunix.d:259
msgid "Argument out of domain"
msgstr "Argumento fuera del dominio"

#
# "El resultado es demasiado grande" - lsg
#
# Si, ya he cambiado `largo' por `grande' en todos los mensajes. Un
# fallo realmente infantil :( - cll
#
#: errunix.d:265
msgid "Result too large"
msgstr "El resultado es demasiado grande"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:272
msgid "Operation would block"
msgstr "La operación se bloquearía"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:278
msgid "Operation now in progress"
msgstr "Operación en curso"

# Already sería "ya". aún sería still.
# Sugerencia: La operación ya se está realizando. sv
#
# Más aún, echando un ojo a la traducción de Enrique Melero en el glibc,
# me he encontrado con el mismo mensaje y el dice: "La operación ya se
# está llevando a cabo". Me gusta bastante. cll
#
#: errunix.d:284
msgid "Operation already in progress"
msgstr "La operación ya se está llevando a cabo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:291
msgid "Too many levels of symbolic links"
msgstr "Demasiados niveles de enlaces simbólicos"

#: errunix.d:297
msgid "File name too long"
msgstr "Nombre de fichero demasiado largo"

#: errunix.d:303
msgid "Directory not empty"
msgstr "El directorio no está vacío"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:310
msgid "Stale NFS file handle"
msgstr "Fichero NFS bloqueado"

# Duda: Aquí he seguido el consejo de Enrique Melero.
#
# En la versión 1.5 he decidido cambiar el término `camino' por
# `trayectoria', tal y como recomiendan los traductores del libro Lisp,
# (3ra edición) de Winston y Horn en el "Vocabulario bilingüe de
# términos técnicos", en la página 650.
#
#: errunix.d:316
msgid "Too many levels of remote in path"
msgstr "Demasiados niveles de profundidad en la trayectoria"

#: errunix.d:323
msgid "Socket operation on non-socket"
msgstr "Operación de `sockets' sobre un \"no-socket\""

#: errunix.d:329
msgid "Destination address required"
msgstr "Se necesita la dirección del destino"

#: errunix.d:335
msgid "Message too long"
msgstr "Mensaje demasiado largo"

#: errunix.d:341
msgid "Protocol wrong type for socket"
msgstr "Tipo de protocolo incorrecto para el `socket'"

#: errunix.d:347
msgid "Option not supported by protocol"
msgstr "Opción no soportada por el protocolo"

#: errunix.d:353
msgid "Protocol not supported"
msgstr "Protocolo no soportado"

#: errunix.d:359
msgid "Socket type not supported"
msgstr "Tipo de `socket' no soportado"

# Pongo `socket' en vez de socket. sv
#: errunix.d:365
msgid "Operation not supported on socket"
msgstr "Acción no permitida en un `socket'"

#: errunix.d:371
msgid "Protocol family not supported"
msgstr "Familia de protocolos no soportada"

#: errunix.d:377
msgid "Address family not supported by protocol family"
msgstr "Familia de direcciones no soportada por el protocolo"

#: errunix.d:383
msgid "Address already in use"
msgstr "Dirección en uso"

# Sugerencia: No se puede asignar. sv
#
# ¡Vale!, "No puede asignarse ..." es demasiado, ..., ¿impersonal? cll
#: errunix.d:389
msgid "Cannot assign requested address"
msgstr "No se puede asignar la dirección requerida"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#: errunix.d:395
msgid "Network is down"
msgstr "La red no está operativa"

#: errunix.d:401
msgid "Network is unreachable"
msgstr "No es posible conectarse con la red"

#: errunix.d:407
msgid "Network dropped connection on reset"
msgstr "Se ha perdido la conexión con la red debido a una reinicialización"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#: errunix.d:413
msgid "Software caused connection abort"
msgstr "El software ha provocado la interrupción de la conexión"

#: errunix.d:419
msgid "Connection reset by peer"
msgstr "Conexión reinicializada por el otro extremo"

#
# Duda: ¿Y buffer? ¿Como traduzco buffer?
#
# Yo he visto a menudo 'memoria tampón', que es el término usado por los
# franceses. - lsg
#
# Tienes toda la razón, ... Sin embargo, en este caso, la traducción
# francesa es:
#
# "Pas d'espace disponible pour un buffer"
#
# Además, como en spanglish.txt pone:
#
# "buffer - memoria intermedia, tampón, buffer"
#
# pues he utilizado `buffer' tal cual, ... - cll
#
#: errunix.d:425
msgid "No buffer space available"
msgstr "No queda espacio en el buffer"

# Lo de socket, si te parece. sv
#
# Te digo lo mismo que te dije antes. Cuando hay finalizado con la
# traducción me pondré a cambiar todas estas cosas con macros. cll
#
#: errunix.d:431
msgid "Socket is already connected"
msgstr "El `socket' ya está conectado"

#: errunix.d:437
msgid "Socket is not connected"
msgstr "El `socket' no está conectado"

# Añado comitas a `socket'. Es una especie de convenio que seguimos
# cuando no nos queda más remedio que poner la palabra inglesa.
# Así al menos reconocemos que es una palabra extraña. sv
#: errunix.d:443
msgid "Cannot send after socket shutdown"
msgstr "No se puede enviar después de la ruptura del `socket'"

#: errunix.d:449
msgid "Too many references: cannot splice"
msgstr ""

# Duda: ¿ Se excedió el tiempo para la conexión ?
#: errunix.d:455
msgid "Connection timed out"
msgstr "Se excedió el tiempo para la conexión"

#: errunix.d:461
msgid "Connection refused"
msgstr "Conexión rechazada"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#: errunix.d:466
#, fuzzy
msgid "Remote peer released connection"
msgstr "El software ha provocado la interrupción de la conexión"

# Estas dos darán que hablar, pero otro día las discutiremos... sv
#
# Al decir tú eso, he leído la traducción de este término en libc
# (traducido por Enrique Melero) y, madre mía, me he quedado
# "flipao". Aquello fue una discusión encarnizada, ...
#
# Para mas inri, yo no estoy de acuerdo con ninguno de los dos :) Verás,
# un host puede estar "caído" (que así es como se suele decir aunque es,
# evidentemente, incorrecto) y por ello no tiene por qué no estar
# operativo (en libc lo habeis traducido como "el `host' no est
# operativo"). De hecho, puede estar operando pero, por algún problema
# de la red o de tu propia transmisión, resultar inalcanzable, ... En
# fin, por este motivo prefiero "El `host' no está disponible"
#
# Por otra parte, no estoy muy de acuerdo con Enrique, ..., a mí lo de
# poner host no me gusta. Ciertamente, un `host' no tiene por qué ser un
# servidor, necesariamente, pero es el caso más común. En cualquier
# caso, todo el mundo comprende perfectamente que el `host' es un
# servidor. cll
#
#: errunix.d:471
msgid "Host is down"
msgstr "El servidor no está disponible"

# Aquí, pues idem de idem, ... :) cll
#
#: errunix.d:477
msgid "Host is unreachable"
msgstr "No se puede conectar con el servidor"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#: errunix.d:482
#, fuzzy
msgid "Networking error"
msgstr "La red no está operativa"

#: errunix.d:488
msgid "Too many processes"
msgstr "Demasiados procesos"

#: errunix.d:494
msgid "Too many users"
msgstr "Demasiados usuarios"

#: errunix.d:500
msgid "Disk quota exceeded"
msgstr "Cuota de disco excedida"

#: errunix.d:507
msgid "Not a stream device"
msgstr "No es un dispositivo de flujo"

#: errunix.d:513
msgid "Timer expired"
msgstr "El temporizador expiró"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:519
msgid "Out of stream resources"
msgstr "Alcanzado el límite de recursos de `streams'"

#: errunix.d:525
msgid "No message of desired type"
msgstr "No hay mensajes del tipo deseado"

#: errunix.d:531
msgid "Not a data message"
msgstr "No es un mensaje de datos"

#: errunix.d:538
msgid "Identifier removed"
msgstr "Identificador desechado"

# Duda: Eso del `inter-bloqueo' ¿estará bien?
#
#: errunix.d:545
msgid "Resource deadlock would occur"
msgstr "Podría ocurrir un interbloqueo entre recursos"

# Duda: Aunque Bruno Haible me ha asegurado que la etiqueta
# sys_errlist[ENOLCK] del glibc.po en español contiene la traduccion que
# yo debiera usar, me he decidido por las indicaciones de Santiago Vila
# en su respuesta a mi mail y he puesto, simplemente: "No quedan
# registros de bloqueo disponibles"
#
#: errunix.d:551
msgid "No record locks available"
msgstr "No quedan registros de bloqueo disponibles"

#: errunix.d:558
msgid "Machine is not on the network"
msgstr "La máquina no está en la red"

#: errunix.d:564 errunix.d:570
msgid "Object is remote"
msgstr "El objeto es remoto"

#: errunix.d:576
msgid "Link has been severed"
msgstr "El enlace ha sido destruído"

#: errunix.d:582
msgid "Advertise error"
msgstr "Error de anuncio"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:588
msgid "Srmount error"
msgstr "Error de `srmount'"

#: errunix.d:594
msgid "Communication error on send"
msgstr "Error de comunicaciones en el envío"

#: errunix.d:600
msgid "Protocol error"
msgstr "Error de protocolo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:606
msgid "Multihop attempted"
msgstr "Se ha intentado un multihop"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:618
msgid "Remote address changed"
msgstr "La dirección remota ha cambiado"

#: errunix.d:625
msgid "Function not implemented"
msgstr "Función no implementada"

#: errunix.d:654
msgid "UNIX error "
msgstr "Error de Unix "

# Cambio librería por el término oficial. sv
#
# Uuuffffff, ..., aquí sí que podríamos discutir hasta la muerte. Pero
# bueno, se queda como tú lo has puesto. cll
#
#: errunix.d:656
msgid "UNIX library error "
msgstr "Error de biblioteca Unix "

#: errwin32.d:3873
msgid "Win32 error "
msgstr "Error de Win32 "

#: errwin32.d:3922
msgid "Winsock error "
msgstr "Error de `winsock'"

#: misc.d:110
msgid "This file was produced by another lisp version, must be recompiled."
msgstr "Este fichero fue producido por otra versión de lisp. Debe recompilarse."

#: misc.d:426
msgid "~ (~ ~): out of memory"
msgstr ""

#: misc.d:481
msgid "~: type of attribute ~ is unsupported"
msgstr "~: el tipo de atributo ~ no está soportado"

#: misc.d:494
msgid "ANSI C program"
msgstr "programa ANSI C"

#: misc.d:501
msgid "GNU C++ "
msgstr "GNU C++"

#: misc.d:503
msgid "GNU C "
msgstr "GNU C "

#: misc.d:509
msgid "C++ compiler"
msgstr "Compilador de C++"

#: misc.d:511
msgid "C compiler"
msgstr "Compilador de C"

#: time.d:854 intlog.d:632
msgid "~: too large shift amount ~"
msgstr "~: el tamaño del desplazamiento es muy grande ~"

#: predtype.d:1661 predtype.d:1859
msgid "~: unidentifiable type!!!"
msgstr "~: a¡tipo irreconocible!!!"

#: predtype.d:1864
msgid "~: type ~ does not correspond to a class"
msgstr "~: el tipo ~ no se corresponde con una clase"

#: predtype.d:1892
msgid "~: ~ does not name a class"
msgstr "~: ~ no es el nombre de una clase"

#: predtype.d:1914
msgid "~: type definition for ~ exceeds depth limit, maybe recursive"
msgstr ""

#: predtype.d:2226
#, fuzzy
msgid "~: invalid type specification ~"
msgstr "~S: la especificación de tipo ~S es inválida"

#: predtype.d:2233
msgid "~: ~ cannot be coerced to type ~"
msgstr "~: ~ no puede convertirse al tipo ~"

#: symbol.d:13
msgid "~: the property list of ~ has an odd length"
msgstr "~: la lista de propiedades de ~ tiene longitud impar"

#: symbol.d:23
msgid "~: the property list ~ has an odd length"
msgstr "~: la lista de propiedades ~ tiene longitud impar"

#: symbol.d:97
msgid "~: ~ is not a system function"
msgstr "~: ~ no es una función del sistema"

#: symbol.d:352 intlog.d:513
msgid "~: index ~ is negative"
msgstr "~: el índice ~ es negativo"

#: symbol.d:363
msgid "~: invalid argument ~"
msgstr "~: el argumento ~ es inválido"

#: symbol.d:377
msgid "The value of *GENSYM-COUNTER* was not a nonnegative integer. Old value ~. New value ~."
msgstr "El valor de *GENSYM-COUNTER* no era un entero no negativo. Valor anterior ~. Nuevo valor ~."

#: lisparit.d:322
msgid "~: argument should be a positive fixnum, not ~"
msgstr "~: el argumento debe ser un número positivo del tipo FIXNUM, no ~"

#: lisparit.d:1564
#, fuzzy
msgid "~: the value of ~ should be a ~, not ~"
msgstr "~: el valor de ~ debe ser un RANDOM-STATE, no ~"

#: lisparit.d:1586
msgid "~: argument should be positive and an integer or float, not ~"
msgstr "~: el argumento debe ser un número positivo del tipo INTEGER o FLOAT, no ~"

#: aridecl.d:336
msgid "division by zero"
msgstr "división entre cero"

#: aridecl.d:344
msgid "floating point overflow"
msgstr "desbordamiento de coma flotante"

# Duda: Lo del desbordamiento inferior de coma flotante ha sido
# traducción super libre mía ;) Este mensaje ocurre cuando el resultado
# (expresado en coma flotante) ocurre mucho más cerca del cero de lo que
# permite la representación de números en coma flotante. Por ejemplo:
# 2.3e-30 * 2.3e-30 sería 5.29e-60 que excedió el límite inferior.
#
#: aridecl.d:352
msgid "floating point underflow"
msgstr "desbordamiento inferior de coma flotante"

#: intelem.d:193 intelem.d:281
msgid "not a 32-bit integer: ~"
msgstr "no es un entero de 32 bits: ~"

#: intelem.d:365 intelem.d:503
msgid "not a 64-bit integer: ~"
msgstr "no es un entero de 64 bits: ~"

#: intelem.d:1317
msgid "bignum overflow"
msgstr "desbordamiento de números grandes"

#: intlog.d:404
msgid "~: ~ is not a valid boolean operation"
msgstr "~: ~ no es una operación lógica válida"

# Duda: En Lisp existe un tipo predeterminado: `fixnum'. Por ese motivo,
# dejo sin traducir este término.
#
#: intbyte.d:13
msgid "The arguments to BYTE must be fixnums >=0: ~, ~"
msgstr "Los argumentos de BYTE deben ser números enteros del tipo FIXNUM >=0: ~, ~"

#: intbyte.d:34
msgid "~ is not a BYTE specifier"
msgstr "~ no es un especificador de BYTE"

#: intmal.d:6
msgid "overflow during multiplication of large numbers"
msgstr "desbordamiento durante la multiplicación de números grandes"

#: intdiv.d:361
msgid "quotient ~ / ~ is not an integer"
msgstr "el cociente ~ / ~ no es un entero"

# Duda: long-float es un tipo, así que lo dejo como `LONG-FLOAT'. Aunque
# Bruno Haible y Marcus Daniels lo han puesto como `long float' se
# refieren al tipo `long-float'
# Sugerencia: `long float'. sv
#
# No estoy de acuerdo con la sugerencia. No se trata de que `long' sea
# un adjetivo de `float', sino que en CLisp existe el tipo "long-float"
# (Common Lisp The Language, 2nd edition, Guy L. Steele, pag. 39). De
# hecho, en muchos otros sitios de CLisp se pone "long-float". Más aún,
# la traducción francesa de este mensaje es: "LONG-FLOAT trop long".
#
# De hecho, en mi opinion, Bruno Haible y Marcus Daniels se equivocaron
# aquí y debían haber puesto el guión. cll
#
#: lfloat.d:5
msgid "long float too long"
msgstr "LONG-FLOAT demasiado largo"

#: flo_konv.d:436
msgid "floating point NaN occurred"
msgstr "aparición de NaN en coma flotante"

#: flo_rest.d:39
msgid ""
"Floating point operation combines numbers of different precision.\n"
"See ANSI CL 12.1.4.4 and the CLISP impnotes for details.\n"
"The result's actual precision is controlled by\n"
"~S.\n"
"To shut off this warning, set ~S to ~S."
msgstr ""
"Las operaciones en coma flotante combinan números de diferentes precisiones.\n"
"Para más detalles, consulte ANSI CL 12.1.4.4 y las notas de implementación de\n"
"CLISP.\n"
"La precisión actual del resultado está controlada por\n"
"~S.\n"
"Para eliminar este aviso, establezca el valor de ~S a ~S."

#: affi.d:79
msgid "~: Unsupported call mechanism: ~"
msgstr "~: mecanismo de llamado no soportado: ~"

#: affi.d:88
msgid "~: Bad function prototype: ~"
msgstr "~: Prototipo de función incorrecto: ~"

#: affi.d:97
msgid "~: Wrong number of arguments for prototype ~"
msgstr "~: número incorrecto de argumentos para el prototipo ~"

#: affi.d:107
msgid "~: Bad argument for prototype ~: ~"
msgstr "~: Argumento incorrecto para el prototipo ~: ~"

#: affi.d:116
msgid "~: Bad argument: ~"
msgstr "~: El argumento ~ es inválido"

#: affi.d:137
msgid "~: ~ is not a valid address"
msgstr "~: ~ no es una dirección válida"

#: foreign.d:19
#, fuzzy
msgid "~: argument is not a foreign object: ~"
msgstr "~: el argumento no es una variable extranjera: ~"

#: foreign.d:49
#, fuzzy
msgid "~: argument ~ should be a ~, ~ or ~"
msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#: foreign.d:103
msgid "~: must not invalidate the sole FFI session pointer"
msgstr ""

#: foreign.d:109
#, fuzzy
msgid "~: cannot resurrect the zombie ~"
msgstr "~: no se puede escribir en ~"

#: foreign.d:178
msgid "A foreign variable ~ already exists"
msgstr "La variable extranjera ~ ya existe"

# Duda: he traducido `foreign' por `ajeno/a'.
#
# Lo he pensado mejor y `extranjera' me gusta mucho más, ..., ¿qué os
# parece? cll
#
#: foreign.d:213
msgid "A foreign function ~ already exists"
msgstr "La función extranjera ~ ya existe"

#: foreign.d:257
msgid "illegal foreign data type ~"
msgstr "el tipo de datos extranjero ~ es inválido"

#: foreign.d:265
msgid "~ cannot be converted to the foreign type ~"
msgstr "~ no puede ser compartido al tipo extranjero ~"

#: foreign.d:273
msgid "64 bit integers are not supported on this platform and with this C compiler: ~"
msgstr "los enteros de 64 bits no están soportados en esta arquitectura, para este compilador de C:"

#: foreign.d:398
msgid "~ cannot be converted to a foreign function with another calling convention."
msgstr "~ no puede ser convertido a una función extranjera con otra convención de llamada."

#: foreign.d:931
#, fuzzy
msgid "~: element type has size 0: ~"
msgstr "el tipo del elemento tiene tamaño 0: ~"

#: foreign.d:2075
msgid "~: argument is not a foreign variable: ~"
msgstr "~: el argumento no es una variable extranjera: ~"

#: foreign.d:2080
msgid "~: foreign variable with unknown type, missing DEF-C-VAR: ~"
msgstr "~: variable externa de tipo desconocido, se ha omitido DEF-C-VAR: ~"

#: foreign.d:2092
msgid "A foreign variable ~ does not exist"
msgstr "La variable extranjera ~ no existe"

#: foreign.d:2102
msgid "~: foreign variable ~ does not have the required size or alignment"
msgstr "~: la variable externa ~ no tiene el tamaño o alineamiento requerido"

#: foreign.d:2114
msgid "~: type specifications for foreign variable ~ conflict: ~ and ~"
msgstr "~: conflicto de especificación de tipo de la variable extranjera ~: ~ y ~"

#: foreign.d:2162
msgid "~: foreign variable ~ may not be modified"
msgstr "~: no se puede modificar la variable externa ~"

#: foreign.d:2208
msgid "~: foreign variable ~ of type ~ is not an array"
msgstr "~: la variable externa ~ del tipo ~ no es una matriz"

#: foreign.d:2285
msgid "~: foreign variable ~ of type ~ is not a pointer"
msgstr "~: la variable externa ~ del tipo ~ no es un puntero"

#: foreign.d:2391
msgid "~: foreign variable ~ of type ~ is not a struct or union"
msgstr "~: la variable externa ~ del tipo ~ no es, ni una estructura, ni una unión"

#: foreign.d:2398
msgid "~: foreign variable ~ of type ~ has no component with name ~"
msgstr "~: la variable externa ~ del tipo ~ no tiene ningún componente con el nombre ~"

#: foreign.d:2468 foreign.d:2645 foreign.d:3826
msgid "~: foreign variable ~ does not have the required alignment"
msgstr "~: la variable externa ~ no tiene el alineamiento requerido"

#: foreign.d:2700
msgid "~: ~ has no type, :FULL is illegal"
msgstr ""

#: foreign.d:2717
msgid "~: argument is not a foreign function: ~"
msgstr "~: el argumento no es una función extranjera: ~"

#: foreign.d:2723
msgid "~: foreign function with unknown calling convention, missing DEF-CALL-OUT: ~"
msgstr "~: función externa con convención de llamada desconocida, se ha omitido DEF-CALL-OUT: ~"

#: foreign.d:2738 foreign.d:3849
msgid "~: illegal foreign function type ~"
msgstr "~: tipo de función externa inválido ~"

#: foreign.d:2744
msgid "~: A foreign function ~ does not exist"
msgstr "~: La función extranjera ~ no existe"

#: foreign.d:2749
msgid "~: calling conventions for foreign function ~ conflict"
msgstr "~: conflicto en la convención de llamada de la función externa ~"

#: foreign.d:3025
msgid "~: :OUT argument is not a pointer: ~"
msgstr "~: el argumento :OUT no es un puntero: ~"

#: foreign.d:3636
#, fuzzy
msgid "~: Cannot open library ~: ~"
msgstr "~: No se puede abrir la biblioteca ~"

#: foreign.d:3638
msgid "~: Cannot open library ~"
msgstr "~: No se puede abrir la biblioteca ~"

#: foreign.d:3674 foreign.d:3675
#, fuzzy
msgid "~: no dynamic object named ~ in library ~"
msgstr "~: No se puede abrir la biblioteca ~"

#: foreign.d:3781
msgid "~: ~ is not a library"
msgstr "~: ~ no es una biblioteca"

#: init.lisp:393
#, fuzzy
msgid "special operator"
msgstr "una forma especial"

#: init.lisp:394
msgid "macro"
msgstr "macro"

#: init.lisp:395
msgid "function"
msgstr "función"

#: init.lisp:443
#, fuzzy
msgid "~a: redefining ~a ~s in ~a, was defined in ~a"
msgstr "~S: redefiniendo ~S; ¡estaba siendo rastreada!"

#: init.lisp:453
#, fuzzy
msgid "~S is a special operator and may not be redefined."
msgstr "~S es una forma especial y por ello, no puede ser redefinida"

# Junto las ¡! sv
# Sugerencia "¡Se estaba trazando!" (es como más "en español") sv
#
# Sí, tu sugerencia me gusta. Como se nota que tienes experiencia, ...,
# ¿eh? cll
#
#: init.lisp:466
msgid "DEFUN/DEFMACRO: redefining ~S; it was traced!"
msgstr "DEFUN/DEFMACRO: redefiniendo ~S; ¡se estaba rastreando!"

#: init.lisp:479
msgid "~S is impossible in compiled code"
msgstr "~S es imposible en código compilado"

#: init.lisp:547
msgid "~S is an invalid function environment"
msgstr "~S es un entorno de función inválido"

#: init.lisp:589
msgid "~S is an invalid variable environment"
msgstr "~S es un entorno de variable inválido"

#: init.lisp:649
msgid "~S: ~S is illegal since ~S is a local macro"
msgstr "~S: ~S es inválido, puesto que ~S es una macro local"

#: init.lisp:652
msgid "~S: invalid function environment ~S"
msgstr "~S: ~S es un entorno de función inválido"

#: init.lisp:656
msgid "~S: ~S is invalid since ~S is not a symbol"
msgstr "~S: ~S es incorrecto, puesto que ~S no es un símbolo"

#: init.lisp:810
msgid "code after MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de MACROLET contiene una lista punteada que termina con ~S"

#: init.lisp:822
msgid "illegal syntax in MACROLET: ~S"
msgstr "sintaxis inválida en MACROLET: ~S"

#: init.lisp:842
msgid "code after SYMBOL-MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de SYMBOL-MACROLET contiene una lista punteada que termina con ~S"

#: init.lisp:852 compiler.lisp:5625
msgid "~S: symbol ~S must not be declared SPECIAL and a macro at the same time"
msgstr "~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo"

#: init.lisp:865 compiler.lisp:5623
#, fuzzy
msgid "~S: symbol ~S is declared special and must not be declared a macro"
msgstr "~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo"

#: init.lisp:870
msgid "illegal syntax in SYMBOL-MACROLET: ~S"
msgstr "sintaxis inválida en SYMBOL-MACROLET: ~S"

#: init.lisp:902
msgid "bad function environment occurred in ~S: ~S"
msgstr "se encontró un entorno de función incorrecto en ~S: ~S"

#: init.lisp:909
msgid "~S: invalid form ~S"
msgstr "~S: forma inválida ~S"

#: init.lisp:924
msgid "code contains a dotted list, ending with ~S"
msgstr "el código contiene una lista punteada que termina con ~S"

#: init.lisp:961
msgid "~S: ~S should be a lambda expression"
msgstr "~S: ~S debe ser una expresión lambda"

#: init.lisp:993
msgid "lambda list must not end with the atom ~S"
msgstr "la lista lambda no debe terminar con el átomo ~S"

#: init.lisp:1020 init.lisp:1035
msgid "~S: variable list ends with the atom ~S"
msgstr "~S: la lista de variables termina con el átomo ~S"

#: init.lisp:1129
msgid "FLET/LABELS: code contains a dotted list, ending with ~S"
msgstr "FLET/LABELS: el código contiene una lista punteada que termina con ~S"

#: init.lisp:1137
msgid "illegal syntax in FLET/LABELS: ~S"
msgstr "sintaxis inválida en FLET/LABELS: ~S"

#: init.lisp:1155
#, fuzzy
msgid "FUNCTION-MACRO-LET: code contains a dotted list, ending with ~S"
msgstr "El código de COND contiene una lista punteada que termina con ~S"

#: init.lisp:1166
#, fuzzy
msgid "illegal syntax in FUNCTION-MACRO-LET: ~S"
msgstr "sintaxis inválida en MACROLET: ~S"

#: init.lisp:1271
msgid "~s: compiled file ~s lacks a version marker"
msgstr ""

#: init.lisp:1273
msgid "~s: compiled file ~s has a corrupt version marker ~s"
msgstr ""

#: init.lisp:1275
msgid "~s: compiled file ~s has an older version marker"
msgstr ""

#: init.lisp:1324
#, fuzzy
msgid "~S: A file with name ~A does not exist"
msgstr "No existe ningún fichero con el nombre ~A"

#: init.lisp:1348
msgid "Loading file "
msgstr "Cargando el fichero \""

#: init.lisp:1383 defs1.lisp:424
#, fuzzy
msgid "Loaded file "
msgstr "Cargando el fichero \""

#: init.lisp:1391
msgid "~S: ~S is not a symbol."
msgstr "~S: ~S no es un símbolo."

#: init.lisp:1400
msgid "~S: missing function name and/or parameter list"
msgstr "~S: no se ha indicado el nombre de la función y/o la lista de parámetros"

#: init.lisp:1408
#, fuzzy
msgid "~S: special operator ~S cannot be redefined."
msgstr "~S: la forma especial ~S no puede ser redefinida."

#: init.lisp:1440 macros1.lisp:126
msgid "exit clause in ~S must be a list"
msgstr "la cláusula exit en ~S debe ser una lista"

#: init.lisp:1591
msgid "~S: cannot define a function from that: ~S"
msgstr "~: no es posible definir una función a partir de ~S"

#: init.lisp:1595 clos.lisp:2765 clos.lisp:2813
msgid "~S: the name of a function must be a symbol, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

#: init.lisp:1599
msgid "~S: function ~S is missing a lambda list"
msgstr "~S: la función ~S debe tener una lista lambda"

#: init.lisp:1799 condition.lisp:1314 reploop.lisp:463
msgid "If you continue (by typing 'continue'): "
msgstr "Si continúa (tecleando `continue'): "

#: backquote.lisp:135
msgid "~S: unquotes may occur only in (...) or #(...) forms"
msgstr ""

# Duda: Aquí, igual que en el caso de la traducción francesa, he
# preferido preservar el término `backquote' y ---porque así se ha
# decidido en Spanish GNU Translation Team---, el término está con
# comillas simples.
#
# He tomado esta decisión porque el `backquote' (que es la tilde
# invertida `) es un término muy familiar para todos los programadores
# de Lisp que, con toda seguridad, conocerán.
#
#: backquote.lisp:152
msgid "~S: comma is illegal outside of backquote"
msgstr "~S: la coma es inválida fuera del `backquote'"

#: backquote.lisp:156
msgid "~S: more commas out than backquotes in, is illegal"
msgstr "~S: no se pueden emplear más comas fuera que apóstrofes invertidos dentro"

#: backquote.lisp:160
#, fuzzy
msgid "~S: unquotes may not occur in structures"
msgstr "~: ~ no es una estructura"

#: backquote.lisp:164
msgid "~S: unquotes may not occur in arrays"
msgstr ""

#: backquote.lisp:182
#, fuzzy
msgid "~athe syntax `,@form is undefined behavior"
msgstr "La sintaxis ,@forma es válida únicamente en las listas"

#: backquote.lisp:185
#, fuzzy
msgid "~athe syntax `,.form is undefined behavior"
msgstr "La sintaxis ,.forma es válida únicamente en las listas"

#: backquote.lisp:192
msgid "~athe syntax `( ... . ,@form) is undefined behavior"
msgstr ""

#: backquote.lisp:195
msgid "~athe syntax `( ... . ,.form) is undefined behavior"
msgstr ""

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# A partir de la versión 1997-05-03, este mensaje ha cambiado y se
# refiere a elementos que serán ignorados. Como no puede anticiparse
# cual será el género del objeto que se ignora, he preferido poner lo de
# os/as. ¿Qué os parece?
#
#: defmacro.lisp:37
msgid "Both will be ignored."
msgstr "Ambos/as serán ignorados/as."

#: defmacro.lisp:38
msgid "Invalid keyword-value-pair: ~S ~S"
msgstr "Par argumento clave y valor inválido: ~S ~S"

#: defmacro.lisp:45
msgid "The macro ~S may not be called with ~S arguments: ~S"
msgstr "La macro ~S no puede ser invocada con ~S argumentos: ~S"

#: defmacro.lisp:109 defmacro.lisp:146 defmacro.lisp:231
msgid "The rest of the lambda list will be ignored."
msgstr "El resto de la lista lambda será ignorado."

#: defmacro.lisp:110
msgid "The lambda list of macro ~S contains a dot after &AUX."
msgstr "La lista lambda de la macro ~S contiene un punto después de &AUX"

#: defmacro.lisp:115
msgid "in macro ~S: ~S may not be used as &AUX variable."
msgstr "en la macro ~S: ~S no debe usarse como una variable &AUX."

#: defmacro.lisp:124
#, fuzzy
msgid "~S: invalid supplied-p variable ~S"
msgstr "~S: especificación inválida de ranura y variable: ~S"

#: defmacro.lisp:147
msgid "The lambda list of macro ~S contains a dot after &KEY."
msgstr "La lista lambda de la macro ~S contiene un punto después de &KEY"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
#: defmacro.lisp:155 defmacro.lisp:169 defmacro.lisp:296 defmacro.lisp:308 defmacro.lisp:312
msgid "It will be ignored."
msgstr "Será ignorado."

#: defmacro.lisp:156
msgid "The lambda list of macro ~S contains a badly placed ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S mal situado."

#: defmacro.lisp:170
msgid "The lambda list of macro ~S contains the invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene el elemento inválido ~S"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# No tengo ni idea de qué significa ese "0*"
#: defmacro.lisp:182
msgid "~0*It will be ignored."
msgstr "Será ignorado."

#: defmacro.lisp:183
msgid "The lambda list of macro ~S contains an invalid keyword specification ~S"
msgstr "La lista lambda de la macro ~S contiene una especificación de argumento clave inválida: ~S"

#: defmacro.lisp:215
msgid "The lambda list of macro ~S is missing a variable after &REST/&BODY."
msgstr "La lista lambda de la macro ~S necesita una variable después de &REST/&BODY."

#: defmacro.lisp:224
msgid "The lambda list of macro ~S contains an illegal variable after &REST/&BODY: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable inválida después de &REST/&BODY: ~S"

#: defmacro.lisp:232
msgid "The lambda list of macro ~S contains a misplaced dot."
msgstr "La lista lambda de la macro ~S contiene un punto mal situado."

# Ojo. sv
#
# :) Vale :) cll
#
#: defmacro.lisp:236
msgid "They will be ignored."
msgstr "Serán ignorados."

#: defmacro.lisp:237
msgid "The lambda list of macro ~S contains superfluous elements: ~S"
msgstr "La lista lambda de la macro ~S contiene elementos innecesarios: ~S"

#: defmacro.lisp:278
msgid "The lambda list of macro ~S contains an illegal &REST variable: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable &REST inválida: ~S"

#: defmacro.lisp:292
msgid "The lambda list of macro ~S contains an invalid &WHOLE: ~S"
msgstr "La lista lambda de la macro ~S contiene un &WHOLE inválido: ~S"

#: defmacro.lisp:297
msgid "The lambda list of macro ~S contains a superfluous ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S innecesario."

#: defmacro.lisp:309
msgid "The lambda list of macro ~S contains ~S before &KEY."
msgstr "La lista lambda de la macro ~S contiene ~S antes de &KEY."

#: defmacro.lisp:313
msgid "The lambda list of macro ~S contains ~S which is illegal here."
msgstr "La lista lambda de la macro ~S contiene ~S, lo cual es incorrecto aquí."

#: defmacro.lisp:329
msgid "The lambda list of macro ~S contains an invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene un elemento inválido: ~S"

#: defmacro.lisp:375
#, fuzzy
msgid "~S: ~S does not match lambda list element ~S"
msgstr "Elemento inválido en lista lambda ~S"

#: defmacro.lisp:394
msgid "In the lambda list of macro ~S, &ENVIRONMENT must be followed by a non-NIL symbol: ~S"
msgstr "En la lista lambda de la macro ~S, &ENVIRONMENT debe estar seguido de un símbolo no nulo: ~S"

#: defmacro.lisp:409
msgid "Cannot define a macro from that: ~S"
msgstr "No se puede definir una macro a partir de: ~S"

#: defmacro.lisp:413
msgid "The name of a macro must be a symbol, not ~S"
msgstr "El nombre de una macro debe ser un símbolo, no ~S"

#: defmacro.lisp:417
msgid "Macro ~S is missing a lambda list."
msgstr "La macro ~S necesita una lista lambda."

#: macros1.lisp:19 macros1.lisp:37
msgid "~S: non-symbol ~S cannot be a variable"
msgstr "~S: sólo los símbolos pueden ser variables, y no ~S"

#: macros1.lisp:23 macros1.lisp:41
msgid "~S: the constant ~S must not be redefined to be a variable"
msgstr "~S: la constante ~S no debe redefinirse como una variable"

#: macros1.lisp:52
#, fuzzy
msgid "~S: non-symbol ~S cannot be defined constant"
msgstr "~S: ~S no es un símbolo, y por lo tanto no puede definirse como una constante"

#: macros1.lisp:80
msgid "~S redefines the constant ~S. Its old value was ~S."
msgstr "~S redefine la constante ~S. Su valor anterior era ~S."

#: macros1.lisp:130
msgid "Invalid syntax in ~S form: ~S."
msgstr "Sintaxis inválida en la forma ~S: ~S."

#: macros1.lisp:228 places.lisp:421 places.lisp:644
msgid "~S called with an odd number of arguments: ~S"
msgstr "~S ha sido invocado con un número impar de argumentos: ~S"

#: macros1.lisp:264
msgid "~S: missing key list"
msgstr "~S: falta la lista de claves"

#: macros1.lisp:270
msgid "~S: the ~S clause must be the last one"
msgstr "~S: la clausula ~S debe ser la última"

#: macros1.lisp:317 macros1.lisp:376
msgid "Not a list of COND clauses: ~S"
msgstr "No es una lista de cláusulas COND: ~S"

#: macros1.lisp:321 macros1.lisp:380
msgid "The atom ~S must not be used as a COND clause."
msgstr "El átomo ~S no debe usarse como una cláusula COND."

#: macros1.lisp:350
msgid "COND code contains a dotted list, ending with ~S"
msgstr "El código de COND contiene una lista punteada que termina con ~S"

#: macros1.lisp:355 compiler.lisp:5666
msgid "COND clause without test: ~S"
msgstr "Cláusula COND sin prueba condicional: ~S"

#: macros2.lisp:10
msgid "Invalid clause in ~S: ~S"
msgstr "Cláusula inválida en ~S: ~S"

#: macros2.lisp:23
msgid "~A~%The value is: ~S"
msgstr "~A~%El valor es: ~S"

#: macros2.lisp:26
msgid "The value of ~S should be ~:[of type ~S~;~:*~A~]."
msgstr "El valor de ~S debe ser ~:[del tipo ~S~;~:*~A~]."

#: macros2.lisp:29
#, fuzzy
msgid "You may input a new value for ~S."
msgstr "Puede introducir un nuevo valor."

#: macros2.lisp:31
msgid "You may input a value to be used instead~@[ of ~S~]."
msgstr ""

#: macros2.lisp:33
msgid "~%New ~S: "
msgstr "~%Nuevo ~S: "

#: macros2.lisp:50
msgid "Retry"
msgstr "Reintentar"

#: macros2.lisp:52
#, fuzzy
msgid "You may input new values for ~S."
msgstr "Puede introducir nuevos valores."

#: macros2.lisp:55
msgid "~S must evaluate to a non-NIL value."
msgstr "~S no puede evaluarse como NIL."

#: macros2.lisp:82
msgid "The value of ~S must be of one of the types ~{~S~^, ~}"
msgstr "El valor de ~S debe ser de uno de los tipos ~{~S~^, ~}"

#: macros2.lisp:86
msgid "The value of ~S must be one of ~{~S~^, ~}"
msgstr "El valor de ~S debe ser uno de los siguientes ~{~S~^, ~}"

#: macros2.lisp:101 condition.lisp:1165
msgid "~S used as a key in ~S, it would be better to use parentheses."
msgstr "~S es usado como una clave en ~S, sería mejor utilizar paréntesis."

#: macros2.lisp:171
msgid "type name should be a symbol, not ~S"
msgstr "el nombre del tipo debe ser un símbolo, no ~S"

#: macros2.lisp:175
msgid "~S is a built-in type and may not be redefined."
msgstr "~S es un tipo predefinido y no puede ser redefinido."

#: macros2.lisp:202
msgid "The deftype expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de DEFTYPE para ~S no puede invocarse con ~S argumentos."

#: macros2.lisp:209
msgid "~S: the name of a symbol macro must be a symbol, not ~S"
msgstr "~S: el nombre de un símbolo de macro debe ser un símbolo, no ~S"

#: macros2.lisp:221
msgid "~S: the symbol ~S names a global variable"
msgstr "~S: el símbolo ~S nombra una variable global"

#: defs1.lisp:83
msgid "missing symbol types (~S/~S/~S) in ~S"
msgstr ""

#: defs1.lisp:89
#, fuzzy
msgid "~S: flag must be one of the symbols ~S, ~S, ~S, not ~S"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: defs1.lisp:398
msgid "~S: ~S does not name a logical host"
msgstr "~S: ~S no es el nombre de un anfitrión \"lógico\""

#: defs1.lisp:417
#, fuzzy
msgid "Loading logical hosts from file "
msgstr "La carga del fichero "

#: defs1.lisp:431
msgid "Defined logical host "
msgstr ""

#: defs1.lisp:441
#, fuzzy
msgid "Loading logical host "
msgstr "La carga del fichero "

#: defs1.lisp:443
#, fuzzy
msgid " from file "
msgstr " de la fuente ~S"

#: defs1.lisp:448
msgid " done"
msgstr ""

#: defs1.lisp:481
msgid "No translations for logical host ~S found"
msgstr ""

#: defs1.lisp:542
msgid "~S: argument ~S should be a nonnegative number"
msgstr "~S: el argumento ~S debe ser un número no negativo"

#: defs1.lisp:691
msgid "incorrect date: ~S.~S.~S, ~Sh~Sm~Ss, time zone ~S"
msgstr "fecha incorrecta: ~S/~S/~S, ~Sh~Sm~Ss, zona horaria ~S"

#: places.lisp:24
msgid "The function (~S ~S) is hidden by a SETF expander."
msgstr "Una función de expansión de SETF oculta a la función (~S ~S)"

#: places.lisp:76
msgid "The argument ~S to ~S should be a keyword."
msgstr "El argumento ~S de ~S debe ser un argumento clave."

# Lo mismo de antes. A lo mejor se puede poner "modificable setf". sv
#: places.lisp:128
#, fuzzy
msgid "~S: Argument ~S is not a SETF place."
msgstr "El argumento ~S no es un lugar `setf' modificable"

#: places.lisp:136
msgid "SETF place ~S produces more than one store variable."
msgstr "El lugar `setf' ~ genera más de una variable de almacenamiento."

#: places.lisp:177
#, fuzzy
msgid "The name of the accessor must be a symbol, not ~S"
msgstr "El nombre de la función de acceso debe ser un símbolo, no ~S"

# Duda: En esta y otras partes de este archivo .po aparece la expresión
# `expander' (¡expansor es horrible!). Me dio muchisimos quebraderos de
# cabeza, pero muchos y francamente, estaba absolutamente atascado
# cuando lo pregunté en las listas de Spanish GNU y CLisp.
#
# Curiosamente, la única persona que respondió no tiene ni idea de
# español (Bruno Haible):
#
# "expander" or "expansion function", I would say.
#
# ¡Pues leches, eso mismo! Función de expansión me suena
# perfectísimamente, ...
#
#: places.lisp:212
msgid "The SETF expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de SETF para ~S no puede invocarse con ~S argumentos."

#: places.lisp:254
#, fuzzy
msgid "~S: Too many arguments: ~S"
msgstr "~: se han entregado demasiados argumentos a ~"

#: places.lisp:257
#, fuzzy
msgid "~S: The documentation string must be a string: ~S"
msgstr "~S: La cadena de control debe ser una cadena, y no ~S"

#: places.lisp:266
#, fuzzy
msgid "~S: Missing store variable."
msgstr "~S: variable ausente"

#: places.lisp:311
#, fuzzy
msgid "(~S ~S): Illegal syntax."
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: places.lisp:327
#, fuzzy
msgid "~S: index ~S is too large for ~S"
msgstr "~: el índice ~ es demasiado grande para ~"

#: places.lisp:510
#, fuzzy
msgid "~S ~S: &REST variable ~S should be a symbol."
msgstr "~S: la variable ~S debe ser un símbolo"

#: places.lisp:515
#, fuzzy
msgid "~S(~S): Only one variable is allowed after &REST, not ~S"
msgstr "Sólo se permite una variable después de &REST, no ~S"

#: places.lisp:519
#, fuzzy
msgid "Illegal in a ~S lambda list: ~S"
msgstr "Lista lambda inválida en DEFINE-MODIFY-MACRO: ~S"

#: places.lisp:525
#, fuzzy
msgid "~S: lambda list may only contain symbols and lists, not ~S"
msgstr "la lista lambda sólo puede contener símbolos y listas, no ~S"

#: places.lisp:640
#, fuzzy
msgid "~S: Illegal place: ~S"
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: places.lisp:656
#, fuzzy
msgid "~S: too few arguments: ~S"
msgstr "Muy pocos argumentos para ~S"

#: places.lisp:816 places.lisp:876
#, fuzzy
msgid "~S is only defined for functions of the form #'symbol."
msgstr "SETF APPLY sólo está definido para funciones de la forma #'símbolo."

# Duda: en Common Lisp existe lo que se denominan los `setf places'. En
# realidad, es una manera bastante correcta de referirse a posiciones de
# memoria (cuyos nombres pueden ser variables, funciones, etc.) que son
# modificables con la primitiva SETF de Lisp. Por ello, traducirlo como
# `modificable' es eminentemente correcto, pero en realidad me da miedo
# porque a los programadores experimentados les mosqueará lo de
# `modificable' a secas. Les resultará mucho más familiar algo como
# `setf modificables', aunque en español esto suene bastante
# regular. cll
#
# En cualquier caso, cuando uno se empeña en emplear la palabra inglesa,
# siempre queda la posibilidad de conservar la sintaxis española,
# por ejemplo: "... no es un lugar modificable `setf'" sv
#
#: places.lisp:822
#, fuzzy
msgid "~S on ~S is not a SETF place."
msgstr "APPLY de ~S no es un lugar `setf' modificable"

#: places.lisp:923
msgid "SETF place ~S expects different numbers of values in the true and false branches (~D vs. ~D values)."
msgstr ""

#: floatprint.lisp:314
msgid "argument is not a float: ~S"
msgstr "el argumento no es un número en coma flotante: ~S"

#: type.lisp:32
msgid "~S: invalid type specification ~S"
msgstr "~S: la especificación de tipo ~S es inválida"

#: type.lisp:91 compiler.lisp:6764
msgid "~S: argument to SATISFIES must be a symbol: ~S"
msgstr "~S: el argumento de SATISFIES debe ser un símbolo: ~S"

#: type.lisp:373 type.lisp:382 type.lisp:392 type.lisp:402
msgid "~S: argument to ~S must be *, ~S or a list of ~S: ~S"
msgstr "~S: el argumento de ~S debe ser *, ~S o una lista de ~S: ~S"

#: type.lisp:486
msgid "~S: argument to MOD must be an integer: ~S"
msgstr "~S: el argumento de MOD debe ser un entero: ~S"

#: type.lisp:494
msgid "~S: argument to SIGNED-BYTE must be an integer or * : ~S"
msgstr "~S: el argumento de SIGNED-BYTE debe ser un entero o * : ~S"

#: type.lisp:504
msgid "~S: argument to UNSIGNED-BYTE must be an integer or * : ~S"
msgstr "~S: el argumento de UNSIGNED-BYTE debe ser un entero o * : ~S"

#: type.lisp:1320 condition.lisp:137
msgid "~S: type ~S is not a subtype of ~S"
msgstr "~S: el tipo ~S no es un subtipo de ~S"

#: defstruct.lisp:375
msgid "~S: invalid syntax for name and options: ~S"
msgstr "~S: la sintáxis del nombre y las opciones es inválida: ~S"

#: defstruct.lisp:397
msgid "~S ~S: argument list should be a list: ~S"
msgstr "~S ~S: la lista de argumentos debe ser una lista: ~S"

#: defstruct.lisp:415
msgid "~S ~S: At most one :INCLUDE argument may be specified: ~S"
msgstr "~S ~S: Sólo puede especificarse un argumento :INCLUDE como mucho: ~S"

#: defstruct.lisp:422
msgid ""
"~S: Use of ~S implicitly applies FUNCTION.~@\n"
"                                     Therefore using ~S instead of ~S."
msgstr ""
"~S: El uso de ~S aplica, implícitamente, FUNCTION.~@\n"
"                                     Por lo tanto, se utilizará ~S en vez de ~S."

#: defstruct.lisp:434 condition.lisp:107
msgid "~S ~S: unknown option ~S"
msgstr "~S ~S: opción ~S desconocida"

#: defstruct.lisp:437 clos.lisp:2881 condition.lisp:111
msgid "~S ~S: invalid syntax in ~S option: ~S"
msgstr "~S ~S: la sintaxis de la opción ~S es inválida: ~S"

#: defstruct.lisp:440 clos.lisp:2826 condition.lisp:114
msgid "~S ~S: not a ~S option: ~S"
msgstr "~S ~S: no se trata de una opción ~S: ~S"

# Duda: (y además gorda) Podría parecer que el siguiente mensaje debiera
# traducirse por:
#
# ~S ~S: No hay ningún :PREDICATE sobre estructuras sin nombre.
#
# Sin embargo, el manual "Common Lisp, The Language - 2nd Edition", en
# la página 477 advierte que, en realidad, la opción :PREDICATE no debe
# usarse con estructuras sin nombre:
#
# `A predicate can be defined only if the structure is "named"'
#
# Por lo tanto, he preferido traducir este mensaje de otra manera, tal y
# como veis:
#
#: defstruct.lisp:462
msgid "~S ~S: There is no :PREDICATE on unnamed structures."
msgstr "~S ~S: No puede definirse un :PREDICATE sobre estructuras sin nombre."

#: defstruct.lisp:483
msgid "~S ~S: invalid :TYPE option ~S"
msgstr "~S ~S: opción :TYPE inválida ~S"

#: defstruct.lisp:488
msgid "~S ~S: The :INITIAL-OFFSET must be a nonnegative integer, not ~S"
msgstr "~S ~S: El :INITIAL-OFFSET debe ser un entero no negativo, y no ~S"

#: defstruct.lisp:493
msgid "~S ~S: :INITIAL-OFFSET must not be specified without :TYPE : ~S"
msgstr "~S ~S: El :INITIAL-OFFSET no debe especificarse sin :TYPE : ~S"

#: defstruct.lisp:510
msgid "~S ~S: included structure ~S has not been defined."
msgstr "~S ~S: la estructura incluida ~S no ha sido definida."

#: defstruct.lisp:521
msgid "~S ~S: included structure ~S must be of the same type ~S."
msgstr "~S ~S: la estructura incluida ~S debe ser del tipo ~S."

#: defstruct.lisp:545
msgid "~S ~S: included structure ~S has no component with name ~S."
msgstr "~S ~S: la estructura incluida ~S no tiene ninguna componente con el nombre ~S."

#: defstruct.lisp:569
msgid "~S ~S: The READ-ONLY slot ~S of the included structure ~S must remain READ-ONLY in ~S."
msgstr "~S ~S: La ranura READ-ONLY ~S de la estructura incluida ~S debe permanecer READ-ONLY en ~S."

#: defstruct.lisp:578
msgid "~S ~S: The type ~S of slot ~S should be a subtype of the type defined for the included strucure ~S, namely ~S."
msgstr "~S ~S: El tipo ~S de la ranura ~S debe ser un subtipo del que ha sido definido para la estructura incluida ~S, a saber, ~S."

#: defstruct.lisp:583 defstruct.lisp:669
msgid "~S ~S: ~S is not a slot option."
msgstr "~S ~S: ~S no es una opción de ranura."

#: defstruct.lisp:608
msgid "~S ~S: structure of type ~S cannot hold the name."
msgstr "~S ~S: una estructura del tipo ~S no puede contener el nombre."

#: defstruct.lisp:653
msgid "~S ~S: There may be only one slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura con el nombre ~S."

#: defstruct.lisp:657
msgid "~S ~S: Slot ~S accessor will shadow the predicate."
msgstr ""

#: format.lisp:73
msgid "The control string terminates within a directive."
msgstr "La cadena de control termina en una directiva."

#: format.lisp:130
msgid "~A must introduce a number."
msgstr "~A debe introducir un número."

#: format.lisp:139
msgid "The control string terminates in the middle of a parameter."
msgstr "La cadena de control termina en medio de un parámetro."

#: format.lisp:214
msgid "Non-existent directive"
msgstr "Directiva no existente"

#: format.lisp:221
msgid "Closing '/' is missing"
msgstr ""

#: format.lisp:235
#, fuzzy
msgid "There is no package with name ~S"
msgstr "No hay ningún paquete con el nombre ~"

#: format.lisp:253
msgid "The closing directive '~A' does not have a corresponding opening one."
msgstr "No existe una directiva de apertura para la de cierre `~A'."

#: format.lisp:257
msgid "The closing directive '~A' does not match the corresponding opening one. It should read '~A'."
msgstr "La directiva de cierre `~A' no se corresponde con la de apertura. Debe leerse `~A'."

#: format.lisp:264 format.lisp:1478 format.lisp:2272
msgid "The ~~; directive is not allowed at this point."
msgstr "La directiva ~~; no está permitida aquí."

#: format.lisp:272
msgid "The ~~newline directive cannot take both modifiers."
msgstr "La directiva ~~newline no puede tomar ambos modificadores."

# Ojo: Estos "ing" no son siempre gerundios.
# Tal vez sea simplemente "...; se esperaba '~A'." sv
#
# Bueno, ..., cuando el mensaje ha salido es que se ha producido un
# error. En tal caso, no se puede estar `esper*ando*', sino que se
# esperaba, ... Si, creo que tienes toda la razón. cll
#
#: format.lisp:289
msgid "An opening directive is never closed; expecting '~A'."
msgstr "No se ha cerrado una directiva; se esperaba `~A'."

#: format.lisp:312
msgid "~%Current point in control string:"
msgstr "~%Posición en curso en la cadena de control:"

# Duda: `fill pointer' (puntero de llenado, o de relleno) es un
# recurso que existe en Common Lisp (y por lo tanto, en CLisp) para
# determinar qué parte de un vector está en uso (la que hay desde el
# principio hasta la posición apuntada por el `fill pointer'). Se trata
# de un término que cualquier programador en Lisp debe conocer porque
# esta palabra clave se utiliza en ocasiones, incluso, como palabra
# reservada para indicar una determinada opción en algunas funciones.
#
# Por ese motivo, he decidido dejarla tal cual, sin traducir. Cuando
# pregunté a Bruno Haible sobre esto me respondió:
#
# Imagine a device attached to a bottle or tank, which shows how much full
# the bottle is, in percent. How would you call this device?
#
# ... y francamente, ¡no se me ocurre como!
#
# Bueno, con el tiempo he decidido que (tal y como señala Bruno Haible)
# lo mejor sería: "puntero de relleno".
#
#: format.lisp:348
msgid "The destination string ~S should have a fill pointer."
msgstr "La cadena de destino ~S debe tener un puntero de relleno."

#: format.lisp:353
msgid "The destination argument ~S is invalid (not NIL or T or a stream or a string)."
msgstr "El argumento destino no es NIL, ni tampoco T, un flujo o una cadena: ~S"

#: format.lisp:378 format.lisp:2520
msgid "~S: The control-string must be a string, not ~S"
msgstr "~S: La cadena de control debe ser una cadena, y no ~S"

#: format.lisp:388
msgid "There are not enough arguments left for this directive."
msgstr "No hay argumentos suficientes para esta directiva."

#: format.lisp:472
msgid "The ~~:@R directive requires an integer in the range 1 - 4999, not ~S"
msgstr "La directiva ~~:@R necesita un entero en el rango 1 - 4999, no ~S"

#: format.lisp:487
msgid "The ~~@R directive requires an integer in the range 1 - 3999, not ~S"
msgstr "La directiva ~~@R necesita un entero en el rango 1 - 3999, no ~S"

#: format.lisp:544
msgid "The argument for the ~~R directive is too large."
msgstr "El argumento de la directiva ~~R es demasiado grande."

#: format.lisp:1187
msgid "The ~~R and ~~:R directives require an integer argument, not ~S"
msgstr "Las directivas ~~R y ~~:R necesitan un argumento entero, no ~S"

#: format.lisp:1206
msgid "The ~~C directive requires a character argument, not ~S"
msgstr "La directiva ~~C necesita un carácter como argumento, no ~S"

#: format.lisp:1424
msgid "The control string argument for the ~~? directive is invalid: ~S"
msgstr "La cadena de control de la directiva ~~? es inválida: ~S"

#: format.lisp:1428
msgid "The argument list argument for the ~~? directive is invalid: ~S"
msgstr "El argumento de la lista de argumentos de la directiva ~~? es inválido: ~S"

#: format.lisp:1482
msgid "The ~~[ parameter must be an integer, not ~S"
msgstr "El parámetro para ~~[ debe ser un entero, no ~S"

#: format.lisp:1496
msgid "The ~~[ directive cannot take both modifiers."
msgstr "La directiva ~~[ no puede tomar ambos modificadores."

#: format.lisp:1518
msgid "The ~~{ directive requires a list argument, not ~S"
msgstr "La directiva ~~{ requiere una lista de argumentos, no ~S"

#: format.lisp:1642
msgid "~~<...~~:> not implemented yet"
msgstr ""

#: format.lisp:1669
msgid "Prefix for logical block must be constant"
msgstr ""

#: format.lisp:1681
msgid "Logical block suffix must be constant"
msgstr ""

#: format.lisp:2034
msgid "Too many arguments for this directive"
msgstr "Demasiados argumentos para esta directiva"

#: format.lisp:2434
#, fuzzy
msgid "Error: ~~:@> not implemented"
msgstr "función no implementada"

#: international.lisp:47
msgid "Language ~S is not defined"
msgstr "El lenguaje ~S no está definido"

#: international.lisp:57
msgid "Language ~S inherits from ~S"
msgstr "El lenguaje ~S hereda de ~S"

#: international.lisp:107
msgid "~S: Language ~S is not defined"
msgstr "~S: El lenguaje ~S no está definido"

#: international.lisp:130
msgid "~S ~S: no value for default language ~S"
msgstr "~S ~S: no hay ningún valor para el lenguaje por defecto ~S"

#: savemem.lisp:65
msgid "Wrote the memory image into "
msgstr ""

#: trace.lisp:71
#, fuzzy
msgid "~s: no local name ~s in ~s"
msgstr "~: anfitrión ~ desconocido en ~"

#: trace.lisp:84
#, fuzzy
msgid "~S: ~S must name a closure"
msgstr "~: ~ no es una cerradura"

#: trace.lisp:102
#, fuzzy
msgid "~S: ~S must be a closure"
msgstr "~: ~ no es una cerradura"

#: trace.lisp:154
#, fuzzy
msgid "~s: ~s is not a function name"
msgstr "~: ~ no es el nombre de una función"

#: trace.lisp:166
msgid "~S: undefined function ~S"
msgstr "~S: la función ~S no está definida"

#: trace.lisp:168
#, fuzzy
msgid "~S: cannot trace special operator ~S"
msgstr "~S: no es posible rastrear la forma especial ~S"

#: trace.lisp:194
msgid "~&;; Tracing ~:[function~;macro~] ~S."
msgstr "~&;; Rastreando la ~:[función~;macro~] ~S."

#: trace.lisp:325
msgid "~S: ~S was traced and has been redefined!"
msgstr "~S: ¡~S estaba siendo rastreada y ha sido redefinida!"

# Aquí también junto las exclamaciones. sv
#: compiler.lisp:662
msgid "Compiler bug!! Occurred in ~A~@[ at ~A~]."
msgstr "aError del compilador!! Ocurrió en ~A~@[ en ~A~]."

# Soy alérgico al verbo "ignorar". Ignorar en español significa no saber.
# Y eso en inglés se dice "not to know".
# Posibilidades: Descartar, no tener en cuenta. sv
#
# :) Bueno, ... :) Lo cierto es que en el diccionario pone:
#
# "No saber una cosa o muchas cosas, o, de lo contrario, no tener
# noticia de ellas."
#
# O sea, que algo se ignora si no se tienen noticias de ello, ... Creo
# que la traducción está, por lo tanto, correcta. Ahora bien, "no tener
# en cuenta" o "descartar" también me parece muy correcto así que, ¿por
# qué no iba a cambiarlo? :) cll
#
#: compiler.lisp:1310
msgid "Bad declaration syntax: ~S~%Will be ignored."
msgstr "Sintaxis de la declaración incorrecta:~S~%No se tendrá en cuenta."

#: compiler.lisp:1327
msgid "Non-symbol ~S may not be declared SPECIAL."
msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#: compiler.lisp:1334
msgid "Non-symbol ~S may not be declared IGNORE."
msgstr "El \"no símbolo\" ~S no debe declararse IGNORE."

#: compiler.lisp:1341
msgid "Non-symbol ~S may not be declared IGNORABLE."
msgstr "El \"no-símbolo\" ~S no debe declararse IGNORABLE."

#: compiler.lisp:1348
#, fuzzy
msgid "Non-symbol ~S may not be declared READ-ONLY."
msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#: compiler.lisp:1351
msgid "Unknown declaration ~S.~%The whole declaration will be ignored."
msgstr "Declaración desconocida ~S.~%La declaración completa será ignorada."

#: compiler.lisp:1709
#, fuzzy
msgid " in file ~S"
msgstr " en la línea ~D"

#: compiler.lisp:1711
msgid " in line ~D"
msgstr " en la línea ~D"

#: compiler.lisp:1712
msgid " in lines ~D..~D"
msgstr " en las líneas ~D..~D"

#
# Duda: He querido traducir la palabra `warning' por `aviso' que es como
# debería decirse en español, ¿no?. ¿Hay algún término adoptado en
# es@li.org, para esta palabra?.
#
# Sí, atención. sv
#
# Si, si, ya lo he hecho, ... En todas partes he puesto "WARNING" por
# "ATENCIÓN". No es exactamente lo mismo, pero me parece una sugerencia
# genial, de hecho me gusta muchísimo más que aquello de "AVISO:". De
# esta manera, parecía que te estaban hablando los "super-tacañones" :) - cll
#
# Sin embargo, Santiago, este caso es bastante peculiar. Verás, si dejo
# "ATENCIÓN" aquí, entonces, durante la compilación de un proyecto con
# varios ficheros en Lisp, podría salir, por ejemplo, un mensaje como el
# siguiente (tomado de un ejemplo real, que conste, ...):
#
# --------------
# ATENCIÓN en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
# Y yo pregunto, en este caso ¿no es mejor poner "ADVERTENCIA"? La
# verdad es que "ADVERTENCIA" me suena mucho mejor que "ATENCIÓN" y que
# "AVISO". En este caso, lo que se tendría es:
#
# --------------
# ADVERTENCIA en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
#
#: compiler.lisp:1736
#, fuzzy
msgid "~%WARNING~@[ in ~A~]~A :~%"
msgstr "~%ADVERTENCIA~@[ en la función ~S~]~A :~%"

#: compiler.lisp:1756
#, fuzzy
msgid "~%ERROR~@[ in ~S~]~A :~%~?"
msgstr "~% ERROR~@[ en la función ~S~]~A : ~%~?"

#: compiler.lisp:1891
msgid "Code contains dotted list ~S"
msgstr "El código contiene la lista punteada ~S"

# En ocasiones como esta hemos puesto a veces:
# "insuficiente número de argumentos" sv
#
# ¡Pues no me gusta nada!, todavía si dijeses "número insuficiente de
# argumentos". No se, ..., la verdad es que a mí me gusta mucho más "muy
# pocos argumentos" o, si quieres, "pocos argumentos" pero eso de la
# "insuficiencia", ... (me trae otros recuerdos). cll
#
#: compiler.lisp:1893
msgid "Form too short, too few arguments: ~S"
msgstr "Forma demasiado corta, muy pocos argumentos: ~S"

#: compiler.lisp:1896
msgid "Form too long, too many arguments: ~S"
msgstr "Forma demasiado larga, demasiados argumentos: ~S"

# Añado lo que faltaba. sv
#
# Hmmm, ¿se me olvidó algo?. Atención, jóvenes traductores: recordad que
# hay un momento en el que es necesario parar de trabajar, ..., la
# cabeza puede llegar a dar muchas vueltas :) cll
#
#: compiler.lisp:2128
msgid "Not the name of a function: ~S"
msgstr "No es el nombre de una función: ~S"

#: compiler.lisp:2192 compiler.lisp:2255
#, fuzzy
msgid ""
"~S is neither declared nor bound,~@\n"
"                     it will be treated as if it were declared SPECIAL."
msgstr ""
"~S no está ni declarado ni ligado,~@\n"
"                        será tratado como si hubiese sido declarado SPECIAL."

#: compiler.lisp:2272
#, fuzzy
msgid ""
"The constant ~S may not be assigned to.~@\n"
"                                        The assignment will be ignored."
msgstr ""
"La constante ~S no puede asignarse. ~@\n"
"                                                  La asignación será ignorada."

#: compiler.lisp:2495
msgid "argument list to function ~S is dotted: ~S"
msgstr "el argumento de la función ~S es una lista punteada: ~S"

#: compiler.lisp:2500
#, fuzzy
msgid ""
"~S was called with ~S~:[~; or more~] arguments, ~\n"
"                     but it requires ~:[~:[from ~S to ~S~;~S~]~;~\n"
"                     at least ~*~S~] argument~:p."
msgstr ""
"~S fue invocado con ~S~:[~; o más~] argumentos, pero requiere ~\n"
"                        ~:[~:[de ~S a ~S~;~S~]~;al menos ~*~S~] argumentos."

#: compiler.lisp:2513
msgid "keyword arguments to function ~S should occur pairwise: ~S"
msgstr "los argumentos clave de la función ~S deben aparecer por pares: ~S"

#
# Afortunadamente, la convención ~#[, para imprimir los términos de una
# lista (en inglés, como dice el estándar) sirve perfectamente para el
# español
#
#: compiler.lisp:2521
#, fuzzy
msgid ""
"keyword ~S is not allowed for function ~S.~\n"
"                             ~%The only allowed keyword~:[s are ~{~S~#[~; and ~S~:;, ~]~}~; is ~{~S~}~]."
msgstr ""
"la palabra clave ~S no está permitida en la función ~S.~\n"
"                              ~%La~:[s~;~] única~:*~:[s~;~] palabra~:*~:[s~;~] clave permitida~:*~:[s son ~{~S~#[~; y ~S~:;, ~]~}~; es ~{~S~}~]."

#: compiler.lisp:2531
#, fuzzy
msgid "argument ~S to function ~S is not a symbol"
msgstr "el argumento ~S para la función ~S no es un argumento clave"

#: compiler.lisp:2693
#, fuzzy
msgid "~S: ignored duplicate keyword ~S ~S"
msgstr "~S no acepta las palabras clave ~S de ~S"

#: compiler.lisp:3050
#, fuzzy
msgid "Function ~s is not defined"
msgstr "~: la función ~ no está definida"

#: compiler.lisp:3054
#, fuzzy
msgid "Function ~s is deprecated~@[, use ~s instead~]"
msgstr "Función no implementada"

#: compiler.lisp:3118
msgid "Function ~s~% was already defined~a~:[~% with the signature~%~a~% it is being re-defined with a new signature~%~a~;~2*~]"
msgstr ""

#: compiler.lisp:3182
msgid "Illegal syntax in LET/LET*: ~S"
msgstr "Sintaxis inválida en LET/LET*: ~S"

#: compiler.lisp:3216
msgid "Lambda list marker ~S not allowed here."
msgstr "El marcador de la lista lambda ~S no está permitido aquí."

#: compiler.lisp:3223
msgid "Missing &REST parameter in lambda list ~S"
msgstr "La lista lambda ~S necesita un parámetro &REST"

#: compiler.lisp:3234
msgid "Lambda list element ~S is superfluous."
msgstr "El elemento ~S de la lista lambda es innecesario."

#: compiler.lisp:3359
msgid "Lambda lists with dots are only allowed in macros, not here: ~S"
msgstr "Sólo se permiten las listas lambda con puntos en la macros, no aquí: ~S"

#: compiler.lisp:3371
msgid "Illegal lambda list element ~S"
msgstr "Elemento inválido en lista lambda ~S"

#: compiler.lisp:3457
#, fuzzy
msgid "Binding variable ~S can cause side effects despite IGNORE declaration~%since it is declared SPECIAL."
msgstr "Asociar la variable ~S puede causar otros efectos, a pesar de la declaración~%IGNORE puesto que está declarada como SPECIAL."

#: compiler.lisp:3460
#, fuzzy
msgid "variable ~S is used despite IGNORE declaration."
msgstr "La variable ~S está siendo usada a pesar de la declaración IGNORE."

#: compiler.lisp:3470
msgid "variable ~S is not used.~%Misspelled or missing IGNORE declaration?"
msgstr "La variable ~S no está siendo usada.~%¿Está mal escrita o es que falta la declaración IGNORE?"

#: compiler.lisp:3475
#, fuzzy
msgid "The variable ~S is assigned to, despite READ-ONLY declaration."
msgstr "La variable ~S está siendo usada a pesar de la declaración IGNORE."

#: compiler.lisp:3516 compiler.lisp:3631
msgid "Constant ~S cannot be bound."
msgstr "La constante ~S no puede ligarse."

#: compiler.lisp:4308
msgid "Misplaced declaration: ~S"
msgstr "Declaración situada incorrectamente: ~S"

#: compiler.lisp:4501
#, fuzzy
msgid "~S: assignment to the internal special symbol ~S"
msgstr "~S: no es posible rastrear la forma especial ~S"

#: compiler.lisp:4509
msgid "Odd number of arguments to SETQ: ~S"
msgstr "Número impar de argumentos de SETQ: ~S"

#: compiler.lisp:4539 compiler.lisp:4568 compiler.lisp:4652
msgid "Cannot assign to non-symbol ~S."
msgstr "No se puede asignar a un \"no-símbolo\" ~S."

#: compiler.lisp:4548
msgid "Odd number of arguments to PSETQ: ~S"
msgstr "Número impar de argumentos de PSETQ: ~S"

#: compiler.lisp:4775
msgid "Only symbols may be used as variables, not ~S"
msgstr "Sólo pueden usarse los símbolos como variables, no ~S"

#: compiler.lisp:4862
msgid "Illegal syntax in COMPILER-LET: ~S"
msgstr "Sintaxis inválida en COMPILER-LET: ~S"

#: compiler.lisp:4867
msgid "Block name must be a symbol, not ~S"
msgstr "El nombre de un bloque debe ser un símbolo, no ~S"

#: compiler.lisp:4909
msgid "RETURN-FROM block ~S is impossible from here."
msgstr "No es posible hacer RETURN-FROM del bloque ~S desde aquí."

#: compiler.lisp:4967
msgid "Only numbers and symbols are valid tags, not ~S"
msgstr "Sólo son etiquetas de salto válidas los números y los símbolos, no ~S"

#: compiler.lisp:5038
msgid "Tag must be a symbol or a number, not ~S"
msgstr "Una etiqueta de salto debe ser un símbolo o un número, no ~S"

#: compiler.lisp:5041
msgid "GO to tag ~S is impossible from here."
msgstr "No es posible ir (GO) a la etiqueta de salto ~S desde aquí."

#: compiler.lisp:5114
msgid "~S is not a function. It is a locally defined macro."
msgstr "~S no es una función. Se trata de una macro definida localmente."

#: compiler.lisp:5129
msgid "Only symbols and lambda expressions are function names, not ~S"
msgstr "Sólo los símbolos y las expresiones lambda son nombres de funciones válidos, no ~S"

#: compiler.lisp:5185
msgid "Illegal function definition syntax in ~S: ~S"
msgstr "La sintaxis para la definición de la función en ~S es inválida: ~S"

#: compiler.lisp:5608
#, fuzzy
msgid "~S: Illegal syntax: ~S"
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: compiler.lisp:5646
#, fuzzy
msgid "~s situation must be ~s, ~s or ~s, but not ~s"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: compiler.lisp:5688
msgid "CASE clause without objects: ~S"
msgstr "Cláusula CASE sin objetos: ~S"

#: compiler.lisp:5697
msgid "~S: the ~S clause must be the last one: ~S"
msgstr "~S: la clausula ~S debe ser la última: ~S"

#: compiler.lisp:5705
msgid "Duplicate ~S label ~S : ~S"
msgstr "~S : La etiqueta ~S se repite: ~S"

#: compiler.lisp:5933
msgid "Too many arguments to ~S"
msgstr "Demasiados argumentos para ~S"

#: compiler.lisp:5944
msgid "Too few arguments to ~S"
msgstr "Muy pocos argumentos para ~S"

#: compiler.lisp:6350
msgid "Arithmetic operand ~s must evaluate to a number, not ~s"
msgstr ""

#: compiler.lisp:6827
#, fuzzy
msgid "The ~S destination is invalid (not NIL or T or a stream or a string with fill-pointer): ~S"
msgstr "El argumento destino no es NIL, ni tampoco T, un flujo o una cadena: ~S"

#: compiler.lisp:6851
#, fuzzy
msgid "~S: index should be an integer, not ~S"
msgstr "~: el índice debe ser un entero, no ~"

#: compiler.lisp:9940
#, fuzzy
msgid "~S cannot be compiled"
msgstr "~S no puede ser editado."

# eso de función "a compilar" siempre
# me pareció un vicio moderno.
# Sugerencia: El nombre de la función que hay que compilar ... sv
#
# Perfecto, ... cll
#
#: compiler.lisp:9983
msgid "Name of function to be compiled must be a symbol, not ~S"
msgstr "El nombre de una función que hay que compilar debe ser un símbolo, no ~S"

#: compiler.lisp:9993
msgid "~S: redefining ~S; it was traced!"
msgstr "~S: redefiniendo ~S; ¡estaba siendo rastreada!"

#: compiler.lisp:9998 compiler.lisp:10023
msgid "~S is already compiled."
msgstr "~S ya está compilada."

#: compiler.lisp:10014 disassem.lisp:9
msgid "Undefined function ~S"
msgstr "La función ~S no está definida"

# Sugerencia: No es blabla ni bla bla. sv
# El ni se ponía la segunda pero no la primera vez, ¿no?
#
# ¡No, hombre, no! Creo que estas equivocado, ..., en el diccionario
# Larousse de Inglés-Español pone:
#
# "nor conj. Ni: he is neither big nor small, no es ni grande ni
# pequeño; neither you nor I, ni tú ni yo || ..."
#
# O sea, que es " ... ni ... ni ..." cll
#
#: compiler.lisp:10028
msgid "Not a lambda expression nor a function: ~S"
msgstr "Ni es una expresión lambda ni es una función: ~S"

#: compiler.lisp:10199
msgid "~%[~s was defined~a]"
msgstr ""

#: compiler.lisp:10206
msgid "~%There were errors in the following functions:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Ha habido errores en las siguientes funciones:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:10212
msgid "~%The following functions were used but not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes funciones han sido utilizadas pero no definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:10220
msgid "~%The following special variables were not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes variables especiales no han sido definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:10223
msgid "~%The following special variables were defined too late:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes variables especiales fueron definidas demasiado tarde:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:10226
#, fuzzy
msgid "~%The following functions were used but are deprecated:~%~:{~<~%~:; ~S~@[ (use ~S instead)~]~>~^~}"
msgstr "~%Las siguientes funciones han sido utilizadas pero no aprobadas:~%~{~<~%~:; ~S~>~^~}"

#
# Duda: ¡atención a la utilización de la directiva ~P!
#
# La siguiente traducción funcionará si, para el caso del español (como
# para el alemán), se pasa el parámetro (eql *error-count* 1), en
# segundo lugar.
#
# Ya no hace falta. Tal y como está hecho no es necesario pasar ningún
# parámetro extra. Así funciona correctamente.
#
# Aquí dudo porque atención no es tan "pluralizable" como aviso. sv
#
# Claro, de hecho, a mí también me pasa lo mismo. He preferido cambiar
# la traducción de "aviso" por "advertencia", en este mensaje y en aquél
# en el que se sacan los mensajes del compilador. ¿No os suena muchísimo
# mejor esta segunda alternativa? - cll
#
#: compiler.lisp:10230
msgid "~%~D error~:P, ~D warning~:P"
msgstr "~%~D error~:*~[es~;~:;es~], ~D advertencia~:P"

#: compiler.lisp:10374
msgid "~&Listing of compilation of file ~A~%on ~@? by ~A, version ~A"
msgstr "~&Listado de la compilación del fichero ~A~%el ~@? por ~A, versión ~A"

#: compiler.lisp:10401
msgid "~%Compiling file ~A ..."
msgstr "~%Compilando el fichero ~A ..."

#: compiler.lisp:10444
msgid "~&~%Wrote file ~A"
msgstr ""

#: compiler.lisp:10446 compiler.lisp:10454
#, fuzzy
msgid "~%Wrote file ~A"
msgstr " de la fuente ~S"

#: compiler.lisp:10449
msgid "~&~%Deleted file ~A"
msgstr ""

#: compiler.lisp:10451
msgid "~%Deleted file ~A"
msgstr ""

#: compiler.lisp:10491
msgid "Disassembly of function "
msgstr "Desensamblado de la función "

#: compiler.lisp:10501
#, fuzzy
msgid "~%~S required argument~:P"
msgstr "~%~S argumentos obligatorios"

#: compiler.lisp:10502
#, fuzzy
msgid "~%~S optional argument~:P~%"
msgstr "~%~S argumentos opcionales"

#: compiler.lisp:10504
msgid "Rest parameter"
msgstr "Parámetro resto"

#: compiler.lisp:10505
msgid "No rest parameter"
msgstr "Sin parámetro de resto"

#
# aAtención a la utilización de la directiva ~P!!
#
# Bueno, en este caso es perfecta :) No hay ningún problema de ningún
# tipo
#
#: compiler.lisp:10508
#, fuzzy
msgid "~%~S keyword parameter~:P: "
msgstr "parámetro~P clave: "

#: compiler.lisp:10515
msgid "Other keywords are allowed."
msgstr "Se permiten otras palabras clave."

#: compiler.lisp:10518
msgid "No keyword parameters"
msgstr "Sin parámetros clave"

#: compiler.lisp:10532
msgid "~%reads special variable~P: ~S"
msgstr ""

#: compiler.lisp:10535
msgid "~%writes special variable~P : ~S"
msgstr ""

#: compiler.lisp:10537
msgid "~%~S byte-code instruction~:P:"
msgstr ""

#: defs2.lisp:89
msgid "~S ~A: the symbol ~A must not be specified more than once"
msgstr "~S ~A: el símbolo ~A no debe especificarse más de una vez"

#: defs2.lisp:99 defs2.lisp:105
msgid "~S ~A: the ~S option must not be given more than once"
msgstr "~S ~A: no se debe poner la opción ~S más de una vez"

#: defs2.lisp:152
msgid "~S ~A: unknown option ~S"
msgstr "~S ~A: la opción ~S es desconocida"

#: defs2.lisp:155
msgid "~S ~A: invalid syntax in ~S option: ~S"
msgstr "~S ~A: la sintaxis de la opción ~S es inválida: ~S"

#: defs2.lisp:158
msgid "~S ~A: not a ~S option: ~S"
msgstr "~S ~A: no se trata de una opción ~S: ~S"

#: defs2.lisp:203
msgid "This symbol will be created."
msgstr "Este símbolo será creado."

#: defs2.lisp:204
msgid "~S ~A: There is no symbol ~A::~A ."
msgstr "~S ~A: El símbolo ~A::~A no existe."

#: defs2.lisp:278
msgid "The object to be destructured should be a list with ~:[at least ~*~S~;~:[from ~S to ~S~;~S~]~] elements, not ~4@*~S."
msgstr "Los objetos a desmontar deben ser una lista ~:[con al menos ~*~S~;de ~:[~S a ~S~;~S~]~] elementos, y no ~4@*~S."

#: defs2.lisp:347
msgid "~S: macro name should be a symbol, not ~S"
msgstr "~S: el nombre de una macro debe ser un símbolo, no ~S"

#: defs2.lisp:377
msgid "~S: input stream ~S ends within read macro beginning to ~S"
msgstr "~S: el flujo de entrada ~S ha terminado durante el procesamiento de una macro de lectura que empezaba en ~S"

#: defs2.lisp:383
#, fuzzy
msgid "~S from ~S: character read should be a character: ~S"
msgstr "~S en ~S: el carácter leído debe ser un STRING-CHAR: ~S"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: defs2.lisp:404
msgid "~S from ~S: After ~S is ~S an undefined dispatch macro character"
msgstr "~S en ~S: Después de ~S está ~S, un macro carácter sencundario indefinido"

#: defs2.lisp:458 defs2.lisp:475
msgid "~S: element types of ~S and ~S are ambiguous. Please use ~S or ~S."
msgstr ""

#: defs2.lisp:615 dribble.lisp:34
#, fuzzy
msgid "~S: ~S should be a ~S"
msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#: loop.lisp:47
msgid "~S: syntax error after ~A in ~S"
msgstr "~S: error de sintaxis después de ~A en ~S"

#: loop.lisp:304
#, fuzzy
msgid "~S: missing variable."
msgstr "~S: variable ausente"

#: loop.lisp:313
msgid "~S: After ~S, ~S is interpreted as a type specification"
msgstr "~S: Después de ~S, ~S es interpretado como una especificación de tipo"

#: loop.lisp:332
#, fuzzy
msgid "~S: missing forms after ~A"
msgstr "~S: variable ausente"

#: loop.lisp:501
#, fuzzy
msgid "~S: duplicate iteration variable ~S"
msgstr "~S ~S: el nombre de la variable ~S está duplicado"

#: loop.lisp:564
msgid "~S: ~A clauses should occur before the loop's main body"
msgstr "~S: las claúsulas ~A deben aparecer antes del cuerpo principal del bucle"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lisp:712
msgid "~S: After ~S a plural loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un plural, y no ~A"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lisp:717
msgid "~S: After ~S a singular loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un singular, y no ~A"

#: loop.lisp:867
msgid "~S: questionable iteration direction after ~A"
msgstr "~S: dirección incierta de la iteración después de ~A"

#: loop.lisp:877
msgid "~S: specifying ~A requires FROM or DOWNFROM"
msgstr "~S: especificar ~A requiere FROM o DOWNFROM"

#: loop.lisp:936
msgid "~S: illegal syntax near ~S in ~S"
msgstr "~S: sintaxis inválida cerca de ~S en ~S"

#: loop.lisp:942
msgid "~S: ambiguous result of loop ~S"
msgstr "~S: el resultado del bucle ~S es ambiguo"

#: loop.lisp:1012
#, fuzzy
msgid "~S: accumulation variable ~S is already bound"
msgstr "~S: demasiadas variables ~S en la clausula ~S"

#: loop.lisp:1075
msgid "~S is possible only from within ~S"
msgstr "~S sólo es posible desde ~S"

#: loop.lisp:1078
msgid "Use of ~S in FINALLY clauses is deprecated because it can lead to infinite loops."
msgstr "La utilización de ~S en las cláusulas FINALLY está desaconsejada puesto que puede provocar bucles infinitos"

#: loop.lisp:1081
msgid "~S is not possible here"
msgstr "~S es imposible aquí"

#: clos.lisp:176 clos.lisp:193
msgid "~S: argument ~S is not a symbol"
msgstr "~S: el argumento ~S no es un símbolo"

#: clos.lisp:182
msgid "~S: ~S does not name a class"
msgstr "~S: ~S no nombra una clase"

#: clos.lisp:198
msgid "~S: ~S is not a class"
msgstr "~S: ~S no es una clase"

#: clos.lisp:204
msgid "~S: cannot redefine built-in class ~S"
msgstr "~S: no se puede redefinir la clase predefinida ~S"

#: clos.lisp:327
msgid "instance ~S of class ~S has no slots (wrong metaclass)"
msgstr "la instancia ~S de la clase ~S no tiene ranuras (metaclase errónea)"

#: clos.lisp:347 clos.lisp:381
msgid "~S: not a list of slots: ~S"
msgstr "~S: no es una lista de ranuras: ~S"

#: clos.lisp:354
msgid "~S: invalid slot and variable specification ~S"
msgstr "~S: especificación inválida de ranura y variable: ~S"

#: clos.lisp:359 clos.lisp:390
msgid "~S: variable ~S should be a symbol"
msgstr "~S: la variable ~S debe ser un símbolo"

#: clos.lisp:363
msgid "~S: slot name ~S should be a symbol"
msgstr "~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos.lisp:386
msgid "~S: invalid slot and accessor specification ~S"
msgstr "~S: especificación inválida de ranura y función de acceso: ~S"

#: clos.lisp:394
msgid "~S: accessor name ~S should be a symbol"
msgstr "~S: el nombre de la función de acceso ~S debe ser un símbolo"

#: clos.lisp:472
msgid "~S: class name ~S should be a symbol"
msgstr "~S: el nombre de la clase ~S debe ser un símbolo"

#: clos.lisp:478
msgid "~S ~S: expecting list of superclasses instead of ~S"
msgstr "~S ~S: se esperaba una lista de superclases en vez de ~S"

#: clos.lisp:483
msgid "~S ~S: superclass name ~S should be a symbol"
msgstr "~S ~S: el nombre de la superclase ~S debe ser un símbolo"

#: clos.lisp:492
msgid "~S ~S: expecting list of slot specifications instead of ~S"
msgstr "~S ~S: se esperaba una lista de especificación de ranuras en vez de ~S"

#: clos.lisp:501
msgid "~S ~S: slot name ~S should be a symbol"
msgstr "~S ~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos.lisp:505
msgid "~S ~S: There may be only one direct slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura directa con el nombre ~S."

#: clos.lisp:518
msgid "~S ~S: slot options for slot ~S must come in pairs"
msgstr "~S ~S: las opciones de ranura para ~S no aparecen por pares"

#: clos.lisp:528
msgid "~S ~S, slot option for slot ~S: ~S is not a function name"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una función"

#: clos.lisp:536 clos.lisp:554
msgid "~S ~S, slot option for slot ~S: ~S is not a symbol"
msgstr "~S ~S, opción de ranura para ~S: ~S no es un símbolo"

#: clos.lisp:544 clos.lisp:560 clos.lisp:567 clos.lisp:573
msgid "~S ~S, slot option ~S for slot ~S may only be given once"
msgstr "~S ~S, la opción de ranura ~S para ~S solo debe indicarse una vez"

#: clos.lisp:549
msgid "~S ~S, slot option for slot ~S must have the value ~S or ~S, not ~S"
msgstr "~S ~S, la opción de ranura para ~S debe tener el valor ~S o ~S, y no ~S"

#: clos.lisp:577
msgid "~S ~S, slot option for slot ~S: ~S is not a string"
msgstr "~S ~S, opción de ranura para ~S: ~S no es una cadena de caracteres"

#: clos.lisp:582
msgid "~S ~S, slot option for slot ~S: ~S is not a valid slot option"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una opción de ranura válida"

#: clos.lisp:625
msgid "~S ~S, option ~S may only be given once"
msgstr "~S ~S, la opción ~S sólo se puede indicar una vez"

#: clos.lisp:633 clos.lisp:655
msgid "~S ~S, option ~S: ~S is not a symbol"
msgstr "~S ~S, opción ~S: ~S no es un símbolo"

#: clos.lisp:641
msgid "~S ~S: option ~S should be written ~S"
msgstr "~S ~S: la opción ~S debe escribirse como ~S"

#: clos.lisp:645
msgid "~S ~S, option ~S: arguments must come in pairs"
msgstr "~S ~S, opción ~S: los argumentos no aparecen en pares"

#: clos.lisp:659
msgid "~S ~S, option ~S: ~S may only be given once"
msgstr "~S ~S, opción ~S: ~S sólo se puede poner una vez"

#: clos.lisp:672
msgid "~S ~S, option ~S: ~S is not a string"
msgstr "~S ~S, opción ~S: ~S no es una cadena de caracteres"

#: clos.lisp:678
msgid "~S ~S: invalid option ~S"
msgstr "~S ~S: la opción ~S es inválida"

#: clos.lisp:749
msgid "~S: class definition circularity: ~S depends on itself"
msgstr ""

#: clos.lisp:777
#, fuzzy
msgid "Cannot redefine ~S with a different metaclass ~S"
msgstr "~S: no se puede redefinir la clase predefinida ~S"

#: clos.lisp:879
#, fuzzy
msgid "(~S ~S): superclass ~S should be of class ~S"
msgstr "~S ~S: la superclase ~S debe pertenecer a la clase STANDARD-CLASS"

#: clos.lisp:1058
msgid "~S ~S: inconsistent precedence graph, cycle ~S"
msgstr "~S ~S: grafo de precedencia inconsistente, ciclo ~S"

#: clos.lisp:1090
msgid "(class-precedence-list ~S) and (class-precedence-list ~S) are inconsistent"
msgstr "(class-precedence-list ~S) y (class-precedence-list ~S) son inconsistentes"

#: clos.lisp:1253
#, fuzzy
msgid "(~S ~S): metaclass ~S forbids more than one direct superclass"
msgstr "~S: la metaclase STRUCTURE-CLASS prohibe más de una superclase directa"

#: clos.lisp:1292
#, fuzzy
msgid "(~S ~S): metaclass ~S does not support shared slots"
msgstr "~S: la metaclase STRUCTURE-CLASS no mantiene ranuras compartidas"

#: clos.lisp:1588
msgid "~S ~S: missing lambda list"
msgstr "~S ~S: falta la lista lambda"

#: clos.lisp:1951
msgid "Too few arguments to ~S: ~S"
msgstr "Muy pocos argumentos para ~S: ~S"

#: clos.lisp:2076
msgid "The generic function ~S is being modified, but has already been called."
msgstr "La función genérica ~S está siendo modificada, pero ya ha sido invocada."

#: clos.lisp:2472
#, fuzzy
msgid "~S ~S: The ~S method combination permits no options: ~S"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos.lisp:2588
#, fuzzy
msgid "~S method combination, used by ~S, allows no method qualifiers except ~S: ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos.lisp:2591
#, fuzzy
msgid "~S method combination, used by ~S, does not allow method qualifiers: ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos.lisp:2595
#, fuzzy
msgid "~S method combination, used by ~S, does not allow more than one method qualifier on a method: ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos.lisp:2624
msgid "~S in ~S: the new arguments ~S have a different effective method than the old arguments ~S"
msgstr "~S en ~S: los argumentos nuevos ~S tienen un método en vigor diferente que los argumentos antiguos ~S"

#: clos.lisp:2647
#, fuzzy
msgid "~S has ~D, but ~S has ~D required parameter~:P"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros obligatorios"

#: clos.lisp:2651
#, fuzzy
msgid "~S has ~D, but ~S has ~D optional parameter~:P"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros opcionales"

#: clos.lisp:2655 clos.lisp:2659
#, fuzzy
msgid "~S accepts &REST or &KEY, but ~S does not."
msgstr "~S tiene parámetros &REST o &KEY, pero ~S no."

#: clos.lisp:2668
#, fuzzy
msgid "~S does not accept the keywords ~S of ~S"
msgstr "~S no acepta las palabras clave ~S de ~S"

#: clos.lisp:2678
#, fuzzy
msgid "~S method combination, used by ~S, does not allow the method qualifiers ~:S: ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos.lisp:2710
msgid "Replacing method ~S in ~S"
msgstr "Reemplazando el método ~S de ~S"

#: clos.lisp:2728
msgid "Removing method ~S in ~S"
msgstr "Borrando el método ~S de ~S"

#: clos.lisp:2755
msgid "~S has no method with qualifiers ~:S and specializers ~S"
msgstr "~S no tiene ningún método con cualificadores ~:S y especializadores ~S"

#: clos.lisp:2781 clos.lisp:3080
#, fuzzy
msgid "~S: ~S does not name a generic function"
msgstr "~S no es una función genérica"

#: clos.lisp:2835
msgid "~S ~S: Only ~S declarations are permitted: ~S"
msgstr "~S ~S: Sólo la declaraciones ~S están permitidas: ~S"

#: clos.lisp:2840
msgid "~S ~S: ~S may only be specified once."
msgstr "~S ~S: ~S sólo puede especificarse una vez."

#: clos.lisp:2846
msgid "~S ~S: A string must be specified after ~S : ~S"
msgstr "~S ~S: Debe especificarse una cadena de caracteres después de ~S: ~S"

#: clos.lisp:2850
msgid "~S ~S: Only one ~S string is allowed"
msgstr "~S ~S: Sólo se permite una cadena de caracteres ~S"

#: clos.lisp:2863
#, fuzzy
msgid "~S ~S: Invalid method combination: ~S"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos.lisp:2869
msgid "~S ~S: The only valid generic function class name is ~S : ~S"
msgstr "~S ~S: El único nombre válido de una clase de función genérica es ~S : ~S"

#: clos.lisp:2875
msgid "~S ~S: The only valid method class name is ~S : ~S"
msgstr "~S ~S: El único nombre válido de una clase de métodos es ~S : ~S"

#: clos.lisp:2889
msgid "~S ~S: ~S is not one of the required parameters: ~S"
msgstr "~S ~S: ~S no es uno de los parámetros obligatorios: ~S"

#: clos.lisp:2899
msgid "~S ~S: some variable occurs twice in ~S"
msgstr "~S ~S: alguna variable ha aparecido dos veces en ~S"

#: clos.lisp:2903
msgid "~S ~S: ~S is missing some required parameter"
msgstr "~S ~S: ~S necesita algunos parámetros obligatorios"

#: clos.lisp:2928
msgid "~S ~S: No initializations are allowed in a generic function lambda-list: ~S"
msgstr "~S ~S: No están permitidas las inicializaciones en la lista lambda de una función genérica: ~S"

#: clos.lisp:2933
msgid "~S ~S: variable name ~S should be a symbol"
msgstr "~S ~S: el nombre de la variable ~S debe ser un símbolo"

#: clos.lisp:2937
msgid "~S ~S: duplicate variable name ~S"
msgstr "~S ~S: el nombre de la variable ~S está duplicado"

#: clos.lisp:2978
msgid "~S ~S: invalid lambda list portion: ~S"
msgstr "~S ~S: parte de la lista lambda es inválida: ~S"

#: clos.lisp:3041
#, fuzzy
msgid "~S is not a valid a ~S designator"
msgstr "~: ~ no es un índice válido en ~"

#: clos.lisp:3123
msgid "~S: ~S is not a generic function specification"
msgstr "~S: ~S no es una especificación de función genérica"

#: clos.lisp:3173
msgid "~S: The name of a class must be a symbol, not ~S"
msgstr "~S: El nombre de una clase debe ser un símbolo, no ~S"

#: clos.lisp:3177
msgid "~S: The name of the built-in class ~S cannot be modified"
msgstr "~S: No es posible modificar el nombre de la clase predefinida ~S"

#: clos.lisp:3213 clos.lisp:3217
msgid "~S: When calling ~S with arguments ~S, no method is applicable."
msgstr "~S: No se puede aplicar ningún método al invocar ~S con los argumentos ~S."

#: clos.lisp:3231 clos.lisp:3235
msgid "~S: When calling ~S with arguments ~S, no primary method is applicable."
msgstr "~S: No se puede aplicar ningún método primario al invocar ~S con los argumentos ~S"

#: clos.lisp:3247
msgid "~S: When calling ~S with arguments ~S, there is no next method after ~S, and ~S was called."
msgstr "~S: Mientras se invoca ~S con los argumentos ~S, no hay ningún método después de ~S, y ~S fue llamado."

#: clos.lisp:3252
#, fuzzy
msgid "~S: ~S is invalid within ~{~S~^ ~} methods"
msgstr "~S ~S: ~S es inválido dentro de los métodos ~S"

#: clos.lisp:3255
#, fuzzy
msgid "~S: ~S is invalid within primary methods"
msgstr "~S ~S: ~S es inválido dentro de los métodos ~S"

#: clos.lisp:3299
msgid "~S: The class ~S has no slot named ~S"
msgstr "~S: La clase ~S no tiene ninguna ranura llamada ~S"

#: clos.lisp:3791
msgid "~S method for ~S returned ~S"
msgstr ""

#: clos.lisp:3864
#, fuzzy
msgid "~S: Class ~S (or its ancestor) is being redefined, instances are obsolete"
msgstr "~S: La clase ~S ha sido redefinida, las instancias son obsoletas"

#: clos.lisp:4045
msgid "for function ~s applied to ~s:~%while computing the effective method for ~s~:%invalid method: ~s~%~?"
msgstr ""

#: clos.lisp:4053
msgid "for function ~s applied to ~s:~%while computing the effective method for ~s~%invalid combination: ~s~%~?"
msgstr ""

#: disassem.lisp:55
msgid "Cannot disassemble ~S"
msgstr "No se puede desensamblar ~S"

#: condition.lisp:85
msgid "~S: the name of a condition must be a symbol, not ~S"
msgstr "~S: el nombre de una condición debe ser un símbolo, y no ~S"

# En este mensaje, el término `parent-type' se refiere al segundo
# argumento de la macro `define-condition' que, según el estándar, se
# utiliza como lista de super-tipos del que se obtiene una nueva
# condición.
#
# Por ese motivo, he añadido la expresión "super-tipos" - cll
#
#: condition.lisp:89
msgid "~S: the parent-type list must be a list of symbols, not ~S"
msgstr "~S: la lista de \"super-tipos\" debe ser una lista de símbolos, y no ~S"

#: condition.lisp:93
msgid "~S: the slot description list must be a list, not ~S"
msgstr "~S: la lista de descripción de la ranura debe ser una lista, y no ~S"

#: condition.lisp:151
msgid "~S ~S: superfluous arguments ~S"
msgstr "~S ~S: los argumentos ~S son superfluos"

#: condition.lisp:164
msgid "~S: the condition argument must be a string, a symbol or a condition, not ~S"
msgstr "~S: el argumento de la condición debe ser una cadena de caracteres, un símbolo o una condición, y no ~S"

#: condition.lisp:547
msgid "~S: illegal syntax of clause ~S"
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: condition.lisp:552
#, fuzzy
msgid "~S: multiple ~S clauses: ~S and ~S"
msgstr "~S: la clausula ~S está mal colocada: ~S"

#: condition.lisp:558
msgid "~S: too many variables ~S in clause ~S"
msgstr "~S: demasiadas variables ~S en la clausula ~S"

# Duda: ¿y cómo traduzco `restart'?
#
# He decidido dejar `restart' sin traducir, ... :(
#
#: condition.lisp:710
msgid "~S: ~S is not a valid restart name here. Use ~S instead."
msgstr "~S: ~S no es válido como nombre de `restart' aquí. En su lugar, use ~S."

#: condition.lisp:732
msgid "~S: invalid restart name ~S"
msgstr "~S: ~S es un nombre inválido de `restart'"

#: condition.lisp:737
msgid "~S: No restart named ~S is visible."
msgstr "~S: No hay ningún `restart' visible llamado ~S"

#: condition.lisp:790 condition.lisp:839
msgid "~S: not a list: ~S"
msgstr "~S: no es una lista: ~S"

#: condition.lisp:799 condition.lisp:848
msgid "~S: invalid restart specification ~S"
msgstr "~S: ~S no es una especificación válida de `restart'"

#: condition.lisp:809 condition.lisp:880
msgid "~S: unnamed restarts require ~S to be specified: ~S"
msgstr "~S: es necesario especificar ~S en los `restart' sin nombre: ~S"

#: condition.lisp:868
msgid "~S: missing lambda list in restart specification ~S"
msgstr "~S: falta la lista lambda en la especificación del `restart' ~S"

#: condition.lisp:886
msgid "~S: restart cannot be invoked interactively because it is missing a ~S option: ~S"
msgstr "~S: el `restart' no puede invocarse interactivamente porque falta la opción ~S: ~S"

#: condition.lisp:1041
msgid "~%Use instead~@[ of ~S~]: "
msgstr ""

#: condition.lisp:1049
msgid "~%Use instead of ~S [value ~D of ~D]: "
msgstr ""

#: condition.lisp:1050
msgid "~%New ~S [value ~D of ~D]: "
msgstr ""

#: condition.lisp:1274 condition.lisp:1363
msgid "Return from ~S loop"
msgstr "Retorno del bucle ~S"

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: condition.lisp:1341 condition.lisp:1356
msgid "WARNING:"
msgstr "ATENCIÓN:"

#
# En este caso he tenido que traducir `warning' por `advertencia', en
# vez de `atención'. ¿No querreis que diga algo así como "Esto es más
# serio que un toque de atención"? Así parecería que el compilador le va
# a meter una paliza al pobre programador, ... :) - cll
#
#: condition.lisp:1350
msgid "~S: This is more serious than a warning: ~A"
msgstr "~S: Esto es más serio que una advertencia: ~A"

#: loadform.lisp:42
msgid "A method on ~S for class ~S is necessary for externalizing the object ~S, according to ANSI CL 3.2.4.4, but no such method is defined."
msgstr ""

#: xcharin.lisp:35
#, fuzzy
msgid "~: argument ~S is not a character"
msgstr "~: el argumento ~ no es un carácter"

#: xcharin.lisp:56
#, fuzzy
msgid "~S: the font argument should be an integer, not ~S"
msgstr "~: el argumento de la fuente debe ser un número y no ~"

#: xcharin.lisp:65
#, fuzzy
msgid "~S: the bits argument should be an integer, not ~S"
msgstr "~: el argumento de los bits debe ser un entero y no ~"

# Ya, ya se que eso de "los nombres de bit" puede sonar muy raro, pero
# es que realmente es así en Common Lisp.  Consúltese el Cltl2, 13.5
# Character Control-Bit Functions, página 385
#
#: xcharin.lisp:87
#, fuzzy
msgid "~S: the only bit names are ~S, ~S, ~S, ~S, not ~S"
msgstr "~: los únicos nombres de bit son :CONTROL, :META, :SUPER y :HYPER, y no ~"

#: beossock.lisp:73 beossock.lisp:83
#, fuzzy
msgid "service does not exist: ~A/~A"
msgstr "el fichero ~ no existe"

#: runprog.lisp:159
msgid "~S: File ~S already exists"
msgstr "~S: El fichero ~S ya existe"

# Con un poco de suerte, aquí se podría poner directamente " (s/n) ".
# En fileutils ya se puede. sv
#
# Bueno, pues sí, ..., sí podría hacerse. Ahora bien, para eso es
# necesario modificar el código fuente del clisp (lo cual no es nada
# complicado gracias a la localizacion de codigo fuente del modo .PO
# desde Emacs :). De momento, lo dejo tal cual (aunque queda pachín,
# pachán, ... :( ) y luego lo modificaré, ..., ¿vale?. cll
#
#: query.lisp:12
msgid " (y/n) "
msgstr " (si(y)/no(n)) "

#: query.lisp:23
msgid "Please answer with y or n : "
msgstr "Por favor, responda con y(si) o n(no) : "

#: query.lisp:33
msgid " (yes/no) "
msgstr " (si(yes)/no(no)) "

#: query.lisp:43
msgid "Please answer with yes or no : "
msgstr "Por favor, responda con yes(si) o no(no) : "

# paquete (?) sv
#
# Bueno, podría parecer muy conveniente. Sin embargo, verás, ..., lo de
# *package* está puesto a nivel de programa. Es decir, Bruno Haible y
# compañÂía lo tienen puesto así desde su propio programa. Por lo tanto,
# si lo cambio en un par de mensajes seguirá apareciendo en muchos otros
# sitios. Prefiero ser consistente y dejarlo así. cll
#
# Además, no está traducido ni en alemán ni en inglés. cll
#
#: reploop.lisp:93
msgid "[*package* invalid]"
msgstr "[*package* inválido]"

#: reploop.lisp:114
msgid "~&Reset *PACKAGE* to ~s"
msgstr ""

#: reploop.lisp:179
msgid ""
"\n"
"Enter the limit for max. frames to print or ':all' for all: "
msgstr ""

#: reploop.lisp:184
#, fuzzy
msgid "~&~A is not a number. Try again."
msgstr "~: ~ no es un número de 8 bits"

#: reploop.lisp:202
msgid "~&Printed ~D frames"
msgstr ""

#: reploop.lisp:224
#, fuzzy
msgid "Values: "
msgstr "valores: "

#: reploop.lisp:237
msgid "~%Last error is: >> ~A <<"
msgstr ""

# Me suele gustar más "utilice" (porque me parece más "fino"). sv
#
# De acuerdo, ..., cambiado `use' por `utilice'. A mí también me gusta más. cll
#
# Y además, (recomendación tuya, Santiago), `command' por `orden', en
# vez de `comando' - cll
#
#: reploop.lisp:243
#, fuzzy
msgid ""
"\n"
"Help (abbreviated :h) = this list\n"
"Use the usual editing capabilities.\n"
"(quit) or (exit) leaves CLISP."
msgstr ""
"\n"
"Help = esta lista\n"
"Utilice las órdenes de edición habituales"

#: reploop.lisp:253
msgid ""
"\n"
"Commands may be abbreviated as shown in the second column.\n"
"COMMAND        ABBR     DESCRIPTION\n"
"Help           :h, ?    this command list\n"
"Error          :e       Print the last error message\n"
"Inspect        :i       Inspect the last error\n"
"Abort          :a       abort to the next recent input loop\n"
"Unwind         :uw      abort to the next recent input loop\n"
"Reset          :re      toggle *PACKAGE* and *READTABLE* between the\n"
"                          local bindings and the sane values\n"
"Quit           :q       quit to the top-level input loop\n"
"Mode-1         :m1      inspect all the stack elements\n"
"Mode-2         :m2      inspect all the frames\n"
"Mode-3         :m3      inspect only lexical frames\n"
"Mode-4         :m4      inspect only EVAL and APPLY frames (default)\n"
"Mode-5         :m5      inspect only APPLY frames\n"
"Where          :w       inspect this frame\n"
"Up             :u       go up one frame, inspect it\n"
"Top            :t       go to top frame, inspect it\n"
"Down           :d       go down one frame, inspect it\n"
"Bottom         :b       go to bottom (most recent) frame, inspect it\n"
"Backtrace-1    :bt1     list all stack elements\n"
"Backtrace-2    :bt2     list all frames\n"
"Backtrace-3    :bt3     list all lexical frames\n"
"Backtrace-4    :bt4     list all EVAL and APPLY frames\n"
"Backtrace-5    :bt5     list all APPLY frames\n"
"Backtrace      :bt      list stack in current mode\n"
"Backtrace-l    :bl      list stack in current mode.\n"
"                          Limit of frames to print will be prompted for.\n"
"Frame-limit    :fl      set the frame-limit. This many frames will\n"
"                          be printed in a backtrace at most.\n"
"Break+         :br+     set breakpoint in EVAL frame\n"
"Break-         :br-     disable breakpoint in EVAL frame\n"
"Redo           :rd      re-evaluate form in EVAL frame\n"
"Return         :rt      leave EVAL frame, prescribing the return values"
msgstr ""

#: reploop.lisp:353
#, fuzzy
msgid ""
"\n"
"Continue       :c       continue evaluation"
msgstr ""
"\n"
"Continue = continuar la evaluación"

# ¿form no era formulario? (o a lo mejor es algo de lisp que no sé). sv
#
# En Visual Basic (y los lenguajes orientados a eventos), form es formulario.
# Sin embargo, en Lisp form es forma. Se refiere a las sentencias Lisp. cll
#
#: reploop.lisp:360
#, fuzzy
msgid ""
"\n"
"Step           :s       step into form: evaluate this form in single step mode\n"
"Next           :n       step over form: evaluate this form at once\n"
"Over           :o       step over this level: evaluate at once up to the next return\n"
"Continue       :c       switch off single step mode, continue evaluation\n"
"-- Step-until :su, Next-until :nu, Over-until :ou, Continue-until :cu --\n"
"           same as above, specify a condition when to stop"
msgstr ""
"\n"
"Step     = entrar en una forma: evaluar esta forma en el modo paso a paso\n"
"Next     = saltarse una forma: evaluar esta forma en un solo paso\n"
"Over     = saltarse este nivel: evaluar hasta el siguiente retorno\n"
"Continue = desactivar el modo paso a paso y continuar la evaluación\n"
"Step-until, Next-until, Over-until, Continue-until:\n"
"           lo mismo que antes, especifique una condición de parada"

#: reploop.lisp:447
#, fuzzy
msgid "Unprintable error message."
msgstr "Mensaje de error no imprimible"

#: reploop.lisp:458
msgid "You can continue (by typing 'continue')."
msgstr "Puede continuar (tecleando `continue')."

#: reploop.lisp:470
#, fuzzy
msgid "The following restarts are also available:"
msgstr "Es posible continuar en los siguientes puntos:"

#: reploop.lisp:471
msgid "The following restarts are available:"
msgstr "Es posible continuar en los siguientes puntos:"

# Duda: Francamente, no sé porqué motivo esto no fué traducido al
# FRANCÉS o al INGLÉS (compruébese en el código, ...) porque en
# realidad, queda pero que muy bien poner `paso' cuando se hace la
# depuración paso a paso, ...
#
# Este mensaje, de hecho, aparece cuando se hace algo del tipo:
#
# > (step (+ 2 3))
# step 1 --> (+ 2 3)
# Step 1>
#
# ..., donde, traduciendo el primer `step' al español, queda algo muy
# propio:
#
# > (step (+ 2 3))
# paso 1 --> (+ 2 3)
# Step 1>
#
# A mi me gusta así, ..., aA SACO!!
#
#: reploop.lisp:565 reploop.lisp:607
msgid "step "
msgstr "paso "

#: reploop.lisp:569
msgid "no values"
msgstr "sin valores"

#: reploop.lisp:570
msgid "value: "
msgstr "valor: "

#: reploop.lisp:573
msgid " values: "
msgstr " valores: "

#: reploop.lisp:637
msgid "condition when to stop: "
msgstr "condición de parada: "

# Nota: La utilización de dribbling viene de la función dribble de Lisp.
#       Dicha función graba una sesión Lisp en el archivo que se indique en la
#       llamada a la función.
#
# La traducción no juega, de esa manera, con las palabras.
#
#: dribble.lisp:45
#, fuzzy
msgid "Already dribbling ~S to ~S"
msgstr "Ya se está grabando la sesión en ~S"

# Nota: `is finished' debería traducirse por `está finalizado' o `est
#       finalizada'. Sin embargo, esta parte se compondrá con otras
#       donde la traducción `ha finalizado' sigue siendo igualmente válida y,
#       además, nos evitamos la utilización de una forma eminentemente
#       masculina o fememina.
#
#: dribble.lisp:47
#, fuzzy
msgid ";; Dribble of ~S finished "
msgstr " ha finalizado."

# Nota: `is finished' debería traducirse por `está finalizado' o `est
#       finalizada'. Sin embargo, esta parte se compondrá con otras
#       donde la traducción `ha finalizado' sigue siendo igualmente válida y,
#       además, nos evitamos la utilización de una forma eminentemente
#       masculina o fememina.
#
#: dribble.lisp:58
#, fuzzy
msgid ";; Dribble of ~S started "
msgstr " ha finalizado."

#: dribble.lisp:62
#, fuzzy
msgid "Currently not dribbling from ~S."
msgstr "En este momento, no se está grabando la sesión."

#: describe.lisp:55
msgid "constant"
msgstr "constante"

#: describe.lisp:57
msgid "symbol-macro"
msgstr ""

#: describe.lisp:58
msgid "variable"
msgstr "variable"

#: describe.lisp:65
msgid "type"
msgstr "tipo"

#: describe.lisp:71
msgid "class"
msgstr "clase"

# Duda: Lo que he dicho unos pocos mensajes más arriba --> Slot por
# slot, ...
#
# Pues no, ... A partir de la versión 1.4, `slot' es "ranura", tal y
# como se propone en la lista de spanglish.
#
#: describe.lisp:148
#, fuzzy
msgid "~%Slots:"
msgstr "~%Ranuras:"

#: describe.lisp:155
msgid "unbound"
msgstr "sin asociar"

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#: describe.lisp:158
#, fuzzy
msgid "~%No slots."
msgstr "~%Sin ranuras."

#: describe.lisp:165
#, fuzzy
msgid "a foreign pointer."
msgstr "una puntero externo"

#: describe.lisp:168
#, fuzzy
msgid "a foreign address."
msgstr "una dirección externa"

#: describe.lisp:171
msgid "a foreign variable of foreign type ~S."
msgstr "una variable externa del tipo extranjero ~S."

#: describe.lisp:175
msgid "a server socket accepting connections."
msgstr ""

#: describe.lisp:177
msgid "a byte specifier, denoting the ~S bits starting at bit position ~S of an integer."
msgstr "un especificador de byte que denota los ~S bits que comienzan en el bit ~S de un entero"

#: describe.lisp:180
msgid "a special form handler."
msgstr "un manipulador de forma especial."

#: describe.lisp:182
msgid "a load-time evaluation promise."
msgstr "una promesa de evaluación en tiempo de carga."

#: describe.lisp:184
#, fuzzy
msgid "a symbol macro handler."
msgstr "un manipulador de forma especial."

#: describe.lisp:186
#, fuzzy
msgid "a macro expander."
msgstr "un manipulador de forma especial."

#: describe.lisp:187 describe.lisp:323 describe.lisp:482
#, fuzzy
msgid "~%For more information, evaluate ~{~S~^ or ~}."
msgstr "~%Para más información, evalúe ~{~S~^ o ~}."

#: describe.lisp:192
msgid "a function with alternative macro expander."
msgstr ""

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: describe.lisp:194
#, fuzzy
msgid "an encoding."
msgstr "un cons."

#: describe.lisp:199
msgid "a GC-invisible pointer to ~S."
msgstr ""

#: describe.lisp:202
msgid "a GC-invisible pointer to a now defunct object."
msgstr ""

#: describe.lisp:204
msgid "a label used for resolving #~D# references during READ."
msgstr "una etiqueta para resolver #~D# referencias en READ."

#: describe.lisp:208
msgid "a pointer into the stack. It points to:"
msgstr "Un puntero a la pila. Apunta a:"

#: describe.lisp:211
msgid "a special-purpose object."
msgstr "un objeto de propósito especial."

#: describe.lisp:213
msgid "a machine address."
msgstr "una dirección de máquina."

#: describe.lisp:215
msgid "an instance of the CLOS class ~S."
msgstr "una instancia de la clase CLOS ~S."

#: describe.lisp:219
msgid "a structure of type ~S."
msgstr "una estructura del tipo ~S."

#: describe.lisp:223
msgid "~%As such, it is also a structure of type ~{~S~^, ~}."
msgstr "Como tal, también es una estructura del tipo ~{~S~^, ~}."

#: describe.lisp:231
msgid "a dotted list of length ~S."
msgstr "una lista punteada de longitud ~S."

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: describe.lisp:233
msgid "a cons."
msgstr "un cons."

#: describe.lisp:236
msgid "a list of length ~S."
msgstr "una lista de longitud ~S."

#: describe.lisp:238
msgid "a cyclic list."
msgstr "una lista cíclica."

#: describe.lisp:240
msgid "the empty list, "
msgstr "la lista vacía, "

#: describe.lisp:243
#, fuzzy
msgid "the symbol ~S, "
msgstr "el símbolo ~S"

#: describe.lisp:247
msgid "lies in ~S"
msgstr "está en el ~S"

# Duda: He traducido al estilo del mensaje en francés: "n'appartient
# aucun paquetage"
#
#: describe.lisp:250
msgid "is uninterned"
msgstr "no aparece en ningún paquete"

# Nota: Caso brillante de la generación de mensajes diferentes gracias a las
#       directivas condicionales del Clisp (y del Common Lisp en general).
#
#: describe.lisp:264
#, fuzzy
msgid ", is accessible in ~:d package~:[~;s~] ~{~A~^, ~}"
msgstr " y es accesible desde ~:[el paquete~;los paquetes~] ~{~A~^, ~}"

#: describe.lisp:269
#, fuzzy
msgid ", is a keyword"
msgstr ", una palabra clave"

#: describe.lisp:272
msgid ", a constant"
msgstr ", una constante"

#: describe.lisp:274
msgid ", a variable declared SPECIAL"
msgstr ", una variable declarada SPECIAL"

#: describe.lisp:275
msgid ", a variable"
msgstr ", una variable"

#: describe.lisp:277
#, fuzzy
msgid " (macro: ~s)"
msgstr " (macro)"

#: describe.lisp:280
#, fuzzy
msgid ", value: ~s"
msgstr " valores: "

#: describe.lisp:284
#, fuzzy
msgid ", an unbound variable declared SPECIAL"
msgstr ", una variable declarada SPECIAL"

#: describe.lisp:286
msgid ", names "
msgstr ", nombra "

#: describe.lisp:288
#, fuzzy
msgid "a special operator"
msgstr "una forma especial"

# Sugerencia: definición de macro. sv
#
# Hmmm, ..., lo de macro definición es bastante típico en informática
# (ya sabes, ...) Sin embargo, en Lisp se suele decir definición de
# macro, tal y como tú propones, ..., pues vale, ¡sugerencia
# completamente aceptada! cll
#
#: describe.lisp:290
msgid " with macro definition"
msgstr " con definición de macro"

#: describe.lisp:292
#, fuzzy
msgid "a~:[~; deprecated~] function"
msgstr "una función ~:[interpret~;compil~]ada."

#: describe.lisp:295
#, fuzzy
msgid "a~:[~; deprecated~] macro"
msgstr "una función ~:[interpret~;compil~]ada."

#: describe.lisp:299
msgid " (use ~s instead)"
msgstr ""

#: describe.lisp:304
msgid ", names a type"
msgstr ", nombra un tipo"

#: describe.lisp:308
msgid ", names a class"
msgstr ", nombra una clase"

#: describe.lisp:314
#, fuzzy
msgid ", has ~:D propert~@:P ~{~S~^, ~}"
msgstr ", tiene ~[~;la propiedad~:;las propiedades~] ~{~S~^, ~}"

#: describe.lisp:317 describe.lisp:351 describe.lisp:374 describe.lisp:395 describe.lisp:450
msgid "."
msgstr "."

#: describe.lisp:321
#, fuzzy
msgid "~%Documentation as a ~a:~%~a"
msgstr "~%documentación: ~A"

#: describe.lisp:327
#, fuzzy
msgid "an integer, uses ~S bit~:p, is represented as a ~(~A~)."
msgstr "un entero que usa ~S bits y se representa como un ~(~A~)."

#: describe.lisp:330
msgid "a rational, not integral number."
msgstr "un racional, no un número entero."

#: describe.lisp:332
msgid "a float with ~S bits of mantissa (~(~A~))."
msgstr "un número en coma flotante con ~S bits de mantisa (~(~A~))."

#: describe.lisp:335
msgid "a complex number "
msgstr "un número complejo "

#: describe.lisp:340
msgid "at the origin"
msgstr "en el origen"

#: describe.lisp:341
msgid "on the ~:[posi~;nega~]tive real axis"
msgstr "en el eje real ~:[posi~;nega~]tivo"

#: describe.lisp:344
msgid "on the ~:[posi~;nega~]tive imaginary axis"
msgstr "en el eje imaginario ~:[posi~;nega~]tivo"

#: describe.lisp:346
#, fuzzy
msgid "in the ~:[~:[first~;fourth~]~;~:[second~;third~]~] quadrant"
msgstr "en el ~:[~:[primer~;cuarto~]~;~:[segundo~;tercer~]~] cuadrante"

# Si es lo que me imagino, tal vez sería mejor poner "del plano complejo".
# (como matemático que soy, me suena mejor :-). sv
#
# Pues sí, es exactamente lo que te imaginas, ..., "el plano de los números
# gaussianos" era una >>horrible<< traducción, ... ¡Gracias! cll
#
#: describe.lisp:348
msgid " of the Gaussian number plane."
msgstr " del plano complejo."

#: describe.lisp:350
msgid "a character"
msgstr "un carácter"

#: describe.lisp:355
msgid "~%Unicode name: ~A"
msgstr ""

#: describe.lisp:356
msgid "~%It is not defined by the Unicode standard."
msgstr ""

#: describe.lisp:357
msgid "~%It is a ~:[non-~;~]printable character."
msgstr "~% Se trata de un carácter ~:[no ~;~]imprimible."

#: describe.lisp:360
msgid "~%Its use is non-portable."
msgstr "~%Su utilización no es portable."

#: describe.lisp:362
msgid "a~:[~:[ closed ~;n output-~]~;~:[n input-~;n input/output-~]~]stream."
msgstr "un flujo ~:[~:[cerrado~;de salida~]~;~:[de entrada~;de entrada/salida~]~]."

#: describe.lisp:368
msgid "the package named ~A"
msgstr "el paquete ~A"

#: describe.lisp:372
#, fuzzy
msgid ". It has ~:d nickname~:[~;s~] ~{~A~^, ~}"
msgstr ". Tiene los apodos ~{~A~^, ~}"

# Duda: Debo comprobarlo en el código fuente de CLisp pero estoy casi
# seguro que esto es mucho mejor dejarlo sin traducir, ... cll
#
#: describe.lisp:377
#, fuzzy
msgid "~%It "
msgstr "~%"

#: describe.lisp:379
#, fuzzy
msgid "imports the external symbols of ~:d package~:[~;s~] ~{~A~^, ~} and "
msgstr "importa los símbolos externos de~:[l paquete~; los paquetes~] ~{~A~^, ~} y "

#: describe.lisp:385
#, fuzzy
msgid "exports ~[no symbols~:;~:*~:d symbol~:[~;s~]~]"
msgstr "~:[no exporta ningún símbolo~;exporta los símbolos~:*~{~<~%~:; ~S~>~^~}~]"

#: describe.lisp:388
msgid "~{ ~S~^,~}"
msgstr ""

#: describe.lisp:391
#, fuzzy
msgid " to ~:d package~:[~;s~] ~{~A~^, ~}"
msgstr " ~:[al paquete~;a los paquetes~]: ~{~A~^, ~}"

#: describe.lisp:394
msgid ", but no package uses these exports"
msgstr ""

#: describe.lisp:396
msgid "a deleted package."
msgstr "un paquete borrado."

#: describe.lisp:399
msgid "an ~s hash table with ~[no entries~:;~:*~:d entr~:[y~;ies~]~]."
msgstr ""

# Este mensaje tiene una especial dificultad, porque de el deberían
# salir cosas del tipo: "una tabla de lectura" (con `tabla de lectura'
# al final del mensaje) o "la tabla de lectura de Common Lisp" (con
# `tabla de lectura' al principio).
#
# Afortunadamente, la situación puede salvarse sin ningún problema
# gracias a la directiva ~:* de format
#
#: describe.lisp:402
msgid "~:[a~;the Common Lisp~] readtable."
msgstr "~:[una~;la~] tabla de lectura~:*~:[~; de Common Lisp~]"

#: describe.lisp:405
msgid "a ~:[~;portable ~]pathname~:[.~;~:*, with the following components:~{~A~}~]"
msgstr "una trayectoria~:[~; portátil~]~:[.~;~:*, constituída por: ~{~A~}~]"

#: describe.lisp:420
msgid "a random-state."
msgstr "un estado aleatorio."

#: describe.lisp:424
msgid "a~:[~; simple~] ~A dimensional array"
msgstr "una matriz~:[~; simple~] de dimensión ~A"

#: describe.lisp:427
msgid " (vector)"
msgstr " (vector)"

#: describe.lisp:430
msgid " with no storage"
msgstr ""

#: describe.lisp:431
#, fuzzy
msgid " of ~As"
msgstr " de ~(~A~)s"

#: describe.lisp:433
msgid ", adjustable"
msgstr ", ajustable"

#: describe.lisp:435
msgid ", of size ~{~S~^ x ~}"
msgstr ", de tamaño ~{~S~^ x ~}"

#: describe.lisp:438
msgid " and current length (fill-pointer) ~S"
msgstr " y longitud actual (fill-pointer) ~S"

#: describe.lisp:442
#, fuzzy
msgid " (a string)"
msgstr "buscar una cadena de caracteres"

#: describe.lisp:445
msgid " (a "
msgstr ""

#: describe.lisp:446
msgid "immutable "
msgstr ""

#: describe.lisp:447
msgid "reallocated "
msgstr ""

#: describe.lisp:448
msgid "~A string)"
msgstr ""

#: describe.lisp:455
#, fuzzy
msgid "a foreign function of foreign type ~S."
msgstr "una variable externa del tipo extranjero ~S."

#: describe.lisp:461
msgid "a built-in system function."
msgstr "una función predefinida del sistema."

#: describe.lisp:469
msgid "a~:[n interpret~; compil~]ed function."
msgstr "una función ~:[interpret~;compil~]ada."

#: describe.lisp:485
#, fuzzy
msgid "~%argument list: ~:S"
msgstr "~%lista de argumentos: ~S"

#: describe.lisp:488
#, fuzzy
msgid "~%documentation: ~A"
msgstr "~%documentación: ~A"

#: describe.lisp:494
msgid "~&~%~A [see above]"
msgstr ""

#: describe.lisp:497
msgid "~&~%~A is "
msgstr ""

#: describe.lisp:500
#, fuzzy
msgid "~&Documentation:"
msgstr "~%documentación: ~A"

#: describe.lisp:534
#, fuzzy
msgid "~%Argument list: "
msgstr "~%lista de argumentos: "

#: room.lisp:17
msgid "~S: argument must be ~S, ~S or ~S, not ~S"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: room.lisp:51 room.lisp:215
msgid "Total"
msgstr "Total"

#: room.lisp:59
msgid "~%Bytes permanently allocated:   ~9D~%Bytes currently in use:        ~9D~%Bytes available until next GC: ~9D~%"
msgstr "~%Bytes permanentemente asignados:   ~9D~%Bytes actualmente en uso:        ~9D~%Bytes disponibles hasta el próximo GC: ~9D~%"

#: edit.lisp:28
msgid "No external editor installed."
msgstr "No hay ningún editor externo instalado"

#: edit.lisp:82
msgid "~S cannot be edited."
msgstr "~S no puede ser editado."

#: edit.lisp:101
msgid "~S: source code for ~S not available."
msgstr "~S: el código fuente de ~S no está disponible."

#: macros3.lisp:13
msgid ""
"The form ~S yielded ~:[no values~;~:*~{~S~^ ; ~}~] ,~@\n"
"                       that's not of type ~S."
msgstr ""
"La forma ~S ~:[no produjo ningún valor~;produjo ~:*~{~S~^ ; ~}~] ,~@\n"
"                       que no es del tipo ~S."

#: macros3.lisp:62
msgid "LETF* code contains a dotted list, ending with ~S"
msgstr "El código del LETF* contiene una lista punteada que termina con ~S"

#: macros3.lisp:81
msgid "illegal syntax in LETF* binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF*: ~S"

#: macros3.lisp:224
msgid "LETF code contains a dotted list, ending with ~S"
msgstr "El código de LETF contiene una lista punteada que termina con ~S"

#: macros3.lisp:243
msgid "illegal syntax in LETF binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF: ~S"

#: threads.lisp:45
#, fuzzy
msgid "~S: ~S does not own ~S"
msgstr "~S: ~S no nombra una clase"

# Creo que si ~S es un sólo carácter, te cabe en la misma línea :-) sv
#
#: foreign1.lisp:100
msgid "Cannot map string ~S to C since it contains a character ~S"
msgstr "La cadena ~S no puede convertirse a C puesto que contiene el carácter ~S"

#: foreign1.lisp:134
msgid "Invalid ~S component: ~S"
msgstr "Componente ~S inválida: ~S"

#: foreign1.lisp:194
msgid "Incomplete FFI type ~S is not allowed here."
msgstr "El tipo incompleto FFI ~S no está permitido aquí"

#: foreign1.lisp:198
msgid "FFI type should be a symbol, not ~S"
msgstr "Un tipo FFI debe ser un símbolo, no ~S"

# Duda: pues un poco lo de siempre. FFI significa Foreign Function
# Interface y todo el mundo sabe que es el módulo de llamadas a
# funciones escritas en otro lenguaje (lo que yo he traducido como
# llamadas extranjeras). Los programadores avanzados en Lisp (y sólo
# ellos podrían ver un mensaje como este, ...) saben muy bien lo que es
# FFI. ¿Lo dejo así?, ...
#
# Uno de nuestros revisores (César Ballardini) dijo en cierta ocasión:
# "No es necesario explicar la terminología dentro de su propio contexto."
# Es decir: Si finalmente te decides por FFI (que por lo que dices
# parece lo más razonable), pon cuidado de no explicarlo tanto, por ejemplo,
# en el mensaje anterior al anterior a este. sv
#
# Vale, pues entonces se queda como FFI ¡y listo! cll
#
#: foreign1.lisp:201
msgid "Invalid FFI type: ~S"
msgstr "Tipo FFI inválido: ~S"

#: foreign1.lisp:267
msgid "Invalid option in ~S: ~S"
msgstr "Opción inválida en ~S: ~S"

#: foreign1.lisp:270
msgid "Only one ~S option is allowed: ~S"
msgstr "Sólo se permite una opción ~S: ~S"

#: foreign1.lisp:318
msgid "Invalid parameter specification in ~S: ~S"
msgstr "Especificación de parámetro inválida en ~S: ~S"

#: foreign1.lisp:332
#, fuzzy
msgid "~s argument ~s is not a pointer in ~s"
msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#: foreign1.lisp:361
msgid "~s: No ~s argument and no ~s form in this compilation unit; ~s assumed now and for the rest of this unit"
msgstr ""

#: foreign1.lisp:367
msgid "The name must be a string, not ~S"
msgstr "El nombre debe ser una cadena, no ~S"

#: foreign1.lisp:371
msgid "The name ~S is not a valid C identifier"
msgstr "El nombre ~S no es un identificador válido en C"

#: foreign1.lisp:600
msgid "illegal foreign data type ~S"
msgstr "el tipo de datos extranjero ~ es inválido"

#: foreign1.lisp:728
msgid "~S: ~S option missing in ~S"
msgstr "~S: falta la opción ~S en ~S"

#: foreign1.lisp:846 foreign1.lisp:902
#, fuzzy
msgid "~s is deprecated, use ~s instead"
msgstr "Función no implementada"

#: foreign1.lisp:985
msgid "~S: :OUT argument is not a pointer: ~S"
msgstr "~S: el argumento :OUT no es un puntero: ~S"

#: foreign1.lisp:1036
msgid "~S (~S): value ~S will be assigned to both ~S and ~S"
msgstr ""

#: foreign1.lisp:1045
#, fuzzy
msgid "~S does not name a C enum type"
msgstr "~S no es una función genérica"

#: foreign1.lisp:1048
#, fuzzy
msgid "~S is not of C enum type ~S"
msgstr "el objeto no es del tipo requerido"

#: foreign1.lisp:1052
msgid "~S symbol value (~S) does not match its table value (~S) in ~S"
msgstr ""

#: foreign1.lisp:1057
#, fuzzy
msgid "~S is not a valid value of type ~S"
msgstr "~ no es un byte CODE-VECTOR válido"

#: foreign1.lisp:1073
msgid "~S is only allowed after ~S: ~S"
msgstr "Sólo se puede poner ~S después de ~S: ~S"

#: affi1.lisp:39
msgid "Basename ~S not a keyword or libraryname ~S not a string"
msgstr "La base ~S no es una palabra clave o el nombre de la biblioteca ~S no es una cadena de caracteres"

#: affi1.lisp:47
msgid "Library redefinition: old ~S, new ~S"
msgstr "La biblioteca llamada ~S ha sido redefinida como ~S"

#: affi1.lisp:57
msgid "Unknown library: ~S"
msgstr "Biblioteca desconocida: ~S"

#: affi1.lisp:83
msgid "Library ~S is not open"
msgstr "La biblioteca ~S no está abierta"

#: affi1.lisp:144
msgid "Unknown function of library ~S: ~S"
msgstr "No se conoce ninguna función en la biblioteca ~S con el nombre ~S"

#: affi1.lisp:170
msgid "Offset must be a fixnum: ~S"
msgstr "El desplazamiento no es del tipo FIXNUM: ~S"

#: affi1.lisp:180
msgid "~&;; redefining foreign library function ~S~%;;  from ~S to ~S~%"
msgstr "~&;; redefiniendo la función ~S de la biblioteca externa~%;;  de ~S a ~S~% "

#: affi1.lisp:199
msgid "Unknown register: ~S"
msgstr "Registro desconocido: ~S"

#: affi1.lisp:210
msgid "Invalid parameter specification ~S in function ~S"
msgstr "La especificación de parámetros ~S de la función ~S es incorrecta"

#: affi1.lisp:221
msgid "Unknown library function: ~S"
msgstr "La función de biblioteca ~S no está definida"

#: affi1.lisp:237
msgid "Bad number of arguments for ~S: ~S"
msgstr "El número de argumentos de ~S es incorrecto: ~S"
