# Mensajes en español para GNU CLISP.
# Copyright (C) 1996 Free Software Foundation, Inc.
# Carlos Linares López <clinares@delicias.dia.fi.upm.es>, 1997.
#
# Han contribuido a esta traducción:
#
# cll - Carlos Linares López 	(Traducción)
# sv  - Santiago Vila Doncel	(Revisión)
# lsg - Leonardo Sarasúa García	(Traducción y Revisión)
#
# Agradecimientos especiales a:
#
# Bruno Haible
# Marcus Daniels
# 					(Programadores de CLisp)
#
# Enrique Melero
# 				    (Coordinador de Spanish GNU)
#
# Por haber atendido siempre mis preguntas y por mostrar tanto interés
# en esta traducción.
#
# Asimismo, quisiera expresar mi agradecimiento a las siguientes
# personas, por responder pacientemente todas mis preguntas: Joerg
# Hoehle (traductor de la versión francesa) y Juan Jordana.
#
# Por último, a toda la lista de Spanish GNU Translation Team
# (es@li.org) por sus sugerencias.
#
# NOTAS.
#
# * Los mensajes en los que se han realizado anotaciones de interés,
# bien porque haya alguna duda, bien porque contenga notas importantes
# relativas a las traducciones tienen la palabra `Duda:' al principio de
# su comentario.
#
# * Por favor, si alguien realiza alguna modificación a este archivo que
# ponga sus iniciales al final del comentario explicando el cambio y el
# motivo. Si su nombre no está en esta cabecera que lo añada poniendo
# las iniciales.
#
# * Todas las líneas que comienzan con #~ son mensajes obsoletos que no
# hace falta revisar. En cualquier caso, intentaré normalmente
# eliminarlas.
#
# $Id$
# $Log$
# Revision 1.8  1998/11/04 13:11:59  haible
# Regenerated.
#
# Revision 1.12  1998/09/07 18:21:38  clinares
# Traducción de todos los mensajes para la versión del 29-8-1998. Estos
# cambios, sin embargo, serán publicados en alguna nueva versión de
# septiembre de este mismo año.
#
# Revision 1.9  1997/09/18 13:36:38  clinares
# He incluído nuevas modificaciones de Leo Sarasúa.
#
# Entre las más representativas está el hecho de haber modificado
# `trama' por `marco' y `# macro carácter' por `macro carácter
# secundario'. Nuevamente gracias, Leo, ...
#
# Revision 1.8  1997/09/05 17:23:30  clinares
# He introducido todas las modificaciones propuestas por Santiago Vila a
# la versión 1.6. Además, las he adaptado para el nuevo .pot que se
# empleó en la versión 1.7.
#
# Entre los cambios más importantes está: `command' es `orden', no
# `comando'; `warning' es, preferiblemente, `atención' y, en otro caso,
# propongo que sea `advertencia', en vez de `aviso'.
#
# Revision 1.7  1997/09/03 17:51:44  clinares
# He modificado la traducción de las directivas ~P, puesto que nunca se
# escribirán versiones en español de ellas, ya que el estándar Common
# Lisp - The Language es muy específico: solo en inglés. Ni en alemán,
# ni francés, ni español, ...
#
# Además, he adaptado los cambios del POT de la versión 1.6
# (POT-Creation-Date: 1997-05-04) a la última versión que existe
# actualmente (POT-Creation-Date: 1997-09-02). Para ello, he traducido 9
# mensajes nuevos, he corregido los mensajes difusos y he borrado todos
# los obsoletos.
#
# Revision 1.6  1997/08/30 14:04:08  clinares
# El 100% de los mensajes están traducidos :)
# En total, 9 meses de trabajo (es decir, ¡¡ha sido un parto!! :)
#
# Revision 1.5  1997/08/27 00:48:46  clinares
# Esta es la traducción que resulta de programar todos los cambios
# propuestos por lsg (Leonardo Sarasúa García). En total, ¡¡alrededor de
# 800 líneas!!, ahí es nada :)
#
# Muchísimas gracias, Leo. Te debo la cerveza más grande del mundo, ...
#
# ------------------------------------------------------------------
# msgfmt --statistics -c -v -o /dev/null /home/clinares/GNU/clisp.po
# 1406 mensajes traducidos.
# ------------------------------------------------------------------
#
msgid ""
msgstr ""
"Project-Id-Version: GNU clisp 1996-03-31\n"
"POT-Creation-Date: 1998-11-04 08:00:05 EST\n"
"PO-Revision-Date: 1997-08-11 18:16 MET DST\n"
"Last-Translator: Carlos Linares López <clinares@delicias.dia.fi.upm.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: constobj.d:333
msgid "Please choose:"
msgstr "Por favor, escoja:"

#: constobj.d:339
msgid "Please choose one of ~:{~A~:^, ~} ."
msgstr "Por favor, elija uno/a de ~:{~A~:^, ~} ."

#: constobj.d:344
msgid "symbol ~A from #<PACKAGE ~A> will become a shadowing symbol"
msgstr "el símbolo ~A del paquete #<PACKAGE ~A> se convertirá en un símbolo que eclipsa a otro"

#: constobj.d:348
msgid "You may choose the symbol in favour of which to resolve the conflict."
msgstr "Puede elegir el símbolo en favor del cual se resolverá el conflicto."

#: constobj.d:352
msgid "uninterning ~S from ~S uncovers a name conflict."
msgstr "Al sacar ~S de ~S se ha puesto de manifiesto un conflicto entre nombres."

#: constobj.d:356 constobj.d:386
msgid "You may choose how to proceed."
msgstr "Puede elegir cómo continuar."

#: constobj.d:360
msgid "importing ~S into ~S produces a name conflict with ~S."
msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S."

#: constobj.d:364
msgid "importing ~S into ~S produces a name conflict with ~S and other symbols."
msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S y otros símbolos."

#
# publicar está mal y ademas no es consistente con el mensaje d:329 en el que dice 'sacar'
# En este y en otros mensajes, el texto no es una orden dada al usuario, sino una opción que
# se le ofrece. Por tanto, no debe traducirse como un imperativo (impórtelo)  sino en
# infinitivo (importarlo). Pero deberías confirmar esto. - lsg
#
# Si, creo que tienes toda la razón, ... Entonces pongo `sacar' que
# aunque suene muy burro, creo que es muy, muy claro, ...
#
#: constobj.d:368
msgid "((\"I\" \"import it and unintern the other symbol\" T) (\"N\" \"do not import it, leave undone\" NIL))"
msgstr "((\"I\" \"impórtarlo y sacar el otro símbolo\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Aquí tengo la misma duda anterior - lsg
#
#: constobj.d:375
msgid "((\"I\" \"import it, unintern one other symbol and shadow the other symbols\" T) (\"N\" \"do not import it, leave undone\" NIL))"
msgstr "((\"I\" \"importarlo, sacar uno de los otro símbolos y eclipsar el resto\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Lo mismo de antes - lsg
#
#: constobj.d:382
msgid "((\"I\" \"import it and shadow the other symbol\" T) (\"N\" \"do nothing\" NIL))"
msgstr "((\"I\" \"importarlo y eclipsar el otro símbolo\" T) (\"N\" \"no hacer nada\" NIL))"

#: constobj.d:390
msgid "symbol ~S should be imported into ~S before being exported."
msgstr "el símbolo ~S debe ser importado a ~S antes de ser exportado."

#
# La misma cuestión anterior entre imperativo e infinitivo - lsg
#
#: constobj.d:394
msgid "((\"I\" \"import the symbol first\" T) (\"N\" \"do nothing, don't export the symbol\" NIL))"
msgstr "((\"I\" importar el símbolo primero\" T) (\"N\" \"no hacer nada, no exportar el símbolo\"))"

#: constobj.d:401
msgid "You may choose in favour of which symbol to resolve the conflict."
msgstr "Puede elegir en favor de qué símbolo se debe resolver el conflicto."

#
# El segundo from deberia ser 'de', porque quiere decir que un símbolo
# a de un paquete A entra en conflicto con el símbolo b _del_ paquete
# B. Luego, debe ser 'de'.
#
#: constobj.d:405
msgid "exporting ~S from ~S produces a name conflict with ~S from ~S."
msgstr "la exportación de ~S desde ~S produce un conflicto de nombres con ~S de ~S."

#: constobj.d:409
msgid "Which symbol should be accessible in ~S ?"
msgstr "¿ Qué símbolo debe ser accesible en ~S ?"

#: constobj.d:415
msgid "the symbol to export, "
msgstr "el símbolo a exportar, "

#: constobj.d:419
msgid "the old symbol, "
msgstr "El símbolo original, "

#: constobj.d:423
msgid "You may choose for every conflict in favour of which symbol to resolve it."
msgstr "Puede elegir en favor de qué símbolo se debe resolver cada conflicto."

#
# Es una traducción un poco libre (literalmente sería "el nombre = ~S
# entra en conflicto...."), pero ésta me parece más corta y correcta. - lsg
#
#: constobj.d:427
msgid "~S name conflicts while executing USE-PACKAGE of ~S into package ~S."
msgstr "Conflicto de nombre ~S al ejecutar USE-PACKAGE de ~S al paquete ~S"

#: constobj.d:431
msgid "which symbol with name ~S should be accessible in ~S ?"
msgstr "¿ Qué símbolo con nombre ~S debe ser accesible en ~S ?"

#: constobj.d:435
msgid "You can input another name."
msgstr "Puede introducir otro nombre."

#: constobj.d:439
msgid "You can input another nickname."
msgstr "Puede introducir otro apodo."

#: constobj.d:443
msgid "a package with name ~S already exists."
msgstr "ya existe un paquete con el nombre ~S."

#
# Si fuera inglés corriente, estaría bien tu traducción, pero es inglés
# 'telegráfico', y en realidad quieren decir lo que te he escrito, es
# decir, 'nuevo' afecta a 'nombre', no a 'paquete'.
#
# Eres un gran maestro, algo así como un quinto dan de las traducciones,
# ... ¡Tienes toda la razón! :) - cll
#
#: constobj.d:447
msgid "Please input new package name:"
msgstr "Por favor, introduzca un nuevo nombre de paquete:"

#: constobj.d:451
msgid "Please input new package nickname:"
msgstr "Por favor, introduzca un nuevo apodo de paquete:"

# Ojo con el ignorar. sv
#
# No, ya te he puesto antes las acepciones de esta palabra y esta vez,
# viene al caso, ... cll
#
# O sea, que estás 'ignorando ' la sugerencia de sv, ;-) - lsg
#
# Muy bueno, muy bueno, ... :) Santiago, por aquí hay mucho cachondeo :) - cll
#
#
#: constobj.d:455
msgid "Ignore."
msgstr "Ignorar."

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~S.",
# pienso que "No hay ningún paquete con el nombre ~S" es ligeramente
# mejor, ¿qué te parece? - cll
#
#: constobj.d:459
msgid "~S: There is no package with name ~S."
msgstr "~S: No hay ningún paquete con el nombre ~S."

#: constobj.d:463
msgid "~*Nevertheless delete ~S."
msgstr "~*No obstante borre ~S."

#
# Leo, en vez de "está siendo utilizado", ¿no crees que es mejor "es
# utilizado"? - cll
#
# Propongo *se utiliza*, es mucho más español. sv
#
# Pero, ¿cómo pones algo así? "~S se utiliza en ~{~S~^, ~}.", ¿por
# ejemplo? Es que el problema es que no ~S (el primero) no "se utiliza"
# en la segunda expresión, sino que la segunda expresión es una que
# emplea a la primera. No se si me explico, ...
#
# En cualquier caso, creo que tienes toda la razón al decir "es mucho
# más español", es que de hecho la expresión "es utilizado" aunque es
# correcta, no parece muy española, por favor, ¿sugerencias? - cll
#
#: constobj.d:467
msgid "~S: ~S is used by ~{~S~^, ~}."
msgstr "~S: ~S es utilizado por ~{~S~^, ~}."

#: constobj.d:483
msgid "January"
msgstr "Enero"

#: constobj.d:489
msgid "February"
msgstr "Febrero"

#: constobj.d:495
msgid "March"
msgstr "Marzo"

#: constobj.d:501
msgid "April"
msgstr "Abril"

#: constobj.d:507
msgid "May"
msgstr "Mayo"

#: constobj.d:513
msgid "June"
msgstr "Junio"

#: constobj.d:519
msgid "July"
msgstr "Julio"

#: constobj.d:525
msgid "August"
msgstr "Agosto"

#: constobj.d:531
msgid "September"
msgstr "Septiembre"

#: constobj.d:537
msgid "October"
msgstr "Octubre"

#: constobj.d:543
msgid "November"
msgstr "Noviembre"

#: constobj.d:549
msgid "December"
msgstr "Diciembre"

#: constobj.d:565
msgid "ANSI C program"
msgstr "programa ANSI C"

#: constobj.d:571
msgid "GNU C++ "
msgstr "GNU C++"

#: constobj.d:576
msgid "GNU C "
msgstr "GNU C "

#: constobj.d:585
msgid "C++ compiler"
msgstr "Compilador de C++"

#: constobj.d:590
msgid "C compiler"
msgstr "Compilador de C"

# Ojo: ¿¿No sería "INGLÉS"?? sv
#
# No, esto está bien, esta expresión se utiliza en una parte del código
# de CLisp en la que se realiza la inicialiación dependiente del idioma,
# de modo que en la traducción alemana pone "DEUTSCH" y en la francesa
# "FRANCAIS", pues en la española, "ESPAÑOL", como corresponde - cll
#
#: constobj.d:597
msgid "ENGLISH"
msgstr "ESPAÑOL"

#: constobj.d:757
msgid "The value of ~S was not a pathname. ~:*~S is being reset."
msgstr "El valor de ~S no es del tipo PATHNAME. ~:*~S se reinicializará."

# Duda: ¿Creando *el* directorio? ¿Creando *un* directorio? De momento,
# simplemente "Creando directorio" - cll
#
#: constobj.d:764
msgid "Creating directory: "
msgstr "Creando directorio: "

#: constobj.d:901
msgid ""
"The variable ~S had an illegal value.\n"
"~S has been reset to ~S."
msgstr ""
"La variable ~S tenía un valor inválido.\n"
"~S ha sido inicializado a ~S."

#: constobj.d:905
msgid ""
"Floating point operation combines numbers of different precision.\n"
"See ANSI CL 12.1.4.4 and the CLISP impnotes for details.\n"
"The result's actual precision is controlled by\n"
"~S.\n"
"To shut off this warning, set ~S to ~S."
msgstr ""
"Las operaciones en coma flotante combinan números de diferentes precisiones.\n"
"Para más detalles, consulte ANSI CL 12.1.4.4 y las notas de implementación de\n"
"CLISP.\n"
"La precisión actual del resultado está controlada por\n"
"~S.\n"
"Para eliminar este aviso, establezca el valor de ~S a ~S."

#: constobj.d:922
msgid "Bye."
msgstr "Adiós."

# Un poco más en español podría ser: "Entorno siguiente: " sv
#
# Hmmm, ..., aquí no estoy de acuerdo contigo. No me suena bien lo del
# "Entorno siguiente", ... cll
#
#: constobj.d:929
msgid ""
"\n"
"  Next environment: "
msgstr ""
"\n"
"  Siguiente entorno: "

#: constobj.d:933
msgid ""
"\n"
"APPLY frame with breakpoint for call "
msgstr ""
"\n"
"marco APPLY con punto de ruptura para invocar "

#: constobj.d:937
msgid ""
"\n"
"APPLY frame for call "
msgstr ""
"\n"
"marco APPLY para invocar "

#: constobj.d:941
msgid ""
"\n"
"EVAL frame with breakpoint for form "
msgstr ""
"\n"
"marco EVAL con punto de ruptura para la forma "

#: constobj.d:945
msgid ""
"\n"
"EVAL frame for form "
msgstr ""
"\n"
"marco EVAL para la forma "

#
# A ver aquí, que hay mogollón, hay mogollón, ...
#
# Leo, tu opinas que aquí deberíamos traducir:
#
# "variables con vinculación de recintos (~ = dinámicamente):"
#
# Sin embargo, yo creo que lo más correcto es:
#
# "trama de ligadura de las variables (~ = dinámicamente):"
#
# Puesto que esto se refiere al tipo de tramas que hay en la pila,
# cuando ésta está siendo examinada. De hecho, la traducción francesa
# es:
#
# "Le «frame» de liaison de variables (~ signifiant dynamique) lie :"
#
# ..., que viene a ser algo como lo que he puesto yo. - cll
#
#: constobj.d:949
msgid ""
"\n"
"frame binding variables (~ = dynamically):"
msgstr ""
"\n"
"marco de ligadura de las variables (~ = dinámicamente):"

#: constobj.d:954
msgid ""
"\n"
"CALLBACK frame"
msgstr ""
"\n"
"marco CALLBACK"

#: constobj.d:959
msgid ""
"\n"
"frame binding variables "
msgstr ""
"\n"
"marco de ligadura de las variables"

#: constobj.d:963
msgid ""
"\n"
"frame binding functions "
msgstr ""
"\n"
"marco de ligadura de las funciones "

#: constobj.d:967
msgid " binds (~ = dynamically):"
msgstr " vincula (~ = dinámicamente):"

#: constobj.d:972
msgid ""
"\n"
"block frame "
msgstr ""
"\n"
"marco de bloque"

#: constobj.d:976
msgid ""
"\n"
"nested block frame "
msgstr ""
"\n"
"marco anidado de bloque"

#: constobj.d:980
msgid " for "
msgstr " para "

#: constobj.d:984
msgid ""
"\n"
"compiled block frame for "
msgstr ""
"\n"
"marco de bloque compilado para "

#: constobj.d:988
msgid ""
"\n"
"tagbody frame "
msgstr ""
"\n"
"marco de cuerpo de etiquetas de salto"

# Duda: Aquí lo de `nested' es bastante puñetero. Creo que no debe
# traducirse por `anidado' (que no tendría demasiado sentido, creo),
# sino por `encajada', haciendo referencia a la trama a la que se llega
# por el uso de las etiquetas de salto, ...
#
# Sin embargo, no estoy demasiado seguro, ... ¡¡Socorro!! - cll
#
# A propósito de esta cuestión, pregunté en la lista de correo de CLisp:
#
# > `nested' have various meanings. It can mean that one thing is `into'
# > other one or that one thing is `joined' with other one. In this
# > message, I think you are talking about the frame you arrive when using
# > a tag, as if you were `joining' a new frame, is it so?
#
# Y la respuesta de Bruno Haible fue:
#
# No. In CLISP it's yet another (maybe new?) meaning. Interpretation frames
# are normally built up in the stack. However, when a closure is created,
# some parts of the frames must be moved out to the heap, so that the
# closure points to valid data, called "environment", even after the frame
# has been deestablished. We called this process "nesting" of a frame.
# Any better vocabulary? Can you propose a good german or french translation?
#
# Asi que, la verdad, "anidado" me parece correcto. Para ello, imaginaos
# una trama (o marco), de la que se "re-elabora" una parte denominada
# "entorno" pero que solo tiene sentido dentro de esta trama (o marco),
# puesto que se ha levantado un `closure'. - cll
#
#: constobj.d:992
msgid ""
"\n"
"nested tagbody frame "
msgstr ""
"\n"
"marco anidado del cuerpo de etiquetas de salto"

#: constobj.d:996
msgid " for"
msgstr " para"

#: constobj.d:1001
msgid ""
"\n"
"compiled tagbody frame for "
msgstr ""
"\n"
"marco compilado del cuerpo de etiquetas de salto para "

#
# Ésta estaba claramente mal - lsg
#
#: constobj.d:1005
msgid ""
"\n"
"catch frame for tag "
msgstr ""
"\n"
"marco de captura para la etiqueta "

# Handler, otra buena.. Sugerencias? - lsg
#
# Duda: ¿cómo traducir `handler'?
#
# Pues bien, he elegido el término `manipulador' puesto que eso es,
# precisamente, lo que es un `handler' en Common Lisp. De hecho, el
# estándar Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr.,
# en la página 872 dice:
#
# "The process of signaling involves the search for an invocation of a
# handler, a piece of code that will attempt to deal appropiately with
# the situation"
#
# Y atención a la siguiente observación: (en la misma página, a
# continuación del párrafo anterior)
#
# "If a handle is found, it may either handle the situation, by
# performing some non-local transfer of control, or decline to handle
# it, by failing to perform a non-local transfer of control. If it
# declines, other handlers are sought".
#
# En fin, a la vista de esta definición y de la siguiente aclaración,
# propongo `manejador' para su traducción - cll
#
#: constobj.d:1009
msgid ""
"\n"
"handler frame for conditions"
msgstr ""
"\n"
"marco de manipulación (HANDLER) para las condiciones"

#
# Estaba mal. Yo pondria: "recinto de unwind-protect" - lsg
#
# Y yo creo que si cambiamos `recinto' por `trama' ya es la leche de
# perfecto ;) - cll
#
# Leo, como puedes ver he cambiado en todos lados `trama' por `marco' - cll
#
#: constobj.d:1013
msgid ""
"\n"
"unwind-protect frame"
msgstr ""
"\n"
"marco `unwind-protect'"

# Duda: Lo de `driver' lo dejo sin traducir, ...
#
# En la traducción francesa está sin traducir y en el estándar de Common
# Lisp no se hace ni la mas mínima referencia a algo que se llame así.
#
# "recinto de driver" - lsg
#
# Vale, ¡pero vamos!, que cambio `recinto' por `trama' - cll
#
#: constobj.d:1017
msgid ""
"\n"
"\n"
"driver frame"
msgstr ""
"\n"
"\n"
"marco `driver'"

# "Entornos con vinculación de recintos" - lsg
#
# Aquí volvemos un poco a lo del mensaje constobj.d:915 Según creo,
# estos mensajes se refieren al tipo de tramas que hay en la pila, no se
# trata de un entorno (en el sentido que en Lisp tiene esta palabra).
#
# La traducción francesa dice:
#
# "«frame» de liaison d'environnements"
#
# ¿Que os parece?
#
#: constobj.d:1021
msgid ""
"\n"
"frame binding environments"
msgstr ""
"\n"
"marco de ligadura del entorno"

#: spvw.d:591
msgid "could not make symbol value per-thread"
msgstr ""

# "*** - desbordamiento de la pila del programa - REINICIALIZANDO" - lsg
#
# En mi opinión, RESET debe traducirse como un imperativo - cll
#
#: spvw.d:644
msgid ""
"\n"
"*** - Program stack overflow. RESET"
msgstr ""
"\n"
"*** - Desbordamiento de la pila del programa. REINICIE"

# ¡ Toma puntilloso que soy! Lisp debería escribirse con mayúscula.
# "*** - desbordamiento de la pila de Lisp - REINICIALIZANDO" - lsg
#
# No, no, nada de REINICIALIZANDO. Debe ser un imperativo: REINICIE.
# Por ejemplo, si durante una sesión con CLisp haces:
#
# > (defun foo (a) (foo (1- a)))
# FOO
# > (foo 2)
#
# *** - Desbordamiento de la pila de Lisp. REINICIE
# >
#
# ..., pero el intérprete se queda esperando a que tú sigas tecleando,
# es decir, él solo no se pone a reiniciar nada, ...
#
# Por otra parte, tienes toda la razón, Lisp debe ir con mayúsculas :) - cll
#
#: spvw.d:653
msgid ""
"\n"
"*** - Lisp stack overflow. RESET"
msgstr ""
"\n"
"*** - Desbordamiento de la pila de Lisp. REINICIE"

#
# Muy bueno el apunte sobre ese acento en "cómo". Gracias, Santiago - cll
#
#: spvw.d:849
msgid ""
"internal error: statement in file ~, line ~ has been reached!!\n"
"Please send the authors of the program a description how you produced this error!"
msgstr ""
"error interno: ¡¡en la sentencia del fichero ~, línea ~!!\n"
"¡Por favor, envíe a los autores del programa una descripción de cómo\n"
"se produjo este error!"

#
# Por qué traduces signature asi?
# "Signatura desconocida de una FSUBR\n" - lsg
#
# Bueno, pues porque la traducción francesa dice:
#
# "Type d'argument inconnu pour FSUBR"
#
# Y mientras no sepa qué leches es eso del FSUBR (o SUBR, ver mensaje
# siguiente), pues para no pillarme los dedos lo dejaré tal y como lo
# puso Joerg Hoehle - cll
#
#: spvw.d:917
msgid "Unknown signature of an FSUBR\n"
msgstr "Tipo de argumento desconocido para FSUBR\n"

# ¿¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:1028
msgid "Unknown signature of a SUBR\n"
msgstr "Tipo de argumento desconocido para SUBR\n"

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#: spvw.d:1619
msgid "module `%s' requires package %s.\n"
msgstr "el módulo `%s' necesita el paquete %s.\n"

#: spvw.d:1875
msgid "Syntax for %s: nnnnnnn or nnnnKB or nMB\n"
msgstr "Sintaxis de %s: nnnnnnn or nnnnKB or nMB\n"

#
# "%s fuera de intervalo\n"
# No me gusta del todo. A lo mejor:
# "%s fuera de limites\n" - lsg
#
# Al final me he decidido por:
#
# "%s se ha salido del rango\n"
#
# ¿No te mola más? - cll
#
#: spvw.d:1882
msgid "%s out of range\n"
msgstr "%s se ha salido del rango\n"

#: spvw.d:1897
msgid "memory size"
msgstr "tamaño de memoria"

#: spvw.d:1910
msgid "stack size"
msgstr "tamaño de la pila"

#: spvw.d:2193
msgid "Return value of malloc() = %x is not compatible with type code distribution.\n"
msgstr "El valor devuelto por malloc() = %x no es compatible con la distribución del código de tipo.\n"

# solo es con acento.
# "sólo %d bytes disponibles\n" - lsg
#
# ¡¡Madre mía!! Tienes toda la razón del mundo - cll :)
#
#: spvw.d:2203
msgid "Only %d bytes available.\n"
msgstr "Sólo quedan %d bytes disponibles.\n"

# Duda: Imagino que SP es el "Stack Pointer". Pero entonces, ¿a qué
# viene decir "SP stack"? ¿Se referirán con ello a la pila del sistema?
# - cll
#
#: spvw.d:2441
msgid "Couldn't determine the end of the SP stack!\n"
msgstr "No fue posible determinar el final de la pila SP!\n"

# Antes de entrar en el debate sobre la traducción de port:
# ¿Es tan fundamentalmente distinto version y port en este contexto como
# para que no se pueda utilizar también versión para "port"? sv
#
# ¡¡Madre mía!! Eso de "antes de entrar" me ha dado muchísimo miedo,
# ... :) Asi que no se hable más, pongo "versión" :) No, ahora fuera
# cachondeo, en el contexto de estos mensajes la expresión "versión" es
# perfecta, ... - cll
#
#: spvw.d:2691
msgid "                    Amiga version: Jörg Höhle                     \n"
msgstr "                    Versión para Amiga: Jörg Höhle\n"

#: spvw.d:2701
msgid "                    RISCOS port: Peter Burwood, Bruno Haible      \n"
msgstr "                    Versión para RISCOS: Peter Burwood, Bruno Haible\n"

#: spvw.d:2711
msgid "                    DOS port: Jürgen Weber, Bruno Haible          \n"
msgstr "                    Versión para DOS: Jürgen Weber, Bruno Haible\n"

# "AVISO: No se ha especificado un fichero de inicializacion.\n" - lsg
#
# El mensaje inglés está en pretérito (specified) por eso yo he
# preferido poner "especificó" en vez de "ha especificado" - cll
#
# Pero Carlos, se ha especificado, es también pretérito,
# pretérito perfecto (compuesto), pero pretérito a fin de cuentas.
# No se ha especificado está más en la línea los demás
# mensajes de los otros ficheros .po. sv
#
# Vale, vale, ... La verdad es que a mí las dos me suenan igual de bien,
# de modo que, a tenor de la voluntad popular (dos votos contra uno),
# pues se pone como propuso Leo - cll
#
# Otra nota de interés es la siguiente: he cambiado "aviso" por
# "atención". Creo que así suena mejor. Sugerencia de Santiago - cll
#
#: spvw.d:2738
msgid ""
"\n"
"WARNING: No initialisation file specified.\n"
msgstr ""
"\n"
"ATENCIÓN: No se ha especificado ningún fichero de inicialización.\n"

#: spvw.d:2744
msgid "Please try: "
msgstr "Por favor, intente:"

#: spvw.d:2930
msgid "Not enough memory for Lisp.\n"
msgstr "No hay memoria suficiente para Lisp.\n"

# "*** - Memoria virtual agotada. REINICIALIZACION " - lsg
#
# Yo creo que el mensaje debe acabar en un imperativo: REINICIALIZAR - cll
#
#: spvw_alloca.d:43
msgid ""
"\n"
"*** - Virtual memory exhausted. RESET"
msgstr ""
"\n"
"*** - Memoria virtual agotada. REINICIE"

# "*** - Memoria agotada. REINICIALIZACION " - lsg
#
# Más de lo mismo - cll
#
#: spvw_alloca.d:49
msgid ""
"\n"
"*** - Memory exhausted. RESET"
msgstr ""
"\n"
"*** - Memoria agotada. REINICIE"

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:64 spvw_mmap.d:212 spvw_mmap.d:403 spvw_multimap.d:172
msgid "Cannot map memory to address 0x%x ."
msgstr "No se puede asignar la memoria a la dirección 0x%x ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:176
msgid "Cannot reserve address range at 0x%x ."
msgstr "No se puede reservar el rango de direcciones a 0x%x ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:190
msgid "Cannot reserve address range 0x%x-0x%x ."
msgstr "No se puede reservar el rango de direcciones 0x%x-0x%x ."

#: spvw_mmap.d:246
msgid "CreateFileMapping() failed."
msgstr "CreateFileMapping() falló."

#: spvw_mmap.d:257
msgid "MapViewOfFileEx(addr=0x%x,off=0x%x) failed."
msgstr "MapViewOfFileEx(dirección=0x%x,segmento=0x%x) falló."

#: spvw_mmap.d:267
msgid "MapViewOfFileEx() returned 0x%x instead of 0x%x.\n"
msgstr "MapViewOfFileEx() devolvió 0x%x en vez de 0x%x.\n"

#: spvw_mmap.d:286
msgid "VirtualFree() failed."
msgstr "VirtualFree() falló."

#: spvw_mmap.d:305
msgid "VirtualProtect() failed."
msgstr "VirtualProtect() falló."

#: spvw_mmap.d:375 spvw_multimap.d:111
msgid "Cannot open /dev/zero ."
msgstr "No se puede abrir /dev/zero."

# "msync(0x%x,0x%x,MS_INVALIDATE) fracasó." - lsg
#
# O "falló" en vez de "fracasó". ¿Qué te parece? - cll
#
#: spvw_multimap.d:141
msgid "msync(0x%x,0x%x,MS_INVALIDATE) fails."
msgstr "msync(0x%x,0x%x,MS_INVALIDATE) falló."

#: spvw_multimap.d:206
msgid "Cannot open %s ."
msgstr "No se puede abrir %s."

#: spvw_multimap.d:220
msgid "Cannot delete %s ."
msgstr "No se puede borrar %s ."

# He seguido la propuesta de Santiago Vila. A partir de ahora, y siempre
# que sea posible, el término "warning" se traducirá por "atención". En
# aquellos casos en que esto no es posible, lo he indicado
# explícitamente con un comentario indicando el motivo. - cll
#
#: spvw_multimap.d:237
msgid "** WARNING: ** Too few free disk space for %s .\n"
msgstr "** ATENCIÓN: ** Hay muy poco espacio libre en disco para %s .\n"

#: spvw_multimap.d:243
msgid "Please restart LISP with fewer memory (option -m).\n"
msgstr "Por favor, vuelva a ejecutar LISP con menos memoria (opción -m).\n"

#: spvw_multimap.d:252
msgid "Cannot make %s long enough."
msgstr "No es posible agrandar %s lo suficiente."

#: spvw_multimap.d:272
msgid "Cannot fill %s ."
msgstr "No se puede rellenar %s ."

#: spvw_multimap.d:291
msgid "Cannot close %s ."
msgstr "No se puede cerrar %s ."

#: spvw_multimap.d:329
msgid "Cannot close /dev/zero ."
msgstr "No se puede cerrar /dev/zero ."

#
# Muy buena tu sugerencia, Leo. Se queda tal y como tu propones - lsg
#
# ¿Apoyo o soporte? sv
#
# Bueno, si, tienes razón. De hecho ésta era una de esas traducciones
# "raras". El problema es que no estaba seguro de que el término
# "soporte" fuese aceptado. Pero si es así, pues perfecto - cll
#
#: spvw_multimap.d:368
msgid "Recompile your operating system with SYSV IPC support.\n"
msgstr "Recompile su sistema operativo con soporte para SYSV IPC.\n"

#
# "no se puede asignar un segmento privado en la memoria compartida" - lsg
#
#: spvw_multimap.d:384
msgid "Cannot allocate private shared memory segment."
msgstr "No se puede asignar un segmento privado en la memoria compartida."

#: spvw_multimap.d:409
msgid "Cannot map shared memory to address 0x%x."
msgstr "No se puede asignar la memoria compartida a la direccion 0x%x."

#: spvw_multimap.d:434
msgid "Cannot fill shared memory."
msgstr "No se puede rellenar la memoria compartida."

#: spvw_multimap.d:444
msgid "Could not fill shared memory."
msgstr "No se pudo rellenar la memoria compartida."

#
# En este y en otros tantos mensajes, he seguido tu consejo, Leo. He
# traducido `remove' por `desechar' en todos los sitios. - cll
#
#: spvw_multimap.d:462
msgid "Cannot remove shared memory segment."
msgstr "No se puede desechar el segmento de memoria compartida."

#: spvw_fault.d:434
msgid "mprotect() fails."
msgstr "mprotect() falló."

# "SIGSEGV no puede ser subsanado. Dirección del error =3D 0x%x.\n" - lsg
#
# Si, me gusta más tu traducción. Yo había puesto:
#
# "No se puede evitar SIGSEGV. Dirección de fallo = 0x%x.\n"
#
# Pero el caso es que un SIGSEGV no tiene porque evitarse puesto que es
# una señal que, para cuando sale este mensaje, ya se ha recibido. El
# problema ---realmente--- es que no fue posible "subsanar" la
# señal. Muy bien - cll
#
# De todas formas, prefiero ponerlo al revés ("No se puede subsanar" en
# vez de "... no puede ser subsanado"). Por otra parte, en vez de
# "error" prefiero "fallo" puesto que eso es exactamente de lo que se
# trata. No de un error por algo que alguien hizo mal, sino de un fallo
# del sistema, ... - cll
#
#: spvw_sigsegv.d:30
msgid ""
"\n"
"SIGSEGV cannot be cured. Fault address = 0x%x.\n"
msgstr ""
"\n"
"No se puede subsanar SIGSEGV. Dirección de fallo = 0x%x.\n"

#: spvw_sigsegv.d:69
msgid "Apollo 13 scenario: Stack overflow handling failed. On the next stack overflow we will crash!!!\n"
msgstr "Escenario Apollo 13: Falló la manipulación del desbordamiento de pila. ¡¡¡ Nos estrellaremos en el siguiente desbordamiento de pila !!!\n"

#: spvw_sigint.d:112 spvw_sigint.d:144
msgid "Ctrl-C: User break"
msgstr "Ctrl-C: Interrupción del usuario"

#: spvw_garcol.d:1964
msgid "munmap() fails."
msgstr "munmap() falló."

#: spvw_allocate.d:32
msgid "No more room for LISP objects"
msgstr "No queda espacio para almacenar más objetos LISP"

#
# "*** - no queda espacio para almacenar objetos LISP - REINICIALIZANDO" - lsg
#
# Yo sigo en mis trece, ... Debe ser un imperativo: REINICIE - cll
#
#: spvw_allocate.d:55
msgid ""
"\n"
"*** - No more room for LISP objects: RESET"
msgstr ""
"\n"
"*** - No queda espacio para almacenar más objetos LISP: REINICIE"

#: spvw_allocate.d:262 spvw_allocate.d:325 spvw_allocate.d:404
msgid "Trying to make room through a GC...\n"
msgstr "Intentando obtener más espacio a través de un GC ...\n"

#: spvw_memfile.d:208
msgid "disk full"
msgstr "el disco está lleno"

#
# "error del sistema operativo al cargar el fichero de inicialización `%s'\n" - lsg
#
# Así dicho parece que la culpa ha sido la carga del fichero de
# inicialización, cuando en realidad, el mensaje dice "durante". El
# error puede haber sido algo distinto de la carga. Por ejemplo, la
# carga puede ser correcta pero puede no cargarse en memoria (se me
# ocurre así de pronto), o cualquier otra cosa. Por eso prefiero la
# traducción:
#
# "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"
#
# - cll
#
#: spvw_memfile.d:711
msgid "operating system error during load of initialisation file `%s'\n"
msgstr "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"

#: spvw_memfile.d:1159
msgid "Cannot map the initialisation file into memory."
msgstr "No puedo escribir el fichero de inicialización en memoria."

#: spvw_memfile.d:1410
msgid "operating system error during load of initialisation file\n"
msgstr "error del sistema operativo durante la carga del fichero de inicialización\n"

#: spvw_memfile.d:1421
msgid "initialisation file was not created by this version of LISP\n"
msgstr "el fichero de inicialización no fue creado con esta versión de LISP\n"

#: spvw_memfile.d:1430
msgid "not enough memory for initialisation\n"
msgstr "no hay memoria suficiente para la inicialización\n"

# "~: ~ es una constante, no se puede asignar dinámicamente" - lsg
#
# ¡Bingo! - cll
#
#: eval.d:547
msgid "~: ~ is a constant, cannot be bound dynamically"
msgstr "~: ~ es una constante, no se puede asignar dinámicamente"

#: control.d:2357 eval.d:1434
msgid "Too many documentation strings in ~"
msgstr "Demasiadas cadenas de documentación en ~"

# Quito el guión, ya que en el mensaje siguiente lo tienes sin él. sv
# Otra posibilidad es: falta la lista lambda para ~. sv
#
# Es que de hecho, debe ir sin guión, ... evidentemente. cll
#
# Por otra parte, mejor pensado, me gusta la alternativa que das - cll
#
#: eval.d:1631
msgid "FUNCTION: lambda-list for ~ is missing"
msgstr "FUNCTION: falta la lista lambda de ~"

#
# "FUNCTION: la lista lambda de ~ debe ser una lista, no un(a) ~" - lsg
#
# Lo de "un(a)" no me mola, aunque sin esa palabra el mensaje queda más
# "telegráfico", me parece más apropiado para tratarse del "diálogo con
# un ordenador" :) - cll
#
#: eval.d:1643
msgid "FUNCTION: lambda-list for ~ should be a list, not ~"
msgstr "FUNCTION: la lista lambda de ~ debe ser una lista, no ~"

#: eval.d:1753
msgid "FUNCTION: illegal declaration ~"
msgstr "FUNCTION: declaración inválida ~"

# Duda: Nótese cómo la traducción dice `declararse SPECIAL'. Esto es
# así, porque en Common Lisp existe SPECIAL para declarar variables
# especiales. Por eso, si digo `declararse SPECIAL' estoy diciendo
# `declararse especial con SPECIAL', pero esto último me parece muy
# rebuscado, ¿o es lo correcto?
#
# La traducción es perfectamente fiel. Déjala así. sv
#
# Además, he quitado el "por ello". cll
#: eval.d:1767
msgid "FUNCTION: ~ is not a symbol, cannot be declared SPECIAL"
msgstr "FUNCTION: ~ no es un símbolo, no puede declararse SPECIAL"

#: eval.d:1845
msgid "FUNCTION: too long variable specification after &OPTIONAL: ~"
msgstr "FUNCTION: especificacion de variable demasiado larga despues de &OPTIONAL: ~"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#: eval.d:1884
msgid "FUNCTION: &REST var must be followed by &KEY or &AUX or end of list: ~"
msgstr "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX o del final de lista: ~"

#
# Igualmente: "FUNCTION: &REST debe ir seguido de una variable: ~" - lsg
#
# Pues si, es que cuando uno está mucho tiempo traduciendo del inglés,
# llega un momento en que empieza coger los hábitos de ese lenguaje y
# empieza a expresarse de una manera extraña, ... - cll
#
#: eval.d:1893
msgid "FUNCTION: &REST must be followed by a variable: ~"
msgstr "FUNCTION: &REST debe ir seguido de una variable: ~"

#: eval.d:1945
msgid "FUNCTION: ~ in ~ is not a keyword"
msgstr "FUNCTION: ~ en ~ no es una palabra clave"

#: eval.d:1996
msgid "FUNCTION: incorrect variable specification after &KEY: ~"
msgstr "FUNCTION: especificación de variable incorrecta después de &KEY: ~"

#
# Y de nuevo "FUNCTION: &ALLOW-OTHER-KEYS debe ir seguido de &AUX o del
# final de lista: ~" - lsg
#
# Pues si, :) - cll
#
#: eval.d:2006
msgid "FUNCTION: &ALLOW-OTHER-KEYS must be followed by &AUX or end of list: ~"
msgstr "FUNCTION: &ALLOW-OTHER-KEYS debe ir seguido por &AUX o el fin de lista: ~"

#: eval.d:2042
msgid "FUNCTION: too long variable specification after &AUX: ~"
msgstr "FUNCTION: especificacion de variable demasiado larga despues de &AUX: ~"

#: eval.d:2066
msgid "FUNCTION: badly placed lambda-list keyword ~: ~"
msgstr "La palabra clave ~ de la lista lambda está mal situada: ~"

# Sugerencia: may not -> no puede. sv
# Sugerencia: comerse el "y por ello". sv
#: eval.d:2074
msgid "FUNCTION: ~ is not a symbol, may not be used as a variable"
msgstr "FUNCTION: ~ no es un símbolo, no puede usarse como una variable"

# me comería el "y por ello", todo el mundo lo entenderá, y además no
# está en el original. sv
#
# No sólo eso, sino que además el mensaje queda demasiado largo. Será
# mucho más cómodo, para quien esté trabajando, ver mensajes cortos,
# ... sugerencia aceptada. cll
#
#: eval.d:2082
msgid "FUNCTION: ~ is a constant, may not be used as a variable"
msgstr "FUNCTION: ~ es una constante, no puede usarse como una variable"

#: eval.d:2092
msgid "FUNCTION: too many parameters in the lambda-list ~"
msgstr "FUNCTION: demasiados parámetros en la lista lambda ~"

#: eval.d:2102
msgid "FUNCTION: a dot in a lambda-list is allowed only for macros, not here: ~"
msgstr "FUNCTION: sólo en las macros se permite utilizar un punto en la lista lambda, no aquí: ~"

#: eval.d:2178
#, fuzzy
msgid "~: ~ is a special form, not a function"
msgstr "APPLY: ~ es una forma especial, no una función"

#: eval.d:2197 symbol.d:33
msgid "~: ~ is a macro, not a function"
msgstr "~: ~ es una macro, no una función"

#: eval.d:2216
msgid "~: the function ~ is undefined"
msgstr "~: la función ~ no está definida"

#: eval.d:2271 sequence.d:1139
msgid "~: ~ is not a function"
msgstr "~: ~ no es una función"

#: eval.d:2336
msgid "EVAL/APPLY: keyword arguments for ~ should occur pairwise"
msgstr "EVAL/APPLY: los argumentos clave de ~ deben aparecer por pares"

#
# 'Se han pasado demasiados argumentos a ~" - lsg
#
# Bueno, tu traducción es absolutamente válido. Tal vez, algo más
# informal que la mía, por aquello de "pasado" en vez de
# "entregado". Bueno, pues si te parece, esta vez lo dejo como lo tenía
# yo - cll
#
#: eval.d:2351 eval.d:2662
msgid "EVAL/APPLY: too many arguments given to ~"
msgstr "EVAL/APPLY: se han entregado demasiados argumentos a ~"

#: eval.d:2368
msgid "EVAL/APPLY: ~ is not a keyword"
msgstr "EVAL/APPLY: ~ no es una palabra clave"

#: eval.d:2395
msgid "EVAL/APPLY: keyword ~ is illegal for ~. The possible keywords are ~"
msgstr "EVAL/APPLY: el argumento clave ~ es inválido en ~. Los posibles argumentos clave son ~"

#
# "EVAL/APPLY: no se han pasado suficientes argumentos a ~" - lsg
#
# Hmmm, ... Si me gusta, es más "explicativo". Si, me gusta, si, si
# Lo único que te trastoco es lo de "pasado" por "entregado". Ya sabes,
# un toque de distinción :) - cll
#
#: eval.d:2583
msgid "EVAL/APPLY: too few arguments given to ~"
msgstr "EVAL/APPLY: no se han entregado suficientes argumentos a ~"

#
# "EVAL: la variable ~ no tiene asignado ningún valor" - lsg
#
# Bueno, he quitado lo de "asignado" porque parece de "perogrullo", pero
# lo demás se queda - cll
#
#: eval.d:3060
msgid "EVAL: variable ~ has no value"
msgstr "EVAL: la variable ~ no tiene ningún valor"

#: eval.d:3093
msgid "EVAL: illegal form ~"
msgstr "EVAL: forma ~ inválida"

#: control.d:105 eval.d:3170 eval.d:4180 eval.d:5086
msgid "~: ~ is not a function name"
msgstr "~: ~ no es el nombre de una función"

# "EVAL: no se han pasado suficientes argumentos a la forma especial ~:~" - lsg
#
# Bueno, pues te digo lo mismo que en el mensaje eval.d:2572, ... - cll
#
#: eval.d:3249
msgid "EVAL: too few parameters for special-form ~: ~"
msgstr "EVAL: no se han entregado suficientes argumentos a la forma especial ~: ~"

#
# "Se han pasado demasiados parámetros a la forma especial ~: ~" - lsg
#
# O sea, que quite lo de "para" y ponga "a". Pues vale, tienes toda la
# razón del mundo - cll
#
#: eval.d:3263
msgid "EVAL: too many parameters for special-form ~: ~"
msgstr "EVAL: se han entregado demasiados parámetros a la forma especial ~: ~"

#: eval.d:3276
msgid "EVAL: dotted parameter list for special form ~: ~"
msgstr "EVAL: la lista de parámetros para la forma especial ~ está punteada: ~"

#
# "EVAL: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Una vez más, te digo lo mismo que en el mensaje eval.d:2572 - cll
#
#: eval.d:3344
msgid "EVAL: too few arguments given to ~: ~"
msgstr "EVAL: no se han entregado suficientes argumentos a ~: ~"

#
# "Se han pasado demasiados argumentos a ~: ~" - lsg
#
# Me gusta más "entregado" que "pasado" - cll
#
#: eval.d:3359
msgid "EVAL: too many arguments given to ~: ~"
msgstr "EVAL: se han entregado demasiados argumentos a ~: ~"

#
# "EVAL: la lista de argumentos pasada a ~ es punteada: ~" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#: eval.d:3374
msgid "EVAL: argument list given to ~ is dotted: ~"
msgstr "EVAL: la lista de argumentos entregada a ~ está punteada: ~"

#: eval.d:4195
msgid "APPLY: argument list given to ~ is dotted"
msgstr "APPLY: la lista de argumentos entregada a ~ está punteada"

#
# "Se han pasado demasiados argumentos a ~" - lsg
#
# Una vez más, me gusta más "entregar" que "pasar" - cll
#
#: eval.d:4209
msgid "APPLY: too many arguments given to ~"
msgstr "APPLY: se han entregado demasiados argumentos a ~"

#
# "APPLY: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Pues eso, que me gusta más "entregar" - cll
#
#: eval.d:4223
msgid "APPLY: too few arguments given to ~"
msgstr "APPLY: se han entregado pocos argumentos a ~"

#
# "el símbolo ~ no tiene valor asignado" - lsg
#
# En algún otro sitio ha aparecido algo parecido a esto. Verás, como me
# parece evidente que si un símbolo no tiene valor, es que no tiene
# valor asignado, pues prefiero omitir lo de "asignado" y evitar que el
# usuario lea términos innecesarios - cll
#
#: eval.d:6601 eval.d:6619
msgid "symbol ~ has no value"
msgstr "el símbolo ~ no tiene valor"

#: eval.d:6636
msgid "assignment to constant symbol ~ is impossible"
msgstr "no pueden realizarse asignaciones sobre el símbolo constante ~"

#
# "~: se ha invocado ~ con demasiados argumentos" - lsg
#
# ¡¡¡ Traducción brillantísima !!! Te ha quedado perfecto. Lo que yo había puesto:
#
# "~: se han entregado demasiados argumentos a ~"
#
# queda como más "indio". Tu traducción me encanta - cll
#
#: control.d:2261 eval.d:7229
msgid "~: too many arguments given to ~"
msgstr "~: se ha invocado ~ con demasiados argumentos"

# Duda: tagbody es de muy difícil traducción.
#       Echando un ojo a la traducción en francés me he encontrado con que está
#       tal cual, ... De momento se queda así hasta que otros miembros del
#       equipo decidan cualquier otra cosa, ...
#
# No es que sepa lo que es, pero, si tag es etiqueta, tagbody podría ser
# "el cuerpo de la etiqueta" (¿tiene sentido esto?), con lo cual, una
# posibilidad sería (para simplificar) "el cuerpo de las etiquetas..." sv
#
# Otra de las propuestas a esta cuestión en la lista de correo
# es@li.org, ha sido: "el contenido de las etiquetas ~ ya ha sido
# abandonado". Esta traducción me gusta, ... cll
#
# ( Desafortunadamente, no recuerdo el nombre de la persona que lo
# sugirió, ... cll )
#
# "(~ ~): ya se ha salido del cuerpo de etiquetas ~" - lsg
#
# Debo rendirme a la evidencia, ... La propuesta de Leo, no solo para
# este término sino todos cuanto se refieren a la traducción de `tag' y
# `tagbody' es perfecta y, además, sigue los pasos de la de Santiago, de
# modo que "moción aceptada" :)
#
#: eval.d:7398 eval.d:7437
msgid "(~ ~): the tagbody of the tags ~ has already been left"
msgstr "(~ ~): ya se ha salido del cuerpo de etiquetas ~"

#: control.d:1969 eval.d:7499
msgid "~: there is no CATCHer for tag ~"
msgstr "~: No hay ningún capturador (CATCH) para la etiqueta de salto ~"

#: eval.d:7524
msgid "STACK corrupted"
msgstr "Pila (STACK) corrupta"

#: eval.d:7852
msgid "~: ~ is not a correct index into ~"
msgstr "~: ~ no es un índice correcto en ~"

#: eval.d:8452
msgid "undefined bytecode in ~ at byte ~"
msgstr "Código de octeto ~ indefinido en el octeto ~"

#: eval.d:8465
msgid "too many return values"
msgstr "Demasiados valores devueltos"

#: eval.d:8475
msgid "Corrupted STACK in ~ at byte ~"
msgstr "Pila corrupta en ~ en el byte ~"

#: control.d:58
msgid "~: function name ~ should be a symbol"
msgstr "~: el nombre de la función ~ debe ser un símbolo"

#: control.d:85
msgid "~: undefined function ~"
msgstr "~: la función ~ no está definida"

#: control.d:127
msgid "~: ~ has no dynamic value"
msgstr "~: ~ no tiene ningún valor dinámico"

#
# "~: ~ no tiene una definición global de función " - lsg
#
# Atención, atención ¿qué es global, la definición o la función?
#
# Yo he traducido:
#
# "~: ~ no tiene ninguna definición global de función"
#
# y la traducción francesa dice:
#
# "~ : ~ n'a pas de définition globale de fonction." - cll
#
#: control.d:168 symbol.d:22
msgid "~: ~ has no global function definition"
msgstr "~: ~ no tiene ninguna definición global de función"

#: control.d:243
msgid "~: the value of the constant ~ may not be altered"
msgstr "~: no puede alterarse el valor de la constante ~"

#: control.d:271
msgid "~ called with odd number of arguments: ~"
msgstr "~ invocado con un número impar de argumentos: ~"

#: control.d:284
msgid "dotted list given to ~ : ~"
msgstr "lista punteada entregada a ~: ~"

#: control.d:377
msgid "~: the value of the constant ~ must not be removed"
msgstr "~: no se debe desechar el valor de la constante ~"

#: control.d:402
msgid "~: the special form definition of ~ must not be removed"
msgstr "~: no se debe desechar la definición de la forma especial de ~"

#: control.d:475
msgid "~: doc-strings are not allowed here: ~"
msgstr "~: aquí no se permiten cadenas de documentación: ~"

#: control.d:545
msgid "~: ~ is not a symbol, but was declared SPECIAL"
msgstr "~: ~ no es un símbolo, pero ha sido declarado SPECIAL"

#: control.d:587 control.d:852
msgid "~: illegal variable specification ~"
msgstr "~: especificación inválida de variable ~"

#: control.d:625
#, fuzzy
msgid "~: symbol ~ is declared special and must not be declared a macro"
msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: control.d:635
msgid "~: symbol ~ must not be declared SPECIAL and a macro at the same time"
msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: control.d:648 control.d:868
msgid "~: ~ is a constant, cannot be bound"
msgstr "~: ~ es una constante, y por ello no puede ligarse"

#: control.d:670
msgid "~: too many variables and/or declarations"
msgstr "~: demasiadas variables y/o declaraciones"

#: control.d:937
msgid "~: ~ is not a function specification"
msgstr "~: ~ no es la especificación de una función"

#: control.d:1082
msgid "~: ~ is not a macro specification"
msgstr "~: ~ no es la especificación de una macro"

#: control.d:1093
msgid "~: macro name ~ should be a symbol"
msgstr "~: el nombre de la macro ~ debe ser un símbolo"

#: control.d:1199
msgid "~: clause ~ should be a list"
msgstr "~: la clausula ~ debe ser una lista"

#: control.d:1233
msgid "~: missing key list: ~"
msgstr "~: falta la lista de claves: ~"

#: control.d:1245
msgid "~: the ~ clause must be the last one"
msgstr "~: la clausula ~ debe ser la última"

#: control.d:1305
msgid "~: the block named ~ has already been left"
msgstr "~: el bloque de nombre ~ ya ha sido abandonado"

#: control.d:1343
msgid "~: no block named ~ is currently visible"
msgstr "~: no hay ningún bloque visible con el nombre ~"

#: control.d:1592
msgid "~: ~ is neither tag nor form"
msgstr "~: ~ no es ni una etiqueta de salto ni una forma"

#: control.d:1637
msgid "~: illegal tag ~"
msgstr "~: etiqueta de salto inválida ~"

#: control.d:1679
msgid "~: tagbody for tag ~ has already been left"
msgstr "~: ya se ha salido del cuerpo de etiquetas de ~"

#: control.d:1697
msgid "~: no tag named ~ is currently visible"
msgstr "~: no hay ninguna etiqueta de salto visible con el nombre ~"

#: control.d:1718
msgid "~: too many values"
msgstr "~: demasiados valores"

#: control.d:1760
msgid "~: too many arguments to ~"
msgstr "~: se han entregado demasiados argumentos a ~"

#: control.d:2008
msgid "Argument ~ is not a macroexpansion environment"
msgstr "El argumento ~ no es un entorno para la expansión de macros"

#: control.d:2061
msgid "declarations ~ are not allowed here"
msgstr "las declaraciones ~ no están permitidas aquí"

#: control.d:2085
msgid "~: ~ evaluated to the values ~, not of type ~"
msgstr "~: La forma ~ ha producido los valores ~, ninguno de los cuales es del tipo ~"

#: control.d:2103
msgid "~: bad declaration ~"
msgstr "~: declaración incorrecta ~"

#: control.d:2209
msgid "~: ~ may not be used as an environment"
msgstr "~: ~ no puede usarse como un entorno"

#: control.d:2347
msgid "no doc-strings allowed here: ~"
msgstr "no se permite la utilización de cadenas de documentación aquí: ~"

#: control.d:2418
msgid "keyword argument list ~ has an odd length"
msgstr "la lista de argumentos clave ~ tiene longitud impar"

#: control.d:2451
msgid "illegal keyword/value pair ~, ~ in argument list. The allowed keywords are ~"
msgstr "par argumento clave/valor inválido ~, ~ en la lista de argumentos. Los parámetros clave permitidos son ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#
#: pathname.d:779 pathname.d:829
msgid "~: host should be NIL or a string, not ~"
msgstr "~: el anfitrión debe ser, o bien NIL, o una cadena, pero no ~"

#
# Duda: he traducido hostname por "nombre del `host'". ¿Qué os parece?
#
#: pathname.d:799 pathname.d:848
msgid "~: illegal hostname ~"
msgstr "~: nombre de anfitrión inválido ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:873
msgid "~: host should be NIL, not ~"
msgstr "~: el anfitrión debe ser NIL, no ~"

#: pathname.d:990
msgid "~: argument should be a string, symbol, file stream or pathname, not ~"
msgstr "~: el argumento debe ser o bien una cadena, o un símbolo, o un flujo de fichero o un PATHNAME pero no ~"

#: pathname.d:1031
msgid "~: filename for ~ is unknown"
msgstr "~: el nombre de fichero de ~ es desconocido"

#: pathname.d:1549 pathname.d:1899
msgid "~: there is no environment variable ~"
msgstr "~: no hay ninguna variable de entorno ~"

#: pathname.d:1839
msgid "~: there is no user named ~"
msgstr "~: no hay ningún usuario con el nombre ~"

#: pathname.d:2228
msgid "~: syntax error in filename ~ at position ~"
msgstr "~: error de sintáxis en el nombre del fichero ~, en la posición ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:2244
msgid "~: hosts ~ and ~ of ~ should coincide"
msgstr "~: los anfitriones ~ y ~ de ~ deben coincidir"

#: pathname.d:2472
msgid "~: argument ~ is not a logical pathname, string, stream or symbol"
msgstr "~: el argumento ~ no es un PATHNAME \"lógica\", una cadena de caracteres, un flujo o un símbolo"

#: pathname.d:2530
msgid "~: endless loop while resolving ~"
msgstr "~: bucle infinito para ~"

#: pathname.d:2555
msgid "~: unknown logical host ~ in ~"
msgstr "~: anfitrión ~ desconocido en ~"

#: pathname.d:2570
msgid "~: No replacement rule for ~ is known."
msgstr "~: No se conoce ninguna regla de sustitución para ~."

#: pathname.d:2944
msgid "~: :VERSION-argument should be NIL or a positive fixnum or :WILD or :NEWEST, not ~"
msgstr "~: el argumento :VERSION debe ser NIL, un número positivo del tipo fixnum, :WILD o :NEWEST pero no ~"

#: pathname.d:2973
msgid "~: :VERSION-argument should be NIL or :WILD or :NEWEST, not ~"
msgstr "~: el argumento :VERSION debe ser o bien NIL, o :WILD o :NEWEST, pero no ~"

#: pathname.d:3986
msgid "~: illegal ~ argument ~"
msgstr "~: el argumento de ~ es inválido: ~"

# Duda: Wildcard por comodín, ..., está bien, ¿no?
#
#: pathname.d:4295
msgid "wildcards are not allowed here: ~"
msgstr "Aquí no están permitidos los comodines: ~"

#: pathname.d:4327
msgid "~: argument ~ should be ~, ~, ~, ~, ~, ~ or ~"
msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#: pathname.d:5336
msgid "~: replacement pieces ~ do not fit into ~"
msgstr "~: las piezas de intercambio ~ no caben en ~"

#: pathname.d:5405
msgid "~: ~ is not a specialization of ~"
msgstr "~: ~ no es una especialización de ~"

#: pathname.d:5457
msgid "(~ ~ ~ ~) is ambiguous: ~"
msgstr "(~ ~ ~ ~) es ambiguo: ~"

#: pathname.d:5485
msgid "nonexistent directory: ~"
msgstr "directorio inexistente: ~"

#: pathname.d:5503
msgid "~: File ~ already exists"
msgstr "~: El fichero ~ ya existe"

#: pathname.d:5846 pathname.d:6664
msgid "no directory ~ above ~"
msgstr "no existe el directorio ~ bajo ~"

#: pathname.d:5857
msgid "\"..\\\\\" after \"...\\\\\" is invalid: ~"
msgstr "\"..\\\\\" después de \"...\\\\\" es inválido: ~"

#: pathname.d:6045
msgid "Couldn't access current directory"
msgstr "No se pudo acceder al directorio actual"

#: pathname.d:6190
msgid "~: ~ names a file, not a directory"
msgstr "~: ~ es el nombre de un fichero, no de un directorio"

#: pathname.d:6239 pathname.d:6431 pathname.d:6781
msgid "~: ~ names a directory, not a file"
msgstr "~: ~ es el nombre de un directorio, no de un fichero"

# Casi lo mismo. Bueno, al menos aquí hay dos puntos. sv
#
# Tienes razón. Ahora que veo este mensaje me lío a poner dos puntos en
# los mensajes anteriores. cll
#
#: pathname.d:6286
msgid "UNIX error while GETWD: ~"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Si la tildecilla se sustituye por aquello que devolvió la orden GETWD,
# la frase resultante no tiene mucho sentido.
# Sugerencia: "La ejecución de GETWD en Unix devolvió ~" sv
#
# Hmmm, ..., podría ser, pero verás: en primer lugar, el texto que está
# asociado con la etiqueta "UNIX GETWD returned ~" es "UNIX error while
# GETWD" (fichero pathname.d, línea 6176); segundo, en CLisp se sigue la
# convención de colocar primero un mensaje y después, al final, aquello
# que originó el mensaje y, francamente, no quiero cambiar esta
# convención. Es decir, no quiero faltar al estilo original de los
# autores del programa. cll
#
# Por este motivo, creo que lo más conveniente es dejarlo como está. cll
#
#: pathname.d:6298
msgid "UNIX GETWD returned ~"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Lo mismo. sv
#
# Lo mismo también ;) cll
#
#: pathname.d:6386
msgid "UNIX REALPATH returned ~"
msgstr "Se produjo un error UNIX durante la ejecución de REALPATH: ~"

#: pathname.d:6594
msgid "~: If a device is specified, the directory must begin with ~: ~"
msgstr "~: Si se especifica un dispositivo, el directorio debe comenzar con ~: ~"

#: pathname.d:6988
msgid "no file name given: ~"
msgstr "no se ha entregado ningún nombre de fichero: ~"

#: pathname.d:7004
msgid "not a directory: ~"
msgstr "no es un directorio: ~"

#: pathname.d:7062
msgid "~: file ~ does not exist"
msgstr "~: el fichero ~ no existe"

#: pathname.d:7094
msgid "~: pathname with type but without name makes no sense: ~"
msgstr "~: un PATHNAME con tipo, pero sin nombre, no tiene ningún sentido: ~"

#: pathname.d:7321
msgid "cannot delete file ~ since there is file stream open to it"
msgstr "no se puede borrar el fichero ~ puesto que hay un flujo abierto sobre el"

#: pathname.d:7387
msgid "cannot rename file ~ since there is file stream open to it"
msgstr "no se puede renombrar el fichero ~ puesto que hay un flujo abierto sobre el"

#: pathname.d:7974
msgid "file ~ does not exist"
msgstr "el fichero ~ no existe"

#: pathname.d:7983
msgid "a file named ~ already exists"
msgstr "ya existe un fichero con el nombre ~"

#: pathname.d:8026
msgid "~: illegal :DIRECTION argument ~"
msgstr "~: argumento :DIRECTION inválido ~"

#: pathname.d:8106
msgid "~: illegal :ELEMENT-TYPE argument ~"
msgstr "~: argumento :ELEMENT-TYPE inválido ~"

#: pathname.d:8136
msgid "~: illegal :IF-EXISTS argument ~"
msgstr "~: argumento :IF-EXISTS inválido ~"

#: pathname.d:8153
msgid "~: illegal :IF-DOES-NOT-EXIST argument ~"
msgstr "~: argumento :IF-DOES-NOT-EXIST inválido ~"

#: pathname.d:8166
#, fuzzy
msgid "~: illegal :EXTERNAL-FORMAT argument ~"
msgstr "~: argumento :TEST inválido ~"

#: pathname.d:9560
msgid "root directory not allowed here: ~"
msgstr "el directorio raíz no está permitido aquí: ~"

# En la lista de "spanglish" pone:
#
# command                 orden, mandato (NO "comando")
#
# Asi que, muchas gracias Santiago por la indicación, ... - cll
#
#: pathname.d:10317 pathname.d:10363 pathname.d:10426
msgid "~: the command should be a string, not ~"
msgstr "~: la orden debe ser una cadena y no ~"

# Duda: En este mensaje, el primer "~" se sustituye por el nombre de una
# función y el segundo "~" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: stream.d:223
msgid "~ on ~ is illegal"
msgstr "~ no es posible sobre el flujo ~"

#: stream.d:401
msgid "~: the last character read from ~ was not ~"
msgstr "~: el último carácter leído de ~ no era ~"

# Duda: A continuación vienen muchos mensajes que empiezan por "~ from
# ~". Para ayudar en su trabajo a quienes estén revisando este trabajo
# (no me canso de darte las gracias, Santiago, ..., y a quienes se
# animen) aclaro que el primer "~" se sustituye por el nombre de una
# función cuya evaluación (o ejecución, pero esto no es correcto en
# Lisp, ... se prefiere el término evaluación porque se está a nivel de
# intérprete) produce el error; el segundo "~" se refiere al nombre del
# flujo desde el cual se leyó dicha función. Luego, a continuación,
# viene el mensaje de error propiamente dicho.
#
# Por ejemplo, la siguiente instrucción en CLisp:
#
# > (read)
#
# ..., si se teclea:
#
# #<...>
#
# ..., produce el siguiente error: (en español, ya traducido)
#
# *** - READ en #<TERMINAL-STREAM>: los objetos escritos de la manera
# #<...> no pueden volverse a leer
#
# ¿De acuerdo?
#
# A continuación reproduzco un par de mails donde se explica el
# mecanismo general de estos mensajes, a propósito de la pregunta que
# puse en la lista de correo de CLisp:
#
# Mi pregunta fue:
#
# > 21. There are a few messages which begin with "~ from ~". They are
# > very easy to translate but they use a lot of prepositions, and words
# > that could be translated in masculine or feminine. So, I need some
# > real examples of their use.
#
# Las respuestas fueron:
#
#
# ---------------------------------------------------------------------------
# Look in io.d:
#     { pushSTACK(*stream_); # Wert fu:r Slot STREAM von STREAM-ERROR
#       pushSTACK(ch); # Character
#       pushSTACK(*stream_); # Stream
#       pushSTACK(S(read));
#       //: DEUTSCH "~ von ~: Gelesenes Zeichen ist kein String-Char: ~"
#       //: ENGLISH "~ from ~: character read should be a string-char: ~"
#       //: FRANCAIS "~ de ~ : le caracte!re lu n'est pas de type STRING-CHAR."
# The first ~ is the function name, the second the stream that was being
# read from or written to and the third is the character that was read/written.
#
# So it says something like "READ from #<STREAM ...>: illegal character"
#
# 						(Joerg Hoehle)
#
# ---------------------------------------------------------------------------
# A general question here: I thought gettext was coming with an Emacs
# mode called "po-mode", which helps you in translating the messages.
# In particular, there are keystroke commands for showing the C/Lisp source
# surrounding the original reference to a message. From this context,
# you should at least be able to guess the meaning of the objects which
# are substituted for the ~. Note, however, that the first ~ corresponds
# the last pushSTACK command before the string, the second ~ to the
# second-to-last pushSTACK command etc.
#
# 						(Bruno Haible)
#
# ---------------------------------------------------------------------------
#
#: stream.d:413
msgid "~ from ~ without ~ before it"
msgstr "~ en ~ sin ~ antes de él"

#: stream.d:556
msgid "~: cannot output to ~"
msgstr "~: no se puede escribir en ~"

#: stream.d:575
msgid "~ is not a character, cannot be output onto ~"
msgstr "~ no es un carácter, no puede escribirse en ~"

#: stream.d:593
msgid "~ is not an integer, cannot be output onto ~"
msgstr "~ no es un entero, no puede escribirse en ~"

#: stream.d:610
msgid "integer ~ is out of range, cannot be output onto ~"
msgstr "el entero ~ está fuera del dominio, no puede imprimirse en ~"

#: stream.d:646
#, fuzzy
msgid "~: argument ~ should be an input stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: stream.d:667
#, fuzzy
msgid "~: argument ~ should be an output stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: stream.d:3227
msgid "character ~ contains bits, cannot be output onto ~"
msgstr "el carácter ~ contiene bits, que no pueden imprimirse en ~"

# Duda: Aunque RAW significa `crudo', y `modo crudo' es una expresión
# muy conocida en español, lo dejo como RAW (y en mayúsuculas), para que
# quede claro que me refiero a la palabra reservada RAW (igual que
# ocurre en la versión original)
#
#: stream.d:3895
msgid "RAW mode not supported on ~"
msgstr "Modo RAW no soportado en ~"

#: stream.d:4272
msgid "~: argument ~ should be a window stream"
msgstr "~: el argumento ~ debe ser un WINDOW-STREAM"

#: stream.d:5081
msgid "cannot output to standard output"
msgstr "no se puede escribir en la salida estándar"

#: stream.d:6331
msgid "environment has no TERM variable"
msgstr "no existe ninguna variable de entorno TERM"

#: stream.d:6340
msgid "terminal type ~ unknown to termcap"
msgstr "No existe ninguna entrada para el tipo de terminal ~ en termcap"

# Duda: Juan Jordana (de la lista de CLisp) propone usar la expresión:
#
# 	Terminal incompleta (o errónea): Terminal de impresora.
#
# 	y me gusta, salvo que prefiero decir a continuación algo del
# 	tipo "usando el modo de impresora" o algo así, ¿no os parece
# 	mejor?
#
#: stream.d:6364
msgid "insufficient terminal: hardcopy terminal"
msgstr "terminal insuficiente: usando el modo de impresora"

# Duda: ¿Pues qué voy a decir? La traducción siguiente es una auténtica
# traducción libre. De todos modos, tanto la versión francesa como la
# alemana (aunque no sé ni alemán ni francés) hacen ---por lo visto---,
# lo que yo: una traducción libre.
#
#: stream.d:6372
msgid "insufficient terminal: overstrikes, cannot clear output"
msgstr "teminal insuficiente: no se puede inicializar la salida"

#: stream.d:6380
msgid "insufficient terminal: cannot scroll"
msgstr "terminal insuficiente: no se puede desplazar la pantalla"

#: stream.d:6389
msgid "insufficient terminal: cannot clear screen"
msgstr "terminal insuficiente: no se puede borrar la pantalla"

#: stream.d:6397
msgid "insufficient terminal: cannot position cursor randomly"
msgstr "terminal insuficiente: no se puede situar el cursor aleatoriamente"

#: stream.d:6856
msgid "~: package SCREEN is not implemented"
msgstr "~: el paquete SCREEN no está implementado"

#: stream.d:7417
msgid "Closed ~ because disk is full."
msgstr "Se ha cerrado ~ porque el disco está lleno."

#: stream.d:7596
msgid "cannot position ~ beyond EOF"
msgstr "no es posible colocarse en ~ más allá de EOF"

# Duda: lo del fichero `regular' por `normal'. De hecho, yo juraría que
# en la asignatura de Sistemas Operativos, en mi Facultad, los
# llamábamos "ficheros normales". ¿Qué tal os suena?.
#
#: stream.d:8818
msgid "~: ~ is not a regular file."
msgstr "~: ~ no es un fichero normal."

# Duda: aqui he traducido de la version francesa (no se frances, pero
# por lo que parece que pone, ...)
#
#: stream.d:8985
msgid "file ~ is not an integer file"
msgstr "el fichero ~ no tiene el formato de un fichero de enteros"

#: stream.d:9410
msgid "~: argument should be a symbol, not ~"
msgstr "~: el argumento debe ser un símbolo, no ~"

#: stream.d:10159 stream.d:10630
msgid "~ is beyond the end because the string ~ has been adjusted"
msgstr "~ está más allá del final porque la cadena ~ ha sido ajustada"

#: stream.d:10251
msgid "~: ~ is not a string input stream"
msgstr "~: ~ no es un flujo de entrada de cadenas de caracteres"

#: charstrg.d:1982 stream.d:10355
#, fuzzy
msgid "~: ~ argument must be a subtype of ~, not ~"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: stream.d:10391
msgid "~: ~ is not a string output stream"
msgstr "~: ~ no es un flujo de salida de cadenas de caracteres"

# Duda: He traducido `fill pointer' por "puntero de relleno". En
# realidad, los `fill-pointer' son exactamente, eso:
#
# "The fill pointer constitutes the "active length" of the vector; all
# vector elements whose index is less than the fill pointer are active,
# and the others are inactive." (Guy L. Steele, Jr; Common Lisp, The
# Language - 2nd Edition; pag. 454).
#
#: stream.d:10432
msgid "~: argument ~ should be a string with fill pointer"
msgstr "~: El argumento ~ debe ser una cadena con un puntero de relleno"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:10733
msgid "~: ~ is not a buffered input stream"
msgstr "~: ~ no es un flujo de entrada con buffer"

# Duda: he dejado `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: stream.d:11774
msgid "host should be string, not ~"
msgstr "el anfitrión debe ser una cadena de caracteres y no ~"

# Duda: Pues otra vez como siempre, ..., he dejado `display' tal
# cual. Pienso que todo el mundo sabe lo que es un `display' ¿no?
#
# Por otra parte (como ya sucedió en un mensaje anterior), ..., `fixnum'
# por ser el nombre de un subtipo (o tipo, si se quiere) en Lisp, está
# sin traducir, ...
#
#: stream.d:11785
msgid "display should be a nonnegative fixnum, not ~"
msgstr "el `display' debe ser un entero del tipo FIXNUM >=0, y no ~"

#: stream.d:11860
msgid "~: stream must be a socket-stream, not ~"
msgstr "~: el flujo debe ser un `socket-stream' y no ~"

#: stream.d:11875
msgid "~: argument ~ should be a vector of type (ARRAY (UNSIGNED-BYTE 8) (*))"
msgstr "~: el argumento ~ debe ser un vector del tipo (ARRAY (UNSIGNED-BYTE 8) (*)) "

#: stream.d:11985
msgid "~: ~ is not a SOCKET-SERVER"
msgstr "~: ~ no es un SOCKET-SERVER"

#: stream.d:12160
msgid "~: argument ~ is not a SOCKET-STREAM"
msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#: stream.d:12407
msgid "~: stream must be a generic-stream, not ~"
msgstr "~: el flujo debe ser un `generic-stream', no ~"

#: stream.d:12586
msgid "The value of ~ is not a stream: ~"
msgstr "El valor de ~ no es un flujo: ~"

#: stream.d:12594
msgid "The value of ~ is not an appropriate stream: ~"
msgstr "El valor de ~ no es un flujo apropiado: ~"

#: stream.d:12610
msgid "The value of ~ was not a stream: ~. It has been changed to ~."
msgstr "El valor de ~ no era un flujo: ~. Ha sido cambiado por ~."

#: stream.d:12631
msgid "readline library: out of memory."
msgstr "biblioteca readline: la memoria ha sido agotada."

#: stream.d:13438 stream.d:13621 stream.d:13661
msgid "~: Ctrl-C: User break"
msgstr "~: Ctrl-C: Interrupción del usuario"

#: io.d:845 stream.d:13791
msgid "~: input stream ~ has reached its end"
msgstr "~: el flujo de entrada ~ ha alcanzado su final"

#: stream.d:13848
msgid "~: argument ~ is not an open file stream"
msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#: stream.d:13880
msgid "~: position argument should be ~ or ~ or a nonnegative fixnum, not ~"
msgstr "~: el argumento de posición debe ser ~, ~ o un número no negativo del tipo FIXNUM, pero no ~"

#: io.d:297
msgid "The value of ~ was not a readtable. It has been reset."
msgstr "El valor de ~ no es una tabla de lectura. Ha sido inicializado/a."

#: io.d:381
msgid "~: argument ~ is not a readtable"
msgstr "~: el argumento ~ no es una tabla de lectura"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
# Al final, por iniciativa de Leo, he cambiado `# macro carácter', que
# no me gustaba demasiado por `macro carácter secundario', que me parece
# mucho mejor. - cll
#
#: io.d:565
msgid "~: ~ is a dispatch macro character"
msgstr "~: ~ es un macro carácter secundario"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:634
msgid "~: ~ is not a dispatch macro character"
msgstr "~: ~ no es un macro carácter secundario"

#: io.d:665
msgid "~: digit $ not allowed as sub-char"
msgstr "~: el dígito $ no está permitido como un sub-carácter"

#: io.d:712
msgid "~: new value ~ should be ~, ~, ~ or ~."
msgstr "~: el nuevo valor ~ debe ser ~, ~, ~ o ~."

#: io.d:751
msgid ""
"The value of ~ should be an integer between 2 and 36, not ~.\n"
"It has been reset to 10."
msgstr ""
"El valor de ~ debe ser un entero entre 2 y 36, no ~.\n"
"Ha sido inicializado a 10."

#: io.d:806
#, fuzzy
msgid "~ from ~: character read should be a character: ~"
msgstr "~ en ~: el carácter leído debe ser un STRING-CHAR: ~"

#: io.d:864
msgid "~: input stream ~ ends within an object. Last opening parenthesis probably in line ~."
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto. El último paréntesis abierto es, probablemente, el de la línea ~."

#: io.d:874
msgid "~: input stream ~ ends within an object"
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto"

#: io.d:1164
msgid "~ from ~: illegal character ~"
msgstr "~ en ~: carácter inválido ~"

#
# Duda: Lo mismo de antes, he dejado `token' sin traducir
#
#: io.d:1180
msgid "~: input stream ~ ends within a token after single escape character"
msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape simple"

#
# Duda: A ver, ¿la palabra `token'?
#       Mientras no se os ocurra algo mejor, lo he dejado en inglés, ...
#
#: io.d:1230
msgid "~: input stream ~ ends within a token after multiple escape character"
msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape múltiple"

#: io.d:1751
msgid "~ from ~: ~ has no macro character definition"
msgstr "~ en ~: ~ no tiene ninguna definición de macro carácter"

#: io.d:1768
msgid "~ from ~: macro character definition for ~ may not return ~ values, only one value."
msgstr "~ en ~: la definición del macro carácter para ~ no puede devolver ~ valores, sólo puede ser uno."

#: io.d:1795
msgid "~: input stream ~ ends within read macro beginning to ~"
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba una macro de lectura en ~"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:1827
msgid "~ from ~: After ~ is ~ an undefined dispatch macro character"
msgstr "~ en ~: Después de ~ está ~, que no es un macro carácter secundario"

#: io.d:1844
msgid "~ from ~: dispatch macro character definition for ~ after ~ may not return ~ values, only one value."
msgstr "~ en ~: la definición del macro carácter secundario de ~ después de ~ sólo puede devolver un valor, no ~"

# Duda: He traducido `token' tal cual, ... Santiago, imagino que la
# palabra token se queda tal cual. Quiero decir, ¿es necesario lo de las
# comillas? - cll
#
#: io.d:1922
msgid "~ from ~: a token consisting only of dots cannot be meaningfully read in"
msgstr "~ en ~: no puede leerse correctamente un `token' que consiste únicamente en puntos"

# Duda: Todo el mundo sabe que `colon' es el signo de dos puntos
# `:'. Bueno, pues la traducción del siguiente mensaje podría ser algo
# del estilo: "demasiados signos de dos puntos en el token ...", sin
# embargo, me ha parecido mejor poner los dos puntos directamente, ...
#
#: io.d:2013
msgid "~ from ~: too many colons in token ~"
msgstr "~ en ~: demasiados `:' en el `token' ~"

#: io.d:2065
msgid "~ from ~: there is no package with name ~"
msgstr "~ en ~: no existe ningún paquete con el nombre ~"

#: io.d:2098
msgid "~ from ~: ~ has no external symbol with name ~"
msgstr "~ en ~: ~ no tiene ningún símbolo externo con el nombre ~"

#: io.d:2145
msgid "~ from ~: token \".\" not allowed here"
msgstr "~ en ~: el `token' \".\" no está permitido aquí"

#: io.d:2197 io.d:6105
msgid "~: the value of ~ has been arbitrarily altered"
msgstr "~: el valor de ~ ha sido arbitrariamente alterado"

#: io.d:2215
msgid "~: no entry for ~ from ~ in ~ = ~"
msgstr "~: no existe ninguna entrada para ~ de ~ en ~ = ~"

#: io.d:2416
msgid "~ from ~: illegal end of dotted list"
msgstr "~ en ~: fin de lista punteada inválido"

#: io.d:2490
msgid "~ from ~: an object cannot start with ~"
msgstr "~ en ~: un objeto no puede comenzar por ~"

#: io.d:2568
msgid "~: input stream ~ ends within a string"
msgstr "~: el flujo de entrada ~ termina con una cadena"

#: io.d:2632
msgid "~ from ~: no number allowed between # and $"
msgstr "~ en ~: no debe haber ningún número entre # y $"

#: io.d:2727
msgid "~: input stream ~ ends within a comment #$ ... $#"
msgstr "~: el flujo de entrada ~ termina dentro un comentario #$ ... $#"

#: io.d:2809
#, fuzzy
msgid "~ from ~: font number ~ for character is too large, should be = 0"
msgstr "~ en ~: el número ~ para la fuente de caracteres es demasiado grande, debe ser < ~"

# Duda: Vamos a ver, ... porque esto es muy curioso, ... En Common Lisp,
# los caracteres tienen tres atributos (Common Lisp, The Language, 2nd
# Edition - Guy L. Steel, página 374): código, bits y fuente. El
# atributo "bits" se refiere a otras señales que se pueden activar por
# la pulsación simultánea de varias teclas (o sea, el Control, Mays,
# etc.) Para identificar convenientemente las pulsaciones simultáneas de
# teclas con las que se conocen como teclas de control, existen
# "nombres" (he aquí el quiz de la cuestión, ...) para referirse a
# dichas combinaciones.
#
# Bueno, pues este es, entonces, el problema para traducir "character
# bit with name". La verdad, no me extraña que los indios hablasen como
# hablaban, ... esto no puede ser más críptico :)
#
# Yo he optado por "nombre para los bits de carácter", ... ¿qué os
# parece? - cll
#
#: io.d:2842
msgid "~ from ~: there is no character bit with name ~"
msgstr "~ en ~: no hay ningún nombre para los bits de carácter que sea ~"

#: io.d:2904
msgid "~ from ~: there is no character with name ~"
msgstr "~ en ~: no hay ningún carácter con el nombre ~"

#: io.d:2968
msgid "~ from ~: token ~ after #$ is not a rational number in base ~"
msgstr "~ en ~: el `token' ~ después de #$ no es un número racional en base ~"

#: io.d:3037
msgid "~ from ~: the number base must be given between # and R"
msgstr "~ en ~: el número de la base debe estar entre # y R"

#: io.d:3055
msgid "~ from ~: The base ~ given between # and R should lie between 2 and 36"
msgstr "~ en ~: La base ~ entre # y R debe estar entre 2 y 36"

#: io.d:3102
msgid "~ from ~: bad syntax for complex number: #C~"
msgstr "~ en ~: sintaxis incorrecta del número complejo: #C~"

#: io.d:3137
msgid "~ from ~: token expected after #:"
msgstr "~ en : ~: se esperaba un `token' después de #:"

#: io.d:3165
msgid "~ from ~: token ~ after #: should contain no colon"
msgstr "~ en ~: el `token' ~ después de #: no debe contener dos puntos"

#: io.d:3218
msgid "~ from ~: only zeroes and ones are allowed after #*"
msgstr "~ en ~: sólo se permiten ceros y unos después de #*"

#: io.d:3249
msgid "~ from ~: bit vector is longer than the explicitly given length ~"
msgstr "~ en ~: la longitud del vector de bits es mayor que la longitud explícitamente indicada ~"

#: io.d:3261
msgid "~ from ~: must specify element of bit vector of length ~"
msgstr "~ en ~: debe especificar un elemento para el vector de bits de longitud ~"

#: io.d:3338
msgid "~ from ~: vector is longer than the explicitly given length ~"
msgstr "~ en ~: el vector tiene una longitud mayor que la explícitamente indicada ~"

#: io.d:3350
msgid "~ from ~: must specify element of vector of length ~"
msgstr "~ en ~: debe especificar un elemento para el vector de longitud ~"

#: io.d:3433
msgid "~ from ~: bad syntax for array: #A~"
msgstr "~ en ~: sintaxis incorrecta en la matriz: #A~"

#: io.d:3499
msgid "~ from ~: ~ = ~ doesn't allow the evaluation of ~"
msgstr "~ en ~: ~ = ~ no permite la evaluación de ~"

#: io.d:3625
msgid "~ from ~: a number must be given between # and $"
msgstr "~ en ~: debe indicarse un número entre # y $"

#: io.d:3640
msgid "~ from ~: label #~? too large"
msgstr "~ en ~: la etiqueta #~? es demasiado grande"

# Duda: En Common Lisp existe lo que se denominan "Listas de asociación"
# (Common Lisp, The Language, 2nd Edition - Guy L. Steel, página 431) o,
# en inglés, "Association Lists" que abreviadamente se conocen como
# "alist" o "a-list". En realidad, aunque en español, mucha gente dice
# "alistas", esto no me parece correcto y me parece mucho más formal
# decir "listas de asociación".
#
# De hecho, el término "listas de asociación" será facílisimamente
# reconocible por el programador, mientras que "alista" exige estar un
# poquito más experimentado con el Lisp.
#
# Más aún, los traductores del libro "Lisp" (3ra edición) de Winston y
# Horn, utilizan la expresión "lista de asociación" en la presentación
# de la función ASSOC en la página 34, aunque luego también se refieran
# a ellas como "listas-a".
#
#: io.d:3665
msgid "~ from ~: the value of ~ has been altered arbitrarily, it is not an alist: ~"
msgstr "~ en ~: el valor de ~ ha sido modificado arbitrariamente, no es una lista de asociación: ~"

#: io.d:3685
msgid "~ from ~: label #~= may not be defined twice"
msgstr "~ en ~: la etiqueta #~= no puede definirse dos veces"

#: io.d:3714
msgid "~ from ~: #~= #~# is illegal"
msgstr "~ en ~: #~= #~# no está permitido"

#: io.d:3742
msgid "~ from ~: undefined label #~#"
msgstr "~ en ~: la etiqueta #~# no está definida"

#: io.d:3761
msgid "~ from ~: objects printed as #<...> cannot be read back in"
msgstr "~ en ~: los objetos escritos de la manera #<...> no pueden volverse a leer"

#: io.d:3781
msgid "~ from ~: objects printed as # in view of ~ cannot be read back in"
msgstr "~ en ~: los objetos escritos como # a causa de ~ no pueden volverse a leer"

# Duda: `feature' puede ser característica, propiedad, ... Yo me he
# decidido por la última. Sin embargo, ¿hay algún término oficial para
# esta palabra (muy común, por cierto)?
#
#: io.d:3864
msgid "~ from ~: illegal feature ~"
msgstr "~ en ~: propiedad inválida ~"

#: io.d:3998
msgid "~ from ~: #S must be followed by the type and the contents of the structure, not ~"
msgstr "~ en ~: #S debe estar seguido del tipo y contenidos de la estructura, no ~"

#: io.d:4013
msgid "~ from ~: the type of a structure should be a symbol, not ~"
msgstr "~ en ~: el tipo de una estructura debe ser un símbolo, no ~"

#: io.d:4030
msgid "~ from ~: bad HASH-TABLE"
msgstr "~ en ~: HASH-TABLE incorrecta"

#: io.d:4060
msgid "~ from ~: bad ~"
msgstr "~ en ~: ~ es incorrecto"

#: io.d:4092
msgid "~ from ~: no structure of type ~ has been defined"
msgstr "~ en ~: no se ha definido ninguna estructura del tipo ~"

#: io.d:4106
msgid "~ from ~: bad ~ for ~"
msgstr "~ en ~: ~ es incorrecto en ~"

#: io.d:4121
msgid "~ from ~: structures of type ~ cannot be read in, missing constructor function"
msgstr "~ en ~: las estructuras del tipo ~ no pueden leerse, no se conoce la función de construcción"

#: io.d:4143
msgid "~ from ~: a structure ~ may not contain a component \".\""
msgstr "~ en ~: una estructura ~ no debe contener un componente \".\""

#: io.d:4157
msgid "~ from ~: ~ is not a symbol, not a slot name of structure ~"
msgstr "~ en ~: ~ no es un símbolo, ni el nombre de una ranura ni una estructura ~"

#: io.d:4170
msgid "~ from ~: missing value of slot ~ in structure ~"
msgstr "~ en ~: falta el valor de la ranura ~ en la estructura ~"

#
# Duda: slots se queda tal cual, ...
#
# De acuerdo con la lista spanglish, `slot' se traducirá, en todo el
# CLisp, como "ranura".
#
#: io.d:4193
msgid "~ from ~: too many slots for structure ~"
msgstr "~ en ~: hay demasiadas ranuras en la estructura ~"

#
# "~ en ~: sintaxis inválida del vector de código de recinto tras #~Y" - lsg
#
# Hmmm, no me acaba de gustar, ... - cll
#
#: io.d:4232
msgid "~ from ~: illegal syntax of closure code vector after #~Y"
msgstr "~ en ~: sintaxis inválida del vector de código de la cerradura después de #~Y"

#: io.d:4273
msgid "~ from ~: object #Y~ has not the syntax of a compiled closure"
msgstr "~ en ~: el objeto #Y~ no tiene la sintaxis de una cerradura compilada"

#
# pathname NO es array!
# "~ en ~: sintaxis incorrecta en nombre de path: #A~" - lsg
#
# Si, es verdad, aquí se me había ido la mano, ...
#
# Además, PATHNAME no se traduce puesto que, o bien se refiere al tipo
# de datos PATHNAME o a la función PATHNAME (en este caso, al tipo de
# datos). Como ambos términos están definidos en el estándar de Common
# Lisp: Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr., pues
# no se traduce y se pone en mayúsculas para distinguirlo de otros
# términos. - cll
#
#: io.d:4410
msgid "~ from ~: bad syntax for pathname: #P~"
msgstr "~ en ~: la sintaxis del PATHNAME: #P~ es incorrecta"

#: io.d:4616 io.d:9321
msgid "~: ~ is not a character"
msgstr "~: ~ no es un carácter"

# Nota: El siguiente mensaje se debe a la función PEEK-CHAR (Common
# Lisp, The Language - 2nd Edition; Guy L. Steele, Jr; pag. 574), que
# realiza la lectura del siguiente objeto de un flujo de caracteres
# según el valor de su primer argumento opcional `peek-type' que solo
# puede valer, como reza el mensaje, NIL, T o un carácter.
#
#: io.d:4663
msgid "~: peek type should be NIL or T or a character, not ~"
msgstr "~: el tipo del PEEK solo puede ser NIL, T o un carácter, y no ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#: io.d:4815
msgid "~: ~ argument should be an integer between 2 and 36, not ~"
msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

# "~: la cadena ~ no tiene sintaxis de entero" - lsg
#
# He cambiado lo "de entero" por "de un número entero", que parece más
# inteligible - cll
#
#: io.d:4908
msgid "~: string ~ does not have integer syntax"
msgstr "~: la cadena ~ no tiene la sintaxis de un número entero"

#: io.d:5074
msgid "~: Despite of ~, ~ cannot be printed readably."
msgstr "~: A pesar de ~, ~ no puede imprimirse de manera legible."

#: io.d:5102
msgid ""
"~: the value ~ of ~ is neither ~ nor ~ nor ~.\n"
"It is reset to ~."
msgstr ""
"~: el valor ~ de ~ no es ~ ni ~ ni ~.\n"
"Ha sido inicializado a ~."

#: io.d:5464
msgid "~: must be a positive integer or NIL, not ~"
msgstr "~: debe ser un número positivo entero o NIL, pero no ~"

# "~: espacio insuficiente en la pila para realizar un análisis de circularidad" - lsg
#
# Vale - cll
#
#: io.d:6313
msgid "~: not enough stack space for carrying out circularity analysis"
msgstr "~: no hay espacio suficiente en la pila para realizar un análisis de circularidad"

#: io.d:7799
msgid "~: bad ~"
msgstr "~: incorrecto ~"

#: io.d:7916 record.d:240
msgid "~: ~ is not a structure"
msgstr "~: ~ no es una estructura"

#: io.d:8653
msgid "~: an unknown record type has been generated!"
msgstr "~: se ha generado un tipo de registro desconocido!"

#
# ¡¡Large no es largo, sino grande!! - lsg
#
# Tienes toda la razón, ya lo he cambiado en todos los mensajes - cll
#
#: array.d:224
msgid "index too large"
msgstr "índice demasiado grande"

# FIXME. Esto no cabe en 80 columnas. Comunicar al autor (?) sv
#
# "Una formación ha sido acortada mediante un ajuste al trasladar otra formación hacia ella"
# O bien, para que quepa en 80 columnas:
# "Una formación ha sido acortada al trasladar otra formación hacia ella" - lsg
#
# Yo había puesto:
#
# "Una matriz ha sido acortada debido a un ajuste cuando otra se ha desplazado "
# "hacia ella"
#
# Y ciertamente me gusta más tu traducción, salvo que en vez de
# formaciones hay que hablar de matrices, ¿no crees? - cll
#
#: array.d:235
msgid "An array has been shortened by adjusting it while another array was displaced to it."
msgstr "Una matriz ha sido acortada al trasladar otra matriz ella"

# "~: ~ no es una formación" - lsg
#
# Aunque en la lista de spanglish.txt pone "formación", en este caso
# creo que será mucho más conveniente poner "matriz" porque de hecho,
# los mensajes se refieren a matrices, ... - cll
#
#: array.d:337
msgid "~: ~ is not an array"
msgstr "~: ~ no es una matriz"

#: array.d:374 foreign.d:2234
msgid "~: got ~ subscripts, but ~ has rank ~"
msgstr "~: se encontraron ~ subíndices, pero ~ tiene rango ~"

#: array.d:392 foreign.d:2253
msgid "~: subscripts ~ for ~ are not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: los subíndices ~ de ~ no son del tipo '(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:420 foreign.d:2267
msgid "~: subscripts ~ for ~ are out of range"
msgstr "~: los subíndices ~ de ~ han excedido el rango"

#: array.d:483
msgid "~: index ~ for ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: el índice ~ de ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:506
msgid "~: index ~ for ~ is out of range"
msgstr "~: el índice ~ de ~ ha excedido el rango"

#: array.d:665
msgid "~: ~ does not fit into ~, bad type"
msgstr "~: ~ no cabe en ~, tipo incorrecto"

#: array.d:859
msgid "~: ~ is not an nonnegative integer less than the rank of ~"
msgstr "~: ~ no es un entero no negativo menor que el rango de ~"

#: array.d:1051
msgid "~: ~ is not an array of bits"
msgstr "~: ~ no es una matriz de bits"

#: array.d:1562
msgid "~: The arguments ~ and ~ should be arrays of bits with the same dimensions"
msgstr "~: Los argumentos ~ y ~ deben ser matrices de bits de la misma dimensión"

#: array.d:1575
msgid "~: The arguments ~, ~ and ~ should be arrays of bits with the same dimensions"
msgstr "~: Los argumentos ~, ~ y ~ deben ser matrices de bits de la misma dimensión"

#: array.d:1714
msgid "~: vector ~ has no fill pointer"
msgstr "~: el vector ~ no tiene ningún puntero de relleno"

#: array.d:1763
msgid "~: ~ has length zero"
msgstr "~: ~ tiene longitud nula"

#: array.d:1795
msgid "~ works only on adjustable arrays, not on ~"
msgstr "~ funciona sólo con matrices ajustables, no con ~"

#: array.d:1816
msgid "~: extension ~ should be a positive fixnum"
msgstr "~: la extensión ~ debe ser un número positivo del tipo FIXNUM"

#: array.d:1842
msgid "~: extending the vector by ~ elements makes it too long"
msgstr "~: ampliar el vector en ~ elementos, lo hace muy grande"

#: array.d:1935
msgid "~: cannot push ~ into array ~ (bad type)"
msgstr "~: no se puede introducir ~ en la matriz ~ (tipo incorrecto)"

#: array.d:2129
msgid "~: dimension ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: la dimensión ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:2173
msgid "~: dimensions ~ produce too large total-size"
msgstr "~: las dimensiones ~ producen un tamaño total demasiado grande"

#: array.d:2210
msgid "~: ambiguous, more than one initialisation specified"
msgstr "~: ambiguo, se ha especificado más de una inicialización"

#: array.d:2224
msgid "~: ~ must not be specified without ~"
msgstr "~: ~ no debe especificarse sin ~"

#: array.d:2342
msgid "~: the initial-element ~ is not of type ~"
msgstr "~: el INITIAL-ELEMENT ~ no es del tipo ~"

#: array.d:2429
msgid "~: ~ is of incorrect length"
msgstr "~: ~ no tiene la longitud correcta"

#: array.d:2462
msgid "~: ~-argument ~ is not an array"
msgstr "~: El ~ argumento ~ no es una matriz"

#: array.d:2492
msgid "~: ~-argument ~ does not have element type ~"
msgstr "~: El ~ argumento ~ no tiene como tipo de elemento ~"

#: array.d:2510
msgid "~: ~-argument ~ is not of type `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"
msgstr "~: El ~ argumento ~ no es del tipo `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"

#: array.d:2524
msgid "~: array-total-size + displaced-offset (= ~) exceeds total size ~ of ~-argument"
msgstr "~: array-total-size + displaced-offset (= ~) excede el tamaño total ~ del ~ argumento"

#: array.d:2551
msgid "~: fill-pointer ~ should be a nonnegative fixnum"
msgstr "~: El puntero de relleno ~ debe ser un número no negativo del tipo FIXNUM"

#: array.d:2564
msgid "~: fill-pointer argument ~ is larger than the length ~"
msgstr "~: El argumento FILL-POINTER ~ es mayor que la longitud ~"

#
# "~: el rango intentado ~ es demasiado grande" - lsg
#
# De acuerdo - cll
#
#: array.d:2637
msgid "~: attempted rank ~ is too large"
msgstr "~: el rango intentado ~ es demasiado grande"

#: array.d:2654
msgid "~: ~ may not be specified for an array of rank ~"
msgstr "~: ~ no debe especificarse para una matriz de rango ~"

#: array.d:2839
msgid "~: array ~ is not adjustable"
msgstr "~: la matriz ~ no es ajustable"

#: array.d:2864
msgid "~: rank ~ of array ~ cannot be altered: ~"
msgstr "~: no es posible cambiar el rango ~ de la matriz ~: ~"

#
# "~: los elementos de la formación ~ no son de tipo ~" - lsg
#
# Una excelente traducción. Lo único que hago es cambiar "formación" por
# "matriz" y listo - cll
#
#: array.d:2882
msgid "~: array ~ does not have element-type ~"
msgstr "~: los elementos de la matriz ~ no son del tipo ~"

#: array.d:2940
msgid "~: cannot displace array ~ to itself"
msgstr "~: no se puede desplazar la matriz ~ hacia ella misma"

#: array.d:2965
msgid "~: array ~ has no fill-pointer"
msgstr "~: la matriz ~ no tiene ningún puntero de relleno"

#: array.d:2984
msgid "~: the fill-pointer of array ~ is ~, greater than ~"
msgstr "~: el puntero de relleno de la matriz ~ es ~ que es mayor que ~"

# ... de la misma forma que uno no pone "START Índice" sv
#
# Si, si, ..., tienes toda la razón, ... cll
#
#: array.d:3117
msgid "Illegal START index ~ for ~"
msgstr "Índice START ~ inválido en ~"

#: array.d:3154
msgid "Illegal END index ~ for ~"
msgstr "Índice END ~ inválido en ~"

#: array.d:3170
msgid "~: invalid bit-vector length ~"
msgstr "~: la longitud de BIT-VECTOR ~ es inválida"

# Duda: hash lo he traducido por hash. ¿Alguna sugerencia? ¿Tablas de
# acceso rápido, o algo así?. Tened en cuenta que en Common Lisp, las
# tablas hash son una estructura bien definida que cuenta con sus
# propias instrucciones. A mí me gusta tal cual, ...
# Sugerencia: tabla de `hash'. sv
#
# No, no, no, no, ... :) `hash table' es `tabla hash'. Si se quiere,
# podríamos traducir la palabra `hash' pero si se deja es `tabla
# hash'. Todos los informáticos las llamamos así. Jamás he oído `Tabla
# *de* hash' cll
#
#: hashtabl.d:886
msgid "Hash table size ~ too large"
msgstr "La tabla hash ~ es demasiado grande"

#
# "error interno al redimensionar ~" - lsg
#
# Me gusta, salvo que el error ocurre "durante" - cll
#
#: hashtabl.d:934
msgid "internal error occured while resizing ~"
msgstr "error interno durante el redimensionamiento de ~"

#: hashtabl.d:1042
msgid "~: illegal :TEST argument ~"
msgstr "~: argumento :TEST inválido ~"

#: hashtabl.d:1060
msgid "~: :SIZE argument should be a fixnum >=0, not ~"
msgstr "~: el argumento :SIZE debe ser del tipo FIXNUM >= 0, no ~"

#: hashtabl.d:1083
msgid "~: :REHASH-SIZE argument should be a float > 1, not ~"
msgstr "~: el argumento :REHASH-SIZE debe ser del tipo FLOAT > 1, no ~"

#: hashtabl.d:1129
msgid "~: :REHASH-THRESHOLD argument should be a float between 0 and 1, not ~"
msgstr "~: el argumento :REHASH-THRESHOLD debe ser un número del tipo FLOAT entre 0 y 1, no ~"

#: hashtabl.d:1203
msgid "~: internal error while building ~"
msgstr "~: error interno durante la construcción de ~"

#: hashtabl.d:1247
msgid "~: argument ~ is not a hash-table"
msgstr "~: el argumento ~ no es una tabla hash"

#: list.d:499
msgid "~: ~ is not a nonnegative fixnum and therefore not a valid index"
msgstr "~: ~ no es un FIXNUM no negativo y por ello, no es un índice válido"

#: list.d:575
msgid "~: ~ is not a nonnegative integer and therefore not a valid argument"
msgstr "~: ~ no es un entero no negativo y por ello, no es un argumento válido"

#: list.d:695
msgid "~: ~ is not a nonnegative fixnum and therefore not a valid list length"
msgstr "~: ~ no es un FIXNUM no negativo y por ello, no es una longitud de lista válida"

#: list.d:969
msgid "~: ~ is not a pair"
msgstr "~: ~ no es un par"

#: list.d:1604
msgid "~: lists ~ and ~ are not of same length"
msgstr "~: las listas ~ y ~ no son de la misma longitud"

#: list.d:1799
msgid "~: index ~ too large for ~"
msgstr "~: el índice ~ es demasiado grande para ~"

#: list.d:1858
msgid "~: start index ~ too large for ~"
msgstr "~: el índice :START ~ es demasiado grande para ~"

#: list.d:1904
msgid "~: end index ~ too large for ~"
msgstr "~: el índice :END ~ es demasiado grande para ~"

#: package.d:341
msgid "symbol ~ cannot be deleted from symbol table"
msgstr "el símbolo ~ no puede ser borrado de la tabla de símbolos"

#: package.d:715
msgid "~ inconsistent: symbol ~ is a shadowing symbol but not present"
msgstr "inconsistencia en ~: el símbolo ~ es un símbolo que eclipsa a otro/s, sin embargo no está presente."

#: package.d:1180
msgid "UNEXPORT in ~ is illegal"
msgstr "UNEXPORT en ~ es inválido"

#
# "UNEXPORT sólo funciona con símbolos accesibles, no con ~ en ~" - lsg
#
# Ya, o sea, que cambie "sobre" por "con". Vale, me gusta mucho más tu
# mensaje que el mío - cll
#
#: package.d:1207
msgid "UNEXPORT works only on accessible symbols, not on ~ in ~"
msgstr "UNEXPORT sólo funciona sobre símbolos accesibles, no con ~ en ~"

#: package.d:1812
msgid "The value of *PACKAGE* was not a package. Old value ~. New value ~."
msgstr "El valor de *PACKAGE* no era un paquete. Valor anterior ~. Nuevo valor ~."

#: package.d:1834
msgid "Package ~ has been deleted."
msgstr "El paquete ~ ha sido borrado."

#: package.d:1847
msgid "There is no package with name ~"
msgstr "No hay ningún paquete con el nombre ~"

#: package.d:1859
msgid "~: argument should be a package or a package name, not ~"
msgstr "~: el argumento debe ser un paquete o el nombre de un paquete, no ~"

#: package.d:1873
msgid "~: argument should be a string, not ~"
msgstr "~: el argumento debe ser una cadena de caracteres, no ~"

#: package.d:1896
msgid "~: argument ~ should be a string or a symbol"
msgstr "~: el argumento ~ debe ser una cadena o un símbolo"

#: package.d:1997
msgid "~: there is already a package named ~"
msgstr "~: ya hay un paquete llamado ~"

#: package.d:2121 predtype.d:1157
msgid "~: argument ~ is not a symbol"
msgstr "~: el argumento ~ no es un símbolo"

#
# "~: el argumento debe ser un símbolo o una lista de símbolos, no ~" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: package.d:2173
msgid "~: argument should be a symbol or a list of symbols, not ~"
msgstr "~: el argumento debe ser un símbolo o una lista de símbolos, no ~"

#: package.d:2388
msgid "Cannot change the case sensitiveness of ~."
msgstr "No es posible cambiar las mayúsculas/minúsculas de ~."

#: record.d:33
msgid "~: ~ is not a valid index into ~"
msgstr "~: ~ no es un índice válido en ~"

#: record.d:47
msgid "~: ~ is not a record"
msgstr "~: ~ no es un registro"

#: record.d:110
msgid "~: length ~ is illegal, should be of type (INTEGER (0) (65536))"
msgstr "~: la longitud ~ es inválida, debe ser del tipo (INTEGER (0) (65536))"

#: record.d:150
msgid "~: ~ is not a structure of type ~"
msgstr "~: ~ no es una estructura del tipo ~"

#: record.d:200
#, fuzzy
msgid "~: Slot ~ of ~ has no value"
msgstr "~: Una ranura de ~ no tiene valor"

#: record.d:303
msgid "~: ~ is not a closure"
msgstr "~: ~ no es una cerradura"

#: record.d:319
msgid "~: This is not a compiled closure: ~"
msgstr "~: No se trata de una cerradura compilada: ~"

#: record.d:393
msgid "~ is not a valid code-vector byte"
msgstr "~ no es un byte CODE-VECTOR válido"

#: record.d:412
msgid "~: invalid code-vector ~"
msgstr "~: CODE-VECTOR inválido ~"

#: record.d:425
msgid "~: function ~ is too big: ~"
msgstr "~: la función ~ es demasiado grande: ~"

#: record.d:459
msgid "~: This is not a generic function: ~"
msgstr "~: Ésta no es una función genérica: ~"

#: record.d:588
msgid "~: ~ is not a class"
msgstr "~: ~ no es una clase"

#
# Yo pondría un guión entre argumento y clave. - lsg
#
# Hmm, o sea `argumento-clave'. No, no me gusta y de hecho, en el
# "Vocabulario bilingüe de términos técnicos" de "Lisp" (3ra edición) de
# Winston y Horn, los traductores al español ponen en la página 649:
#
# keyword arguments - argumentos clave
#
# sin guión por medio - cll
#
#: record.d:800
msgid ""
"~: illegal keyword/value pair ~, ~ in argument list.\n"
"The allowed keywords are ~"
msgstr ""
"~: par argumento clave/valor inválido ~, ~ en la lista de argumentos.\n"
"Los parámetros clave permitidos son ~"

#: record.d:837
msgid "SHARED-INITIALIZE: keyword argument list ~ has an odd length"
msgstr "SHARED-INITIALIZE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:953
msgid "REINITIALIZE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "REINITIALIZE-INSTANCE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:1052
msgid "INITIALIZE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "INITIALIZE-INSTANCE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:1179
msgid "MAKE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "MAKE-INSTANCE: la lista de argumentos clave ~S tiene longitud impar"

#: sequence.d:218
msgid "There are no sequences of type ~"
msgstr "No hay secuencias del tipo ~"

#: sequence.d:268
msgid "~ is not a sequence"
msgstr "~ no es una secuencia"

#: sequence.d:288
msgid "sequence type forces length ~, but result has length ~"
msgstr ""

#: sequence.d:307
msgid "~: ~ should be an integer >=0, not ~"
msgstr "~: ~ debe ser un entero >=0, no ~"

#: sequence.d:361 sequence.d:395
msgid "~: ~ = ~ should not be greater than ~ = ~"
msgstr "~: ~ = ~ no debe ser mayor que ~ = ~"

#: sequence.d:511
msgid "~: the index should be a fixnum >=0, not ~"
msgstr "~: el índice debe ser un número >=0 del tipo FIXNUM, no ~"

#: sequence.d:531
msgid "~ ~: the index should be a fixnum >=0, not ~"
msgstr "~ ~: el índice debe ser del tipo fixnum >=0, no ~"

#: sequence.d:673
msgid "~: ~ is not a sequence"
msgstr "~: ~ no es una secuencia"

#: sequence.d:779 sequence.d:1019
msgid "~: bad length ~"
msgstr "~: longitud incorrecta ~"

#: sequence.d:883
msgid "~: size should be an integer >=0, not ~"
msgstr "~: el tamaño debe ser un entero >=0, no ~"

#: sequence.d:894
msgid "~: :update must not be specified without :initial-element"
msgstr "~: no debe especificarse :update sin :initial-element"

#: sequence.d:1857
msgid "~: Must not specify both arguments to :TEST and :TEST-NOT"
msgstr "~: Los argumentos :TEST y :TEST-NOT no deben tener valor simultáneamente"

#: sequence.d:1989
msgid "~: sequence ~ is too long"
msgstr "~: la secuencia ~ es demasiado larga"

#: sequence.d:2454
msgid "too long sequence ~"
msgstr "secuencia demasiado larga ~"

#: charstrg.d:484
msgid "This is not a string: ~"
msgstr "Esto no es una cadena: ~"

#: charstrg.d:709
msgid "~: the radix must be an integer between 2 and 36, not ~"
msgstr "~: la base debe ser un entero entre 2 y 36, no ~"

#: charstrg.d:999
msgid "~: the code argument should be an integer, not ~"
msgstr "~: el argumento del código debe ser un entero y no ~"

# "~: no se puede convertir ~ al tipo character"
#
# No sé si traducir la palabra character, puesto que es una palabra
# clave en Lisp. - lsg
#
# Yo ya había traducido este mensaje como:
#
# "~: ~ no puede convertirse a un carácter"
#
# Pero el tuyo me gusta mucho más, salvo que `character', puesto que es
# un término definido en el estándar Common Lisp, debe ir en mayúsculas
# - cll
#
#: charstrg.d:1022
msgid "~: cannot coerce ~ to a character"
msgstr "~: no se puede convertir ~ al tipo CHARACTER"

#: charstrg.d:1061
msgid "~: the weight argument should be an integer, not ~"
msgstr "~: el argumento de ponderación debe ser un entero, y no ~"

#: charstrg.d:1102
msgid "~: argument should be an integer, not ~"
msgstr "~: el argumento debe ser un entero, no ~"

#: charstrg.d:1129
msgid "~: index should be an integer, not ~"
msgstr "~: el índice debe ser un entero, no ~"

#: charstrg.d:1138
msgid "~: ~-index should be an integer, not ~"
msgstr "~: el índice ~ debe ser un entero, no ~"

#: charstrg.d:1156
msgid "~: index should be NIL or an integer, not ~"
msgstr "~: el índice debe ser NIL o un entero, no ~"

#: charstrg.d:1165
msgid "~: ~-index should be NIL or an integer, not ~"
msgstr "~: el índice ~ debe ser NIL o un entero, no ~"

#: charstrg.d:1183
msgid "~: index should not be negative: ~"
msgstr "~: el índice no debe ser negativo: ~"

#: charstrg.d:1192
msgid "~: ~-index should not be negative: ~"
msgstr "~: el índice ~ no debe ser negativo: ~"

#: charstrg.d:1216
msgid "~: index ~ should not be greater than the length of the string"
msgstr "~: el índice ~ no debe ser mayor que la longitud de la cadena"

#: charstrg.d:1225
msgid "~: ~-index ~ should not be greater than the length of the string"
msgstr "~: el índice ~ = ~ no debe ser mayor que la longitud de la cadena"

#: charstrg.d:1249
msgid "~: index ~ should be less than the length of the string"
msgstr "~: el índice ~ debe ser menor que la longitud de la cadena"

#: charstrg.d:1258
msgid "~: ~-index ~ should be less than the length of the string"
msgstr "~: el índice ~ = ~ debe ser menor que la longitud de la cadena"

#: charstrg.d:1351
#, fuzzy
msgid "~: argument should be a character, not ~"
msgstr "~: el argumento debe ser un entero, no ~"

#: charstrg.d:1425 charstrg.d:1499 charstrg.d:2244
msgid "~: :start-index ~ must not be greater than :end-index ~"
msgstr "~: El índice :start ~ no debe ser mayor que el índice :end ~"

#: charstrg.d:1455
#, fuzzy
msgid "~: argument ~ should be a string, a symbol or a character"
msgstr "~: el argumento ~ debe ser del tipo string o string-char, o un símbolo"

#: charstrg.d:1563
msgid "~: :start1-index ~ must not be greater than :end1-index ~"
msgstr "~: El índice start1 ~ no debe ser mayor que el índice :end1 ~"

#: charstrg.d:1589
msgid "~: :start2-index ~ must not be greater than :end2-index ~"
msgstr "~: El índice :start2 ~ no debe ser mayor que el índice :end2 ~"

#: charstrg.d:1963
msgid "~: the string length ~ should be nonnegative fixnum"
msgstr ""
"~: la longitud de la cadena de caracteres ~ debe ser un número no negativo\n"
"del tipo FIXNUM"

#: charstrg.d:1999
#, fuzzy
msgid "~: :initial-element ~ should be of type character"
msgstr "~: El :INITIAL-ELEMENT ~ debe ser del tipo STRING-CHAR"

#
# Duda: esta traducción ha sido muy difícil, y está basada en la
# traducción francesa que dice: "~: Mauvais mode de saut d'environnement
# ~."
#
#: debug.d:686
msgid "~: bad frame climbing mode ~"
msgstr "~: modo de salto de marco incorrecto"

#: debug.d:708
msgid "~: ~ is not a stack pointer"
msgstr "~: ~ no es un puntero de pila"

#: debug.d:889
msgid "~: ~ is not a pointer to an EVAL/APPLY frame"
msgstr "~: ~ no es un puntero a un marco de tipo EVAL/APPLY"

#: debug.d:1143
msgid "~: environment is not an alist"
msgstr "~: el entorno no es una a-lista"

#: debug.d:1239
msgid "~: unknown frame type"
msgstr "~: tipo de marco desconocido"

#: error.d:42 user1.lsp:369
msgid "Unprintable error message"
msgstr "Mensaje de error no imprimible"

#: error.d:578
msgid "~: User break"
msgstr "~: Interrupción del usuario"

#: error.d:630
msgid "~: ~ is not a list"
msgstr "~: ~ no es una lista"

#: error.d:648
msgid "~: A true list must not end with ~"
msgstr "~: Una auténtica lista no debe finalizar con ~"

#: error.d:668
msgid "~: ~ is not a symbol"
msgstr "~: ~ no es un símbolo"

#: error.d:700
msgid "~: ~ is not a simple-vector"
msgstr "~: ~ no es un SIMPLE-VECTOR"

#: error.d:718
msgid "~: ~ is not a vector"
msgstr "~: ~ no es un vector"

#: error.d:736
msgid "~: argument ~ should be a nonnegative fixnum"
msgstr "~: el argumento ~ debe ser un número no negativo del tipo fixnum"

#: error.d:754
msgid "~: argument ~ is not a character"
msgstr "~: el argumento ~ no es un carácter"

#: error.d:771
msgid "~: argument ~ is not a string"
msgstr "~: el argumento ~ no es un string"

#: error.d:788
msgid "~: argument ~ is not a simple string"
msgstr "~: el argumento ~ no es una cadena simple"

#: error.d:806
msgid "~: argument ~ should be a stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: error.d:826
msgid "~: argument ~ should be a stream of type ~"
msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#: error.d:844
msgid ""
"~: argument ~ is not a function.\n"
"To get a function in the current environment, write (FUNCTION ...).\n"
"To get a function in the global environment, write (COERCE '... 'FUNCTION)."
msgstr ""

#: error.d:864 error.d:882
msgid "~: ~ is not an 8-bit number"
msgstr "~: ~ no es un número de 8 bits"

#: error.d:900 error.d:918
msgid "~: ~ is not a 16-bit number"
msgstr "~: ~ no es un número de 16 bits"

#: error.d:936 error.d:954
msgid "~: ~ is not an 32-bit number"
msgstr "~: ~ no es un número de 32 bits"

#: error.d:972 error.d:990
msgid "~: ~ is not an 64-bit number"
msgstr "~: ~ no es un número de 64 bits"

#: error.d:1012
msgid "~: ~ is not an `unsigned int' number"
msgstr "~: ~ no es un número del tipo `unsigned int'"

#: error.d:1034
msgid "~: ~ is not an `int' number"
msgstr "~: ~ no es un número del tipo `int'"

#: error.d:1056
msgid "~: ~ is not a `unsigned long' number"
msgstr "~: ~ no es un número del tipo `unsigned long'"

#: error.d:1078
msgid "~: ~ is not a `long' number"
msgstr "~: ~ no es un número del tipo `long'"

#: error.d:1096
msgid "~: ~ is not a single-float"
msgstr "~: ~ no es un SINGLE-FLOAT"

#: error.d:1114
msgid "~: ~ is not a double-float"
msgstr "~: ~ no es un DOUBLE-FLOAT"

# Sugerencia: "Error del Sistema Operativo Amiga " sv
#
# ¡Ajá! me parece muchísimo mejor que lo que había puesto, ...
#
#: erramiga.d:10
msgid "Amiga OS error "
msgstr "Error del Sistema Operativo Amiga "

#: erramiga.d:43
msgid "not enough memory available"
msgstr "no hay suficiente memoria disponible"

#: erramiga.d:48
msgid "process table full"
msgstr "tabla de procesos llena"

#: erramiga.d:60
msgid "bad template"
msgstr "plantilla incorrecta"

#: erramiga.d:64
msgid "bad number"
msgstr "número incorrecto"

#: erramiga.d:68
msgid "required argument missing"
msgstr "argumentos obligatorios ausentes"

#: erramiga.d:72
msgid "value after keyword missing"
msgstr "falta el valor después de la palabra clave"

#: erramiga.d:76
msgid "wrong number of arguments"
msgstr "~: número incorrecto de argumentos"

# Duda: Uuufff! Por favor, que alguien le eche un ojo a esto, ...
#
# Bueno, he encontrado un mensaje parecido a este en el glibc donde pone
# "desemparejados". Me suena bien. cll
#
#: erramiga.d:80
msgid "unmatched quotes"
msgstr "comillas desemparejadas"

#: erramiga.d:84
msgid "argument line invalid or too long"
msgstr "línea de argumentos inválida o demasiado larga"

#: erramiga.d:88
msgid "file is not executable"
msgstr "el fichero no es un ejecutable"

#: erramiga.d:92
msgid "invalid resident library"
msgstr "librería residente inválida"

#: erramiga.d:103
msgid "object is in use"
msgstr "el objeto está siendo usado"

#: erramiga.d:107
msgid "object already exists"
msgstr "el objeto ya existe"

#: erramiga.d:111
msgid "directory not found"
msgstr "directorio no encontrado"

#: erramiga.d:115
msgid "object not found"
msgstr "objeto no encontrado"

#: erramiga.d:119
msgid "invalid window description"
msgstr "descripción de ventana inválida"

#: erramiga.d:123
msgid "object too large"
msgstr "el objeto es demasiado grande"

#: erramiga.d:128
msgid "packet request type unknown"
msgstr "tipo de paquete de petición desconocido"

#: erramiga.d:132
msgid "object name invalid"
msgstr "nombre de objeto inválido"

#: erramiga.d:136
msgid "invalid object lock"
msgstr "bloqueo de objeto inválido"

#: erramiga.d:140
msgid "object is not of required type"
msgstr "el objeto no es del tipo requerido"

#: erramiga.d:144
msgid "disk not validated"
msgstr "disco no validado"

#: erramiga.d:148
msgid "disk is write-protected"
msgstr "el disco es de solo lectura"

#: erramiga.d:152
msgid "rename across devices attempted"
msgstr "se intentó un renombramiento entre unidades"

#: erramiga.d:156
msgid "directory not empty"
msgstr "directorio no vacío"

#: erramiga.d:160
msgid "too many levels"
msgstr "demasiados niveles"

#: erramiga.d:164
msgid "device (or volume) is not mounted"
msgstr "el dispositivo (o volumen) no está montado"

#: erramiga.d:168
msgid "seek failure"
msgstr "error durante un acceso directo (seek)"

#: erramiga.d:172
msgid "comment is too long"
msgstr "el comentario es demasiado largo"

#: erramiga.d:176
msgid "disk is full"
msgstr "el disco está lleno"

#: erramiga.d:180
msgid "object is protected from deletion"
msgstr "el objeto está protegido contra el borrado"

#: erramiga.d:184
msgid "file is write protected"
msgstr "el archivo está protegido contra escritura"

#: erramiga.d:188
msgid "file is read protected"
msgstr "el fichero está protegido contra escritura"

#: erramiga.d:192
msgid "not a valid DOS disk"
msgstr "no es un disquete DOS válido"

#: erramiga.d:196
msgid "no disk in drive"
msgstr "no hay ningún disquete en la unidad"

#: erramiga.d:205
msgid "no more entries in directory"
msgstr "no hay más entradas en el directorio"

#: erramiga.d:209
msgid "object is soft link"
msgstr "el objeto es un enlace blando"

#: erramiga.d:213
msgid "object is linked"
msgstr "el objeto está enlazado"

#: erramiga.d:217
msgid "bad loadfile hunk"
msgstr "trozo incorrecto del fichero de carga"

#: erramiga.d:221
msgid "function not implemented"
msgstr "función no implementada"

#: erramiga.d:228
msgid "record not locked"
msgstr "registro no bloqueado"

#: erramiga.d:232
msgid "record lock collision"
msgstr "colisión de bloqueo de registro"

#: erramiga.d:236
msgid "record lock timeout"
msgstr "tiempo de espera excedido del bloqueo del registro"

#: erramiga.d:240
msgid "record unlock error"
msgstr "error de desbloqueo de registro"

#: erramiga.d:249
msgid "buffer overflow"
msgstr "desbordamiento del buffer"

#: erramiga.d:253
msgid "break"
msgstr "interrupción"

#: erramiga.d:257
msgid "file not executable"
msgstr "fichero no ejecutable"

# Duda: ¿Ok por `vale'? Hmmm, no sé, no sé, ...
# Depende del caso, ¿qué te parece "correcto"? sv
#
# No, no me gusta demasiado, ..., me parece que es demasiado en plan
# "computadora". Prefiero "vale" antes que "correcto". cll
#
#: erramiga.d:267
msgid "Ok, No error"
msgstr "Vale, sin errores"

# Sugerencia: Error de DJDOS. sv
#: errdjgpp.d:10
msgid "DJDOS error "
msgstr "Error de DJDOS "

#: errdjgpp.d:43 errunix.d:966
msgid "Function not implemented"
msgstr "Función no implementada"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
# "No existe ese archivo o directorio" - lsg
#
# Pues si, me gusta más la traducción de Leo, que la de Enrique, salvo
# que, tal y como tu mismo apuntas, Leo, se debe decir "fichero" y no
# "archivo" - cll
#
#: errdjgpp.d:47 errunix.d:58
msgid "No such file or directory"
msgstr "No existe ese fichero o directorio"

#: errdjgpp.d:51 errunix.d:238
msgid "Not a directory"
msgstr "No es un directorio"

#: errdjgpp.d:55 errunix.d:278
msgid "Too many open files"
msgstr "Demasiados ficheros abiertos"

#: errdjgpp.d:59 errunix.d:168
msgid "Permission denied"
msgstr "Permiso denegado"

#: errdjgpp.d:63 errunix.d:128
msgid "Bad file number"
msgstr "Número de fichero incorrecto"

#: errdjgpp.d:67
msgid "Memory control blocks destroyed"
msgstr "Bloques de control de memoria destruídos"

#: errdjgpp.d:71 errunix.d:158
msgid "Not enough memory"
msgstr "No hay memoria suficiente"

#: errdjgpp.d:75
msgid "Invalid memory address"
msgstr "Dirección de memoria inválida"

#: errdjgpp.d:79
msgid "Invalid environment"
msgstr "Entorno inválido"

#: errdjgpp.d:84
msgid "Invalid access code"
msgstr "Código de acceso inválido"

#: errdjgpp.d:89 errunix.d:228
msgid "No such device"
msgstr "No existe tal dispositivo"

#: errdjgpp.d:93
msgid "Attempt to remove the current directory"
msgstr "Intento de borrar el directorio actual"

#: errdjgpp.d:97
msgid "Can't move to other than the same device"
msgstr "No se puede cambiar de dispositivo"

#: errdjgpp.d:101
msgid "No more files"
msgstr "No más ficheros"

# ¿Por qué no inválido? La palabra existe.
# Un día os tengo que enviar un trozo de "1984" de Orwell,
# que habla de "neolengua", el único idioma del mundo que tiene
# cada vez menos palabras, en vez de más... sv
#
# ¡¡¡Por supuestísimo!!! Tienes toda la razón del mundo. De hecho, si
# echas un ojo al resto de los mensajes verás que yo siempre he
# traducido "invalid" por "inválido" salvo en tres ocasiones: en dos
# preferí la expresión "no es correcto" y en la otra lo dejé como "no es
# válido" en vez de "no válido" que, además, suena horrible.
#
# A propósito del trozo de "1984", venga, ya estoy esperando :) - cll
#
#: errdjgpp.d:105 errunix.d:258
msgid "Invalid argument"
msgstr "Argumento inválido"

#: errdjgpp.d:109 errunix.d:108
msgid "Arg list too long"
msgstr "Lista de argumentos demasiado larga"

#: errdjgpp.d:113 errunix.d:118
msgid "Exec format error"
msgstr "Formato de programa no ejecutable"

#: errdjgpp.d:117 errunix.d:218
msgid "Cross-device link"
msgstr "Enlace cruzado entre dispositivos"

#: errdjgpp.d:123 errunix.d:369
msgid "Argument out of domain"
msgstr "Argumento fuera del dominio"

#
# "El resultado es demasiado grande" - lsg
#
# Si, ya he cambiado `largo' por `grande' en todos los mensajes. Un
# fallo realmente infantil :( - cll
#
#: errdjgpp.d:127 errunix.d:379
msgid "Result too large"
msgstr "El resultado es demasiado grande"

#: errdjgpp.d:131 errunix.d:208
msgid "File exists"
msgstr "El fichero ya existe"

#: errunix.d:48
msgid "Operation not permitted"
msgstr "Operación no permitida"

#: errunix.d:68
msgid "No such process"
msgstr "No existe tal proceso"

#: errunix.d:78
msgid "Interrupted system call"
msgstr "Llamada al sistema interrumpida"

# Sugerencia: E/S. sv
#
# Vaya, tu sugerencia es tan informática que me impresiona que se me
# haya escapado. cll
#
#: errunix.d:88
msgid "I/O error"
msgstr "Error de E/S"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:98
msgid "No such device or address"
msgstr "Dispositivo no configurado"

# Sugerencia: No hay ningún proceso hijo. sv
#
# Bueno, Enrique tradujo este mensaje como "Ningún proceso hijo" en libc
# asi que, si te parece bien, lo pondré como él puesto que lo suyo es
# una traducción ya aceptada y que además, resulta de mezclar lo que yo
# he puesto y de tu sugerencia. cll
#
#: errunix.d:138
msgid "No child processes"
msgstr "Ningún proceso hijo"

#: errunix.d:148
msgid "No more processes"
msgstr "No hay más procesos"

#: errunix.d:178
msgid "Bad address"
msgstr "Dirección incorrecta"

# Pongo esto un poco más en español.
# Antes decía "Dispositivo de bloque requerido".
# Por cierto, en otros sitios hemos puesto "dispositivo de bloques".
# ¿cómo es? sv
#: errunix.d:188
msgid "Block device required"
msgstr "Se requiere un dispositivo de bloque"

#: errunix.d:198
msgid "Device busy"
msgstr "Dispositivo ocupado"

#: errunix.d:248
msgid "Is a directory"
msgstr "Es un directorio"

#: errunix.d:268
msgid "File table overflow"
msgstr "Desbordamiento de la tabla de ficheros"

#: errunix.d:288
msgid "Inappropriate ioctl for device"
msgstr "El dispositivo no acepta la llamada `ioctl'"

#: errunix.d:298
msgid "Text file busy"
msgstr "Fichero de texto en uso"

#: errunix.d:308
msgid "File too large"
msgstr "Fichero demasiado grande"

#: errunix.d:318
msgid "No space left on device"
msgstr "No queda espacio en el dispositivo"

#: errunix.d:328
msgid "Illegal seek"
msgstr "Desplazamiento inválido"

#: errunix.d:338
msgid "Read-only file system"
msgstr "Sistema de ficheros de sólo lectura"

#: errunix.d:348
msgid "Too many links"
msgstr "Demasiados enlaces"

# Duda: pipe, todo el mundo sabe lo que es un pipe. Más aún, todo el mundo
#       conoce el mensaje `broken pipe'. Para no guiar a confusiones considero
#       que, excepcionalmente, se debe añadir la palabra pipe entre paréntesis,
#       con la intención de recordar al usuario lo que se quiere decir con
#       Tubería, ...
#
# Si en los cursillos de Unix se enseñara a los niños que esto | 
# es una tubería, no tendríamos que andar haciendo estas tonterías.
# Voto por eliminarlas de una vez por todas.
# "Tubería rota". sv
#
# Precisamente en estos días se discute esto mismo en la lista es@li.org
# (todavía no he enviado mi mensaje con mi opinión, pero lo haré,
# ...). La verdad es que creo que tienes razón. Sin ser exagerados y
# "eliminar de una vez por todas", creo que, en este caso, hay que
# arriesgarse y tirar p'alante, ¿no? ¡¡pues eso!! ¡¡¡"Tuberías rotas" al
# poder!!! - cll
#
#: errunix.d:358
msgid "Broken pipe"
msgstr "Tubería rota"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:390
msgid "Operation would block"
msgstr "La operación se bloquearía"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:400
msgid "Operation now in progress"
msgstr "Operación en curso"

# Already sería "ya". aún sería still.
# Sugerencia: La operación ya se está realizando. sv
#
# Más aún, echando un ojo a la traducción de Enrique Melero en el glibc,
# me he encontrado con el mismo mensaje y el dice: "La operación ya se
# está llevando a cabo". Me gusta bastante. cll
#
#: errunix.d:410
msgid "Operation already in progress"
msgstr "La operación ya se está llevando a cabo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:421
msgid "Too many levels of symbolic links"
msgstr "Demasiados niveles de enlaces simbólicos"

#: errunix.d:431
msgid "File name too long"
msgstr "Nombre de fichero demasiado largo"

#: errunix.d:441
msgid "Directory not empty"
msgstr "El directorio no está vacío"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:452
msgid "Stale NFS file handle"
msgstr "Fichero NFS bloqueado"

# Duda: Aquí he seguido el consejo de Enrique Melero.
#
# En la versión 1.5 he decidido cambiar el término `camino' por
# `trayectoria', tal y como recomiendan los traductores del libro Lisp,
# (3ra edición) de Winston y Horn en el "Vocabulario bilingüe de
# términos técnicos", en la página 650.
#
#: errunix.d:462
msgid "Too many levels of remote in path"
msgstr "Demasiados niveles de profundidad en la trayectoria"

#: errunix.d:473
msgid "Socket operation on non-socket"
msgstr "Operación de `sockets' sobre un \"no-socket\""

#: errunix.d:483
msgid "Destination address required"
msgstr "Se necesita la dirección del destino"

#: errunix.d:493
msgid "Message too long"
msgstr "Mensaje demasiado largo"

#: errunix.d:503
msgid "Protocol wrong type for socket"
msgstr "Tipo de protocolo incorrecto para el `socket'"

#: errunix.d:513
msgid "Option not supported by protocol"
msgstr "Opción no soportada por el protocolo"

#: errunix.d:523
msgid "Protocol not supported"
msgstr "Protocolo no soportado"

#: errunix.d:533
msgid "Socket type not supported"
msgstr "Tipo de `socket' no soportado"

# Pongo `socket' en vez de socket. sv
#: errunix.d:543
msgid "Operation not supported on socket"
msgstr "Acción no permitida en un `socket'"

#: errunix.d:553
msgid "Protocol family not supported"
msgstr "Familia de protocolos no soportada"

#: errunix.d:563
msgid "Address family not supported by protocol family"
msgstr "Familia de direcciones no soportada por el protocolo"

#: errunix.d:573
msgid "Address already in use"
msgstr "Dirección en uso"

# Sugerencia: No se puede asignar. sv
#
# ¡Vale!, "No puede asignarse ..." es demasiado, ..., ¿impersonal? cll
#: errunix.d:583
msgid "Can't assign requested address"
msgstr "No se puede asignar la dirección requerida"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#: errunix.d:593
msgid "Network is down"
msgstr "La red no está operativa"

#: errunix.d:603
msgid "Network is unreachable"
msgstr "No es posible conectarse con la red"

#: errunix.d:613
msgid "Network dropped connection on reset"
msgstr "Se ha perdido la conexión con la red debido a una reinicialización"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#: errunix.d:623
msgid "Software caused connection abort"
msgstr "El software ha provocado la interrupción de la conexión"

#: errunix.d:633
msgid "Connection reset by peer"
msgstr "Conexión reinicializada por el otro extremo"

#
# Duda: ¿Y buffer? ¿Como traduzco buffer?
#
# Yo he visto a menudo 'memoria tampón', que es el término usado por los
# franceses. - lsg
#
# Tienes toda la razón, ... Sin embargo, en este caso, la traducción
# francesa es:
#
# "Pas d'espace disponible pour un buffer"
#
# Además, como en spanglish.txt pone:
#
# "buffer - memoria intermedia, tampón, buffer"
#
# pues he utilizado `buffer' tal cual, ... - cll
#
#: errunix.d:643
msgid "No buffer space available"
msgstr "No queda espacio en el buffer"

# Lo de socket, si te parece. sv
#
# Te digo lo mismo que te dije antes. Cuando hay finalizado con la
# traducción me pondré a cambiar todas estas cosas con macros. cll
#
#: errunix.d:653
msgid "Socket is already connected"
msgstr "El `socket' ya está conectado"

#: errunix.d:663
msgid "Socket is not connected"
msgstr "El `socket' no está conectado"

# Añado comitas a `socket'. Es una especie de convenio que seguimos
# cuando no nos queda más remedio que poner la palabra inglesa.
# Así al menos reconocemos que es una palabra extraña. sv
#: errunix.d:673
msgid "Can't send after socket shutdown"
msgstr "No se puede enviar después de la ruptura del `socket'"

# Duda: ¿ Se excedió el tiempo para la conexión ?
#: errunix.d:691
msgid "Connection timed out"
msgstr "Se excedió el tiempo para la conexión"

#: errunix.d:701
msgid "Connection refused"
msgstr "Conexión rechazada"

# Estas dos darán que hablar, pero otro día las discutiremos... sv
#
# Al decir tú eso, he leído la traducción de este término en libc
# (traducido por Enrique Melero) y, madre mía, me he quedado
# "flipao". Aquello fue una discusión encarnizada, ...
#
# Para mas inri, yo no estoy de acuerdo con ninguno de los dos :) Verás,
# un host puede estar "caído" (que así es como se suele decir aunque es,
# evidentemente, incorrecto) y por ello no tiene por qué no estar
# operativo (en libc lo habeis traducido como "el `host' no está
# operativo"). De hecho, puede estar operando pero, por algún problema
# de la red o de tu propia transmisión, resultar inalcanzable, ... En
# fin, por este motivo prefiero "El `host' no está disponible"
#
# Por otra parte, no estoy muy de acuerdo con Enrique, ..., a mí lo de
# poner host no me gusta. Ciertamente, un `host' no tiene por qué ser un
# servidor, necesariamente, pero es el caso más común. En cualquier
# caso, todo el mundo comprende perfectamente que el `host' es un
# servidor. cll
#
#: errunix.d:717
msgid "Host is down"
msgstr "El servidor no está disponible"

# Aquí, pues idem de idem, ... :) cll
#
#: errunix.d:727
msgid "Host is unreachable"
msgstr "No se puede conectar con el servidor"

#: errunix.d:744
msgid "Too many processes"
msgstr "Demasiados procesos"

#: errunix.d:754
msgid "Too many users"
msgstr "Demasiados usuarios"

#: errunix.d:764
msgid "Disk quota exceeded"
msgstr "Cuota de disco excedida"

#: errunix.d:775
msgid "Not a stream device"
msgstr "No es un dispositivo de flujo"

#: errunix.d:785
msgid "Timer expired"
msgstr "El temporizador expiró"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:795
msgid "Out of stream resources"
msgstr "Alcanzado el límite de recursos de `streams'"

#: errunix.d:805
msgid "No message of desired type"
msgstr "No hay mensajes del tipo deseado"

#: errunix.d:815
msgid "Not a data message"
msgstr "No es un mensaje de datos"

#: errunix.d:826
msgid "Identifier removed"
msgstr "Identificador desechado"

# Duda: Eso del `inter-bloqueo' ¿estará bien?
#
#: errunix.d:837
msgid "Resource deadlock would occur"
msgstr "Podría ocurrir un interbloqueo entre recursos"

# Duda: Aunque Bruno Haible me ha asegurado que la etiqueta
# sys_errlist[ENOLCK] del glibc.po en español contiene la traduccion que
# yo debiera usar, me he decidido por las indicaciones de Santiago Vila
# en su respuesta a mi mail y he puesto, simplemente: "No quedan
# registros de bloqueo disponibles"
#
#: errunix.d:847
msgid "No record locks available"
msgstr "No quedan registros de bloqueo disponibles"

#: errunix.d:858
msgid "Machine is not on the network"
msgstr "La máquina no está en la red"

#: errunix.d:868 errunix.d:878
msgid "Object is remote"
msgstr "El objeto es remoto"

#: errunix.d:888
msgid "Link has been severed"
msgstr "El enlace ha sido destruído"

#: errunix.d:898
msgid "Advertise error"
msgstr "Error de anuncio"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:908
msgid "Srmount error"
msgstr "Error de `srmount'"

#: errunix.d:918
msgid "Communication error on send"
msgstr "Error de comunicaciones en el envío"

#: errunix.d:928
msgid "Protocol error"
msgstr "Error de protocolo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:938
msgid "Multihop attempted"
msgstr "Se ha intentado un multihop"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:955
msgid "Remote address changed"
msgstr "La dirección remota ha cambiado"

#: errunix.d:977
msgid "Not supported under MS-DOS"
msgstr "No soportado en MS-DOS"

#: errunix.d:999
msgid "UNIX error "
msgstr "Error de Unix "

# Cambio librería por el término oficial. sv
#
# Uuuffffff, ..., aquí sí que podríamos discutir hasta la muerte. Pero
# bueno, se queda como tú lo has puesto. cll
#
#: errunix.d:1005
msgid "UNIX library error "
msgstr "Error de biblioteca Unix "

#: errwin32.d:3864
msgid "Win32 error "
msgstr "Error de Win32 "

#: errwin32.d:3920
msgid "Winsock error "
msgstr "Error de `winsock'"

#: misc.d:40
msgid "This file was produced by another lisp version, must be recompiled."
msgstr "Este fichero fue producido por otra versión de lisp. Debe recompilarse."

#: misc.d:295
msgid "~: type of attribute ~ is unsupported"
msgstr "~: el tipo de atributo ~ no está soportado"

#: predtype.d:935 predtype.d:1107
msgid "~: unidentifiable type!!!"
msgstr "~: ¡¡¡tipo irreconocible!!!"

#: predtype.d:1117
msgid "~: type ~ does not correspond to a class"
msgstr "~: el tipo ~ no se corresponde con una clase"

#: predtype.d:1169
msgid "~: ~ does not name a class"
msgstr "~: ~ no es el nombre de una clase"

#: predtype.d:1449
msgid "~: bad type specification ~"
msgstr "~: especificación de tipo incorrecta ~"

#: predtype.d:1460
msgid "~: ~ cannot be coerced to type ~"
msgstr "~: ~ no puede convertirse al tipo ~"

#: symbol.d:52
msgid "~: the property list of ~ has an odd length"
msgstr "~: la lista de propiedades de ~ tiene longitud impar"

#: symbol.d:105
msgid "SETF SYMBOL-FUNCTION: ~ is not a function"
msgstr "SETF SYMBOL-FUNCTION: ~ no es una función"

#: symbol.d:130
msgid "~: ~ is not a system function"
msgstr "~: ~ no es una función del sistema"

#: symbol.d:183 symbol.d:223
msgid "~: the property list ~ has an odd length"
msgstr "~: la lista de propiedades ~ tiene longitud impar"

#: intlog.d:526 symbol.d:395
msgid "~: index ~ is negative"
msgstr "~: el índice ~ es negativo"

#: symbol.d:410
msgid "~: invalid argument ~"
msgstr "~: el argumento ~ es inválido"

#: symbol.d:426
msgid "The value of *GENSYM-COUNTER* was not a nonnegative integer. Old value ~. New value ~."
msgstr "El valor de *GENSYM-COUNTER* no era un entero no negativo. Valor anterior ~. Nuevo valor ~."

#: lisparit.d:334
msgid "argument to ~ should be a number: ~"
msgstr "el argumento de ~ debe ser un número: ~"

#: lisparit.d:352
msgid "argument to ~ should be a real number: ~"
msgstr "el argumento de ~ debe ser un número real: ~"

#: lisparit.d:370
msgid "argument to ~ should be a floating point number: ~"
msgstr "el argumento de ~ debe ser un número en coma flotante: ~"

#: lisparit.d:388
msgid "argument to ~ should be a rational number: ~"
msgstr "el argumento de ~ debe ser un número racional: ~"

#: lisparit.d:406
msgid "argument to ~ should be an integer: ~"
msgstr "el argumento de ~ debe ser un entero: ~"

#: lisparit.d:424
msgid "~: argument should be a positive fixnum, not ~"
msgstr "~: el argumento debe ser un número positivo del tipo FIXNUM, no ~"

#: lisparit.d:1668
msgid "~: argument should be a random-state, not ~"
msgstr "~: el argumento debe ser un estado aleatorio, no ~"

#: lisparit.d:1686
msgid "~: the value of ~ should be a random-state, not ~"
msgstr "~: el valor de ~ debe ser un RANDOM-STATE, no ~"

#: lisparit.d:1708
msgid "~: argument should be positive and an integer or float, not ~"
msgstr "~: el argumento debe ser un número positivo del tipo INTEGER o FLOAT, no ~"

#: lisparit.d:1791
msgid "~ : argument should be a fixnum >=0, not ~"
msgstr "~ : El argumento debe ser del tipo FIXNUM >=0 y no ~"

#: aridecl.d:356
msgid "stack overflow during bignum arithmetic"
msgstr "desbordamiento de la pila durante la realización de operaciones aritméticas con números grandes"

#: aridecl.d:421
msgid "division by zero"
msgstr "división entre cero"

#: aridecl.d:433
msgid "floating point overflow"
msgstr "desbordamiento de coma flotante"

# Duda: Lo del desbordamiento inferior de coma flotante ha sido
# traducción super libre mía ;) Este mensaje ocurre cuando el resultado
# (expresado en coma flotante) ocurre mucho más cerca del cero de lo que
# permite la representación de números en coma flotante. Por ejemplo:
# 2.3e-30 * 2.3e-30 sería 5.29e-60 que excedió el límite inferior.
#
#: aridecl.d:445
msgid "floating point underflow"
msgstr "desbordamiento inferior de coma flotante"

#: intelem.d:205 intelem.d:293
msgid "not a 32-bit integer: ~"
msgstr "no es un entero de 32 bits: ~"

#: intelem.d:380 intelem.d:518
msgid "not a 64-bit integer: ~"
msgstr "no es un entero de 64 bits: ~"

#: intelem.d:1420
msgid "bignum overflow"
msgstr "desbordamiento de números grandes"

#: intlog.d:406
msgid "~: ~ is not a valid boolean operation"
msgstr "~: ~ no es una operación lógica válida"

#: intlog.d:651
msgid "~: too large shift amount ~"
msgstr "~: el tamaño del desplazamiento es muy grande ~"

# Duda: En Lisp existe un tipo predeterminado: `fixnum'. Por ese motivo,
# dejo sin traducir este término.
#
#: intbyte.d:15
msgid "The arguments to BYTE must be fixnums >=0: ~, ~"
msgstr "Los argumentos de BYTE deben ser números enteros del tipo FIXNUM >=0: ~, ~"

#: intbyte.d:42
msgid "~ is not a BYTE specifier"
msgstr "~ no es un especificador de BYTE"

#: intmal.d:7
msgid "overflow during multiplication of large numbers"
msgstr "desbordamiento durante la multiplicación de números grandes"

#: intdiv.d:347
msgid "quotient ~ / ~ is not an integer"
msgstr "el cociente ~ / ~ no es un entero"

#: intsqrt.d:390
msgid "~ applied to negative number ~"
msgstr "~ aplicado al número negativo ~"

# Duda: long-float es un tipo, así que lo dejo como `LONG-FLOAT'. Aunque
# Bruno Haible y Marcus Daniels lo han puesto como `long float' se
# refieren al tipo `long-float'
# Sugerencia: `long float'. sv
#
# No estoy de acuerdo con la sugerencia. No se trata de que `long' sea
# un adjetivo de `float', sino que en CLisp existe el tipo "long-float"
# (Common Lisp The Language, 2nd edition, Guy L. Steele, pag. 39). De
# hecho, en muchos otros sitios de CLisp se pone "long-float". Más aún,
# la traducción francesa de este mensaje es: "LONG-FLOAT trop long".
#
# De hecho, en mi opinion, Bruno Haible y Marcus Daniels se equivocaron
# aquí y debían haber puesto el guión. cll
#
#: lfloat.d:7
msgid "long float too long"
msgstr "LONG-FLOAT demasiado largo"

#: flo_konv.d:448
msgid "floating point NaN occurred"
msgstr "aparición de NaN en coma flotante"

# Duda: ¿alguien sabe qué es eso de ARexx?
#
#: rexx.d:33
msgid "Communication with ARexx isn't possible."
msgstr "La comunicación con ARexx no es posible."

#
# Siguiendo con las recomendaciones de Santiago y de "spanglish",
# `command' será `orden' - cll
#
#: rexx.d:114
msgid "~ must be a string for commands or a vector of strings for a function"
msgstr "~ debe ser una cadena para órdenes o un vector de cadenas para una función"

#: rexx.d:126
msgid "~: an ARexx function must have 0 to ~ arguments: ~"
msgstr "~: Una función ARexx debe tener entre 0 y ~ argumentos: ~"

#: rexx.d:143
msgid "~: must be a string for ARexx: ~"
msgstr "~: debe ser una cadena para ARexx: ~"

#: rexx.d:167
msgid "Only NIL, T and strings are accepted for ~ : ~"
msgstr "~ sólo acepta NIL, T o cadenas de caracteres: ~"

#: rexx.d:459
msgid "~: Not a Fixnum: ~"
msgstr "~: No es del tipo Fixnum: ~"

#: rexx.d:474
msgid "~: Not an incoming Rexx message: ~"
msgstr "~: No es un nuevo mensaje Rexx: ~"

#: affi.d:82
msgid "~: Unsupported call mechanism: ~"
msgstr "~: mecanismo de llamado no soportado: ~"

#: affi.d:95
msgid "~: Bad function prototype: ~"
msgstr "~: Prototipo de función incorrecto: ~"

#: affi.d:108
msgid "~: Wrong number of arguments for prototype ~"
msgstr "~: número incorrecto de argumentos para el prototipo ~"

#: affi.d:124
msgid "~: Bad argument for prototype ~: ~"
msgstr "~: Argumento incorrecto para el prototipo ~: ~"

#: affi.d:137
msgid "~: Bad argument: ~"
msgstr "~: El argumento ~ es inválido"

#: affi.d:159
msgid "~: ~ is not a valid address"
msgstr "~: ~ no es una dirección válida"

#: graph.d:445 graph.d:2762
msgid "graphics not initialized"
msgstr "los gráficos no han sido inicializados"

#: graph.d:3692
msgid "~: cannot switch to graphics mode"
msgstr "~: no es posible conmutar al modo gráfico"

#: foreign.d:26
msgid "~ comes from a previous Lisp session and is invalid"
msgstr "~ proviene de una sesion anterior de Lisp y es inválido"

#: foreign.d:98
msgid "A foreign variable ~ already exists"
msgstr "La variable extranjera ~ ya existe"

# Duda: he traducido `foreign' por `ajeno/a'.
#
# Lo he pensado mejor y `extranjera' me gusta mucho más, ..., ¿qué os
# parece? cll
#
#: foreign.d:140
msgid "A foreign function ~ already exists"
msgstr "La función extranjera ~ ya existe"

#: foreign.d:184
msgid "illegal foreign data type ~"
msgstr "el tipo de datos extranjero ~ es inválido"

#: foreign.d:200
msgid "~ cannot be converted to the foreign type ~"
msgstr "~ no puede ser compartido al tipo extranjero ~"

#: foreign.d:215
msgid "64 bit integers are not supported on this platform and with this C compiler: ~"
msgstr "los enteros de 64 bits no están soportados en esta arquitectura, para este compilador de C:"

#: foreign.d:357 foreign.d:509
msgid "~ cannot be converted to a foreign function with another calling convention."
msgstr "~ no puede ser convertido a una función extranjera con otra convención de llamada."

#: foreign.d:556
msgid "No more room for foreign language interface"
msgstr "No queda espacio para el interfaz con otros lenguajes"

#: foreign.d:567
msgid ":MALLOC-FREE is not available under AMIGAOS."
msgstr ":MALLOC-FREE no está disponible en AMIGAOS."

#: foreign.d:1089 foreign.d:1151 foreign.d:1297 foreign.d:1336
msgid "element type has size 0: ~"
msgstr "el tipo del elemento tiene tamaño 0: ~"

#: foreign.d:2059
msgid "~: argument is not a foreign variable: ~"
msgstr "~: el argumento no es una variable extranjera: ~"

#: foreign.d:2071
msgid "~: foreign variable with unknown type, missing DEF-C-VAR: ~"
msgstr "~: variable externa de tipo desconocido, se ha omitido DEF-C-VAR: ~"

#: foreign.d:2087
msgid "A foreign variable ~ does not exist"
msgstr "La variable extranjera ~ no existe"

#: foreign.d:2102
msgid "~: foreign variable ~ does not have the required size or alignment"
msgstr "~: la variable externa ~ no tiene el tamaño o alineamiento requerido"

#: foreign.d:2119
msgid "~: type specifications for foreign variable ~ conflict: ~ and ~"
msgstr "~: conflicto de especificación de tipo de la variable extranjera ~: ~ y ~"

#: foreign.d:2165
msgid "~: foreign variable ~ may not be modified"
msgstr "~: no se puede modificar la variable externa ~"

#: foreign.d:2221
msgid "~: foreign variable ~ of type ~ is not an array"
msgstr "~: la variable externa ~ del tipo ~ no es una matriz"

#: foreign.d:2316
msgid "~: foreign variable ~ of type ~ is not a pointer"
msgstr "~: la variable externa ~ del tipo ~ no es un puntero"

#: foreign.d:2419
msgid "~: foreign variable ~ of type ~ is not a struct or union"
msgstr "~: la variable externa ~ del tipo ~ no es, ni una estructura, ni una unión"

#: foreign.d:2431
msgid "~: foreign variable ~ of type ~ has no component with name ~"
msgstr "~: la variable externa ~ del tipo ~ no tiene ningún componente con el nombre ~"

#: foreign.d:2496 foreign.d:3579
msgid "~: foreign variable ~ does not have the required alignment"
msgstr "~: la variable externa ~ no tiene el alineamiento requerido"

#: foreign.d:2514
msgid "~: argument is not a foreign function: ~"
msgstr "~: el argumento no es una función extranjera: ~"

#: foreign.d:2527
msgid "~: foreign function with unknown calling convention, missing DEF-CALL-OUT: ~"
msgstr "~: función externa con convención de llamada desconocida, se ha omitido DEF-CALL-OUT: ~"

#: foreign.d:2547 foreign.d:3605
msgid "~: illegal foreign function type ~"
msgstr "~: tipo de función externa inválido ~"

#: foreign.d:2558
msgid "~: A foreign function ~ does not exist"
msgstr "~: La función extranjera ~ no existe"

#: foreign.d:2568
msgid "~: calling conventions for foreign function ~ conflict"
msgstr "~: conflicto en la convención de llamada de la función externa ~"

#: foreign.d:2841
msgid "~: Too few arguments (~ instead of at least ~) to ~"
msgstr "~: Muy pocos argumentos (~ en vez de, al menos, ~) para ~"

#: foreign.d:2855
msgid "~: :OUT argument is not a pointer: ~"
msgstr "~: el argumento :OUT no es un puntero: ~"

#: foreign.d:2901
msgid "~: Too many arguments (~ instead of ~) to ~"
msgstr "~: Demasiados argumentos (~ en vez de ~) para ~"

#: foreign.d:3463
msgid "~: Cannot open library ~"
msgstr "~: No se puede abrir la biblioteca ~"

#: foreign.d:3552
msgid "~: ~ is not a library"
msgstr "~: ~ no es una biblioteca"

#: init.lsp:337
msgid "~S is a special form and may not be redefined."
msgstr "~S es una forma especial y por ello, no puede ser redefinida"

#: clos.lsp:214 init.lsp:345
msgid "The old definition will be lost"
msgstr "Se perderá la definición anterior."

#: init.lsp:348
msgid "Redefining the COMMON LISP ~A ~S"
msgstr "La ~A de COMMON LISP ~S será redefinida"

# Junto las ¡! sv
# Sugerencia "¡Se estaba trazando!" (es como más "en español") sv
#
# Sí, tu sugerencia me gusta. Como se nota que tienes experiencia, ...,
# ¿eh? cll
#
#: init.lsp:366
msgid "DEFUN/DEFMACRO: redefining ~S; it was traced!"
msgstr "DEFUN/DEFMACRO: redefiniendo ~S; ¡se estaba rastreando!"

#: init.lsp:388
msgid "~S is impossible in compiled code"
msgstr "~S es imposible en código compilado"

#: init.lsp:472
msgid "~S is an invalid function environment"
msgstr "~S es un entorno de función inválido"

#: init.lsp:521
msgid "~S is an invalid variable environment"
msgstr "~S es un entorno de variable inválido"

#: init.lsp:588
msgid "~S: ~S is illegal since ~S is a local macro"
msgstr "~S: ~S es inválido, puesto que ~S es una macro local"

#: init.lsp:594
msgid "~S: invalid function environment ~S"
msgstr "~S: ~S es un entorno de función inválido"

#: init.lsp:602
msgid "~S: ~S is invalid since ~S is not a symbol"
msgstr "~S: ~S es incorrecto, puesto que ~S no es un símbolo"

#: init.lsp:778
msgid "code after MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de MACROLET contiene una lista punteada que termina con ~S"

#: init.lsp:796
msgid "illegal syntax in MACROLET: ~S"
msgstr "sintaxis inválida en MACROLET: ~S"

#: init.lsp:807
msgid "code after SYMBOL-MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de SYMBOL-MACROLET contiene una lista punteada que termina con ~S"

#: compiler.lsp:7208 init.lsp:818
msgid "~S: symbol ~S must not be declared SPECIAL and a macro at the same time"
msgstr "~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo"

#: compiler.lsp:7201 init.lsp:835
#, fuzzy
msgid "~S: symbol ~S is declared special and must not be declared a macro"
msgstr "~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo"

#: init.lsp:844
msgid "illegal syntax in SYMBOL-MACROLET: ~S"
msgstr "sintaxis inválida en SYMBOL-MACROLET: ~S"

#: init.lsp:884
msgid "bad function environment occurred in ~S: ~S"
msgstr "se encontró un entorno de función incorrecto en ~S: ~S"

#: init.lsp:895
msgid "~S: invalid form ~S"
msgstr "~S: forma inválida ~S"

#: init.lsp:908
msgid "code contains a dotted list, ending with ~S"
msgstr "el código contiene una lista punteada que termina con ~S"

#: init.lsp:953
msgid "~S: ~S should be a lambda expression"
msgstr "~S: ~S debe ser una expresión lambda"

#: init.lsp:996
msgid "lambda list must not end with the atom ~S"
msgstr "la lista lambda no debe terminar con el átomo ~S"

#: init.lsp:1030 init.lsp:1049
msgid "~S: variable list ends with the atom ~S"
msgstr "~S: la lista de variables termina con el átomo ~S"

#: init.lsp:1164
msgid "FLET/LABELS: code contains a dotted list, ending with ~S"
msgstr "FLET/LABELS: el código contiene una lista punteada que termina con ~S"

#: init.lsp:1175
msgid "illegal syntax in FLET/LABELS: ~S"
msgstr "sintaxis inválida en FLET/LABELS: ~S"

#: init.lsp:1305
msgid ";; Loading file "
msgstr ";; Cargando el fichero \""

#: init.lsp:1310
msgid " ..."
msgstr " ..."

#: init.lsp:1336
msgid ";; Loading of file "
msgstr ";; La carga del fichero "

# Nota: `is finished' debería traducirse por `está finalizado' o `está
#       finalizada'. Sin embargo, esta parte se compondrá con otras
#       donde la traducción `ha finalizado' sigue siendo igualmente válida y,
#       además, nos evitamos la utilización de una forma eminentemente
#       masculina o fememina.
#
#: init.lsp:1341
msgid " is finished."
msgstr " ha finalizado."

#: init.lsp:1350
msgid "A file with name ~A does not exist"
msgstr "No existe ningún fichero con el nombre ~A"

#: init.lsp:1366
msgid "~S: missing function name and/or parameter list"
msgstr "~S: no se ha indicado el nombre de la función y/o la lista de parámetros"

#: init.lsp:1376
msgid "~S: ~S is not a symbol."
msgstr "~S: ~S no es un símbolo."

#: init.lsp:1383
msgid "~S: special form ~S cannot be redefined."
msgstr "~S: la forma especial ~S no puede ser redefinida."

#: init.lsp:1430 macros1.lsp:160
msgid "exit clause in ~S must be a list"
msgstr "la cláusula exit en ~S debe ser una lista"

#: init.lsp:1583
msgid "~S: cannot define a function from that: ~S"
msgstr "~: no es posible definir una función a partir de ~S"

#: clos.lsp:3072 clos.lsp:3133 init.lsp:1590
msgid "~S: the name of a function must be a symbol, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

#: init.lsp:1597
msgid "~S: function ~S is missing a lambda list"
msgstr "~S: la función ~S debe tener una lista lambda"

# Duda: Aquí, igual que en el caso de la traducción francesa, he
# preferido preservar el término `backquote' y ---porque así se ha
# decidido en Spanish GNU Translation Team---, el término está con
# comillas simples.
#
# He tomado esta decisión porque el `backquote' (que es la tilde
# invertida `) es un término muy familiar para todos los programadores
# de Lisp que, con toda seguridad, conocerán.
#
#: backquot.lsp:39
msgid "~S: comma is illegal outside of backquote"
msgstr "~S: la coma es inválida fuera del `backquote'"

#: backquot.lsp:46
msgid "~S: more commas out than backquotes in, is illegal"
msgstr "~S: no se pueden emplear más comas fuera que apóstrofes invertidos dentro"

#: backquot.lsp:209
msgid "The syntax ,@form is valid only in lists"
msgstr "La sintaxis ,@forma es válida únicamente en las listas"

#: backquot.lsp:216
msgid "The syntax ,.form is valid only in lists"
msgstr "La sintaxis ,.forma es válida únicamente en las listas"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# A partir de la versión 1997-05-03, este mensaje ha cambiado y se
# refiere a elementos que serán ignorados. Como no puede anticiparse
# cual será el género del objeto que se ignora, he preferido poner lo de
# os/as. ¿Qué os parece?
#
#: defmacro.lsp:44
msgid "Both will be ignored."
msgstr "Ambos/as serán ignorados/as."

#: defmacro.lsp:47
msgid "Invalid keyword-value-pair: ~S ~S"
msgstr "Par argumento clave y valor inválido: ~S ~S"

#: defmacro.lsp:58
msgid "The macro ~S may not be called with ~S arguments"
msgstr "La macro ~S no puede ser invocada con ~S argumentos"

#: defmacro.lsp:131 defmacro.lsp:162 defmacro.lsp:327
msgid "The rest of the lambda list will be ignored."
msgstr "El resto de la lista lambda será ignorado."

#: defmacro.lsp:134
msgid "The lambda list of macro ~S contains a dot after &AUX."
msgstr "La lista lambda de la macro ~S contiene un punto después de &AUX"

#: defmacro.lsp:142
msgid "in macro ~S: ~S may not be used as &AUX variable."
msgstr "en la macro ~S: ~S no debe usarse como una variable &AUX."

#: defmacro.lsp:165
msgid "The lambda list of macro ~S contains a dot after &KEY."
msgstr "La lista lambda de la macro ~S contiene un punto después de &KEY"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
#: defmacro.lsp:176 defmacro.lsp:198 defmacro.lsp:418 defmacro.lsp:438 defmacro.lsp:447
msgid "It will be ignored."
msgstr "Será ignorado."

#: defmacro.lsp:179
msgid "The lambda list of macro ~S contains a badly placed ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S mal situado."

#: defmacro.lsp:201
msgid "The lambda list of macro ~S contains the invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene el elemento inválido ~S"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# No tengo ni idea de qué significa ese "0*"
#: defmacro.lsp:233
msgid "~0*It will be ignored."
msgstr "Será ignorado."

#: defmacro.lsp:236
msgid "The lambda list of macro ~S contains an invalid keyword specification ~S"
msgstr "La lista lambda de la macro ~S contiene una especificación de argumento clave inválida: ~S"

#: defmacro.lsp:309
msgid "The lambda list of macro ~S is missing a variable after &REST/&BODY."
msgstr "La lista lambda de la macro ~S necesita una variable después de &REST/&BODY."

#: defmacro.lsp:316
msgid "The lambda list of macro ~S contains an illegal variable after &REST/&BODY: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable inválida después de &REST/&BODY: ~S"

#: defmacro.lsp:330
msgid "The lambda list of macro ~S contains a misplaced dot."
msgstr "La lista lambda de la macro ~S contiene un punto mal situado."

# Ojo. sv
#
# :) Vale :) cll
#
#: defmacro.lsp:337
msgid "They will be ignored."
msgstr "Serán ignorados."

#: defmacro.lsp:340
msgid "The lambda list of macro ~S contains superfluous elements: ~S"
msgstr "La lista lambda de la macro ~S contiene elementos innecesarios: ~S"

#: defmacro.lsp:395
msgid "The lambda list of macro ~S contains an illegal &REST variable: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable &REST inválida: ~S"

#: defmacro.lsp:411
msgid "The lambda list of macro ~S contains an invalid &WHOLE: ~S"
msgstr "La lista lambda de la macro ~S contiene un &WHOLE inválido: ~S"

#: defmacro.lsp:421
msgid "The lambda list of macro ~S contains a superfluous ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S innecesario."

#: defmacro.lsp:441
msgid "The lambda list of macro ~S contains ~S before &KEY."
msgstr "La lista lambda de la macro ~S contiene ~S antes de &KEY."

#: defmacro.lsp:450
msgid "The lambda list of macro ~S contains ~S which is illegal here."
msgstr "La lista lambda de la macro ~S contiene ~S, lo cual es incorrecto aquí."

#: defmacro.lsp:471
msgid "The lambda list of macro ~S contains an invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene un elemento inválido: ~S"

#: defmacro.lsp:487
msgid "The lambda list of macro ~S contains an invalid supplied-variable ~S"
msgstr "La lista lambda de la macro ~S contiene una \"variable-proporcionada\" inválida ~S"

#: defmacro.lsp:551
msgid "In the lambda list of macro ~S, &ENVIRONMENT must be followed by a non-NIL symbol: ~S"
msgstr "En la lista lambda de la macro ~S, &ENVIRONMENT debe estar seguido de un símbolo no nulo: ~S"

#: defmacro.lsp:575
msgid "Cannot define a macro from that: ~S"
msgstr "No se puede definir una macro a partir de: ~S"

#: defmacro.lsp:582
msgid "The name of a macro must be a symbol, not ~S"
msgstr "El nombre de una macro debe ser un símbolo, no ~S"

#: defmacro.lsp:589
msgid "Macro ~S is missing a lambda list."
msgstr "La macro ~S necesita una lista lambda."

#: macros1.lsp:11 macros1.lsp:38
msgid "~S: non-symbol ~S can't be a variable"
msgstr "~S: sólo los símbolos pueden ser variables, y no ~S"

#: macros1.lsp:18 macros1.lsp:45
msgid "~S: the constant ~S must not be redefined to be a variable"
msgstr "~S: la constante ~S no debe redefinirse como una variable"

#: macros1.lsp:61
msgid "~S: non-symbol ~S can't be a defined constant"
msgstr "~S: ~S no es un símbolo, y por lo tanto no puede definirse como una constante"

#: macros1.lsp:96
msgid "~S redefines the constant ~S. Its old value was ~S."
msgstr "~S redefine la constante ~S. Su valor anterior era ~S."

#: macros1.lsp:167
msgid "Invalid syntax in ~S form: ~S."
msgstr "Sintaxis inválida en la forma ~S: ~S."

#: macros1.lsp:285 places.lsp:734
msgid "~S called with an odd number of arguments: ~S"
msgstr "~S ha sido invocado con un número impar de argumentos: ~S"

#: macros1.lsp:339
msgid "~S: missing key list"
msgstr "~S: falta la lista de claves"

#: macros1.lsp:348
msgid "~S: the ~S clause must be the last one"
msgstr "~S: la clausula ~S debe ser la última"

#: macros1.lsp:403 macros1.lsp:484
msgid "Not a list of COND clauses: ~S"
msgstr "No es una lista de cláusulas COND: ~S"

#: macros1.lsp:410 macros1.lsp:491
msgid "The atom ~S must not be used as a COND clause."
msgstr "El átomo ~S no debe usarse como una cláusula COND."

#: macros1.lsp:448
msgid "COND code contains a dotted list, ending with ~S"
msgstr "El código de COND contiene una lista punteada que termina con ~S"

#: compiler.lsp:7263 macros1.lsp:456
msgid "COND clause without test: ~S"
msgstr "Cláusula COND sin prueba condicional: ~S"

#: macros2.lsp:40
msgid "Language ~S is not defined"
msgstr "El lenguaje ~S no está definido"

#: macros2.lsp:52
msgid "Language ~S inherits from ~S"
msgstr "El lenguaje ~S hereda de ~S"

#: macros2.lsp:106
msgid "~S: Language ~S is not defined"
msgstr "~S: El lenguaje ~S no está definido"

#: macros2.lsp:131
msgid "~S ~S: no value for default language ~S"
msgstr "~S ~S: no hay ningún valor para el lenguaje por defecto ~S"

#: macros2.lsp:148
msgid "Invalid clause in ~S: ~S"
msgstr "Cláusula inválida en ~S: ~S"

#: macros2.lsp:169
msgid "~A~%The value is: ~S"
msgstr "~A~%El valor es: ~S"

#: macros2.lsp:175
msgid "The value of ~S should be ~:[of type ~S~;~:*~A~]."
msgstr "El valor de ~S debe ser ~:[del tipo ~S~;~:*~A~]."

#: macros2.lsp:181
msgid "You may input a new value."
msgstr "Puede introducir un nuevo valor."

#: macros2.lsp:186
msgid "~%New ~S: "
msgstr "~%Nuevo ~S: "

#: macros2.lsp:209
msgid "Retry"
msgstr "Reintentar"

#: macros2.lsp:214
msgid "You may input new values."
msgstr "Puede introducir nuevos valores."

#: macros2.lsp:220
msgid "~S must evaluate to a non-NIL value."
msgstr "~S no puede evaluarse como NIL."

#: macros2.lsp:258
msgid "The value of ~S must be of one of the types ~{~S~^, ~}"
msgstr "El valor de ~S debe ser de uno de los tipos ~{~S~^, ~}"

#: macros2.lsp:265
msgid "The value of ~S must be one of ~{~S~^, ~}"
msgstr "El valor de ~S debe ser uno de los siguientes ~{~S~^, ~}"

#: conditio.lsp:1320 macros2.lsp:283
msgid "~S used as a key in ~S, it would be better to use parentheses."
msgstr "~S es usado como una clave en ~S, sería mejor utilizar paréntesis."

#: macros2.lsp:371
msgid "type name should be a symbol, not ~S"
msgstr "el nombre del tipo debe ser un símbolo, no ~S"

#: macros2.lsp:378
msgid "~S is a built-in type and may not be redefined."
msgstr "~S es un tipo predefinido y no puede ser redefinido."

#: macros2.lsp:413
msgid "The deftype expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de DEFTYPE para ~S no puede invocarse con ~S argumentos."

#: defs1.lsp:318
msgid "~S: ~S does not name a logical host"
msgstr "~S: ~S no es el nombre de un anfitrión \"lógico\""

#: defs1.lsp:358
msgid "No translations for logical host ~S found"
msgstr ""

#: defs1.lsp:457
msgid "~S: argument ~S should be a nonnegative number"
msgstr "~S: el argumento ~S debe ser un número no negativo"

#: defs1.lsp:621
msgid "incorrect date: ~S.~S.~S, ~Sh~Sm~Ss, time zone ~S"
msgstr "fecha incorrecta: ~S/~S/~S, ~Sh~Sm~Ss, zona horaria ~S"

#: places.lsp:24
msgid "The function (~S ~S) is hidden by a SETF expander."
msgstr "Una función de expansión de SETF oculta a la función (~S ~S)"

#: places.lsp:87
msgid "The argument ~S to ~S should be a keyword."
msgstr "El argumento ~S de ~S debe ser un argumento clave."

# Lo mismo de antes. A lo mejor se puede poner "modificable setf". sv
#: places.lsp:144
msgid "Argument ~S is not a SETF place."
msgstr "El argumento ~S no es un lugar `setf' modificable"

#: places.lsp:159
msgid "SETF place ~S produces more than one store variable."
msgstr "El lugar `setf' ~ genera más de una variable de almacenamiento."

#: places.lsp:185 places.lsp:195
msgid "~S: first argument ~S is illegal, not a symbol"
msgstr "~S: el primer argumento ~S es inválido, no es un símbolo"

#: places.lsp:233
msgid "The name of the access function must be a symbol, not ~S"
msgstr "El nombre de la función de acceso debe ser un símbolo, no ~S"

# Duda: En esta y otras partes de este archivo .po aparece la expresión
# `expander' (¡expansor es horrible!). Me dio muchisimos quebraderos de
# cabeza, pero muchos y francamente, estaba absolutamente atascado
# cuando lo pregunté en las listas de Spanish GNU y CLisp.
#
# Curiosamente, la única persona que respondió no tiene ni idea de
# español (Bruno Haible):
#
# "expander" or "expansion function", I would say.
#
# ¡Pues leches, eso mismo! Función de expansión me suena
# perfectísimamente, ...
#
#: places.lsp:268
msgid "The SETF expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de SETF para ~S no puede invocarse con ~S argumentos."

#: places.lsp:305
msgid "Too many arguments to DEFSETF: ~S"
msgstr "Demasiados argumentos para DEFSETF: ~S"

#: places.lsp:311
msgid "The doc string to DEFSETF must be a string: ~S"
msgstr "La cadena de documentación de DEFSETF debe ser una cadena: ~S"

#: places.lsp:323
msgid "Missing store variable in DEFSETF."
msgstr "No se encuentra ninguna variable de almacenamiento en DEFSETF."

#: places.lsp:365
msgid "Illegal syntax in DEFSETF for ~S"
msgstr "Sintaxis inválida en DEFSETF: ~S"

#: places.lsp:380
msgid "(SETF (NTH ...) ...) : index ~S is too large for ~S"
msgstr "(SETF (NTH ...) ...) : el índice ~S es demasiado grande para ~S"

#: places.lsp:482
#, fuzzy
msgid "PSETF called with an odd number of arguments: ~S"
msgstr "~S ha sido invocado con un número impar de argumentos: ~S"

#: places.lsp:530
msgid "REMF: property list with an odd length"
msgstr "REMF: lista de propiedades de longitud impar"

#: places.lsp:582
msgid "In the definition of ~S: &REST variable ~S should be a symbol."
msgstr "En la definición de ~S: la variable &REST ~S debe ser un símbolo."

#: places.lsp:590
msgid "Only one variable is allowed after &REST, not ~S"
msgstr "Sólo se permite una variable después de &REST, no ~S"

#: places.lsp:597
msgid "Illegal in a DEFINE-MODIFY-MACRO lambda list: ~S"
msgstr "Lista lambda inválida en DEFINE-MODIFY-MACRO: ~S"

#: places.lsp:607
msgid "lambda list may only contain symbols and lists, not ~S"
msgstr "la lista lambda sólo puede contener símbolos y listas, no ~S"

# En cristiano creo que sería "Lugar SETF incorrecto". sv
#
# Sí, tienes razón. Creo que cuando traduje este mensaje llevaba
# demasiadas horas delante del ordenador, ... tienes razón, ... cll
#
#: places.lsp:726
msgid "Illegal SETF place: ~S"
msgstr "Lugar `setf' inválido: ~S"

#: places.lsp:749
msgid "SHIFTF called with too few arguments: ~S"
msgstr "SHIFTF ha sido llamado con muy pocos argumentos: ~S"

#: places.lsp:791
msgid "(SETF (GETF ...) ...) : property list with an odd length"
msgstr "(SETF (GETF ...) ...) : lista de propiedades de longitud impar"

#: places.lsp:828
msgid "first argument ~S is illegal, not a symbol"
msgstr "el primer argumento ~S es inválido, no es un símbolo"

#: places.lsp:940
msgid "SETF APPLY is only defined for functions of the form #'symbol."
msgstr "SETF APPLY sólo está definido para funciones de la forma #'símbolo."

# Duda: en Common Lisp existe lo que se denominan los `setf places'. En
# realidad, es una manera bastante correcta de referirse a posiciones de
# memoria (cuyos nombres pueden ser variables, funciones, etc.) que son
# modificables con la primitiva SETF de Lisp. Por ello, traducirlo como
# `modificable' es eminentemente correcto, pero en realidad me da miedo
# porque a los programadores experimentados les mosqueará lo de
# `modificable' a secas. Les resultará mucho más familiar algo como
# `setf modificables', aunque en español esto suene bastante
# regular. cll
#
# En cualquier caso, cuando uno se empeña en emplear la palabra inglesa,
# siempre queda la posibilidad de conservar la sintaxis española,
# por ejemplo: "... no es un lugar modificable `setf'" sv
#
#: places.lsp:948
msgid "APPLY on ~S is not a SETF place."
msgstr "APPLY de ~S no es un lugar `setf' modificable"

#: places.lsp:1005
msgid "SETF FUNCALL is only defined for functions of the form #'symbol."
msgstr "SETF FUNCALL sólo está definido para funciones de la forma #'símbolo."

#: floatpri.lsp:341
msgid "argument is not a float: ~S"
msgstr "el argumento no es un número en coma flotante: ~S"

#: type.lsp:30
msgid "~S: invalid type specification ~S"
msgstr "~S: la especificación de tipo ~S es inválida"

#: compiler.lsp:8650 type.lsp:59
msgid "~S: argument to SATISFIES must be a symbol: ~S"
msgstr "~S: el argumento de SATISFIES debe ser un símbolo: ~S"

#: compiler.lsp:8462 compiler.lsp:8474 type.lsp:265 type.lsp:276
msgid "~S: argument to ~S must be *, ~S or a list of ~S: ~S"
msgstr "~S: el argumento de ~S debe ser *, ~S o una lista de ~S: ~S"

#: compiler.lsp:8523 type.lsp:286
msgid "~S: argument to MOD must be an integer: ~S"
msgstr "~S: el argumento de MOD debe ser un entero: ~S"

#: compiler.lsp:8537 type.lsp:299
msgid "~S: argument to SIGNED-BYTE must be an integer or * : ~S"
msgstr "~S: el argumento de SIGNED-BYTE debe ser un entero o * : ~S"

#: compiler.lsp:8553 type.lsp:312
msgid "~S: argument to UNSIGNED-BYTE must be an integer or * : ~S"
msgstr "~S: el argumento de UNSIGNED-BYTE debe ser un entero o * : ~S"

#: type.lsp:470
msgid "Invalid type specifier ~S"
msgstr "Especificador de tipo inválido: ~S"

#: defstruc.lsp:63 foreign1.lsp:444
msgid "~S: this is not a symbol: ~S"
msgstr "~S: esto no es un símbolo: ~S"

#: defstruc.lsp:403
msgid "~S: invalid syntax for name and options: ~S"
msgstr "~S: la sintáxis del nombre y las opciones es inválida: ~S"

#: defstruc.lsp:429
msgid "~S ~S: argument list should be a list: ~S"
msgstr "~S ~S: la lista de argumentos debe ser una lista: ~S"

#: defstruc.lsp:454
msgid "~S ~S: At most one :INCLUDE argument may be specified: ~S"
msgstr "~S ~S: Sólo puede especificarse un argumento :INCLUDE como mucho: ~S"

#: defstruc.lsp:464
msgid ""
"~S: Use of ~S implicitly applies FUNCTION.~@\n"
"                                     Therefore using ~S instead of ~S."
msgstr ""
"~S: El uso de ~S aplica, implícitamente, FUNCTION.~@\n"
"                                     Por lo tanto, se utilizará ~S en vez de ~S."

#: conditio.lsp:112 defstruc.lsp:481
msgid "~S ~S: unknown option ~S"
msgstr "~S ~S: opción ~S desconocida"

#: clos.lsp:3229 conditio.lsp:118 defstruc.lsp:487
msgid "~S ~S: invalid syntax in ~S option: ~S"
msgstr "~S ~S: la sintaxis de la opción ~S es inválida: ~S"

#: clos.lsp:3148 conditio.lsp:124 defstruc.lsp:493
msgid "~S ~S: not a ~S option: ~S"
msgstr "~S ~S: no se trata de una opción ~S: ~S"

# Duda: (y además gorda) Podría parecer que el siguiente mensaje debiera
# traducirse por:
#
# ~S ~S: No hay ningún :PREDICATE sobre estructuras sin nombre.
#
# Sin embargo, el manual "Common Lisp, The Language - 2nd Edition", en
# la página 477 advierte que, en realidad, la opción :PREDICATE no debe
# usarse con estructuras sin nombre:
#
# `A predicate can be defined only if the structure is "named"'
#
# Por lo tanto, he preferido traducir este mensaje de otra manera, tal y
# como veis:
#
#: defstruc.lsp:519
msgid "~S ~S: There is no :PREDICATE on unnamed structures."
msgstr "~S ~S: No puede definirse un :PREDICATE sobre estructuras sin nombre."

#: defstruc.lsp:547
msgid "~S ~S: invalid :TYPE option ~S"
msgstr "~S ~S: opción :TYPE inválida ~S"

#: defstruc.lsp:555
msgid "~S ~S: The :INITIAL-OFFSET must be a nonnegative integer, not ~S"
msgstr "~S ~S: El :INITIAL-OFFSET debe ser un entero no negativo, y no ~S"

#: defstruc.lsp:563
msgid "~S ~S: :INITIAL-OFFSET must not be specified without :TYPE : ~S"
msgstr "~S ~S: El :INITIAL-OFFSET no debe especificarse sin :TYPE : ~S"

#: defstruc.lsp:583
msgid "~S ~S: included structure ~S has not been defined."
msgstr "~S ~S: la estructura incluida ~S no ha sido definida."

#: defstruc.lsp:597
msgid "~S ~S: included structure ~S must be of the same type ~S."
msgstr "~S ~S: la estructura incluida ~S debe ser del tipo ~S."

#: defstruc.lsp:624
msgid "~S ~S: included structure ~S has no component with name ~S."
msgstr "~S ~S: la estructura incluida ~S no tiene ninguna componente con el nombre ~S."

#: defstruc.lsp:655
msgid "~S ~S: The READ-ONLY slot ~S of the included structure ~S must remain READ-ONLY in ~S."
msgstr "~S ~S: La ranura READ-ONLY ~S de la estructura incluida ~S debe permanecer READ-ONLY en ~S."

#: defstruc.lsp:667
msgid "~S ~S: The type ~S of slot ~S should be a subtype of the type defined for the included strucure ~S, namely ~S."
msgstr "~S ~S: El tipo ~S de la ranura ~S debe ser un subtipo del que ha sido definido para la estructura incluida ~S, a saber, ~S."

#: defstruc.lsp:675 defstruc.lsp:779
msgid "~S ~S: ~S is not a slot option."
msgstr "~S ~S: ~S no es una opción de ranura."

#: defstruc.lsp:709
msgid "~S ~S: structure of type ~S can't hold the name."
msgstr "~S ~S: una estructura del tipo ~S no puede contener el nombre."

#: defstruc.lsp:763
msgid "~S ~S: There may be only one slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura con el nombre ~S."

#: format.lsp:70
msgid "The control string terminates within a directive."
msgstr "La cadena de control termina en una directiva."

#: format.lsp:139
msgid "~A must introduce a number."
msgstr "~A debe introducir un número."

#: format.lsp:151
msgid "The control string terminates in the middle of a parameter."
msgstr "La cadena de control termina en medio de un parámetro."

#: format.lsp:233
msgid "Non-existent directive"
msgstr "Directiva no existente"

#: format.lsp:243
msgid "Closing '/' is missing"
msgstr ""

#: format.lsp:258
#, fuzzy
msgid "There is no package with name ~S"
msgstr "No hay ningún paquete con el nombre ~"

#: format.lsp:275
msgid "The closing directive '~A' does not have a corresponding opening one."
msgstr "No existe una directiva de apertura para la de cierre `~A'."

#: format.lsp:282
msgid "The closing directive '~A' does not match the corresponding opening one. It should read '~A'."
msgstr "La directiva de cierre `~A' no se corresponde con la de apertura. Debe leerse `~A'."

#: format.lsp:293 format.lsp:1686 format.lsp:2500
msgid "The ~~; directive is not allowed at this point."
msgstr "La directiva ~~; no está permitida aquí."

#: format.lsp:305
msgid "The ~~newline directive cannot take both modifiers."
msgstr "La directiva ~~newline no puede tomar ambos modificadores."

# Ojo: Estos "ing" no son siempre gerundios.
# Tal vez sea simplemente "...; se esperaba '~A'." sv
#
# Bueno, ..., cuando el mensaje ha salido es que se ha producido un
# error. En tal caso, no se puede estar `esper*ando*', sino que se
# esperaba, ... Si, creo que tienes toda la razón. cll
#
#: format.lsp:328
msgid "An opening directive is never closed; expecting '~A'."
msgstr "No se ha cerrado una directiva; se esperaba `~A'."

#: format.lsp:355
msgid "~%Current point in control string:"
msgstr "~%Posición en curso en la cadena de control:"

# Duda: `fill pointer' (puntero de llenado, o de relleno) es un
# recurso que existe en Common Lisp (y por lo tanto, en CLisp) para
# determinar qué parte de un vector está en uso (la que hay desde el
# principio hasta la posición apuntada por el `fill pointer'). Se trata
# de un término que cualquier programador en Lisp debe conocer porque
# esta palabra clave se utiliza en ocasiones, incluso, como palabra
# reservada para indicar una determinada opción en algunas funciones.
#
# Por ese motivo, he decidido dejarla tal cual, sin traducir. Cuando
# pregunté a Bruno Haible sobre esto me respondió:
#
# Imagine a device attached to a bottle or tank, which shows how much full
# the bottle is, in percent. How would you call this device?
#
# ... y francamente, ¡no se me ocurre como!
#
# Bueno, con el tiempo he decidido que (tal y como señala Bruno Haible)
# lo mejor sería: "puntero de relleno".
#
#: format.lsp:407
msgid "The destination string ~S should have a fill pointer."
msgstr "La cadena de destino ~S debe tener un puntero de relleno."

#: format.lsp:416
msgid "The destination argument ~S is invalid (not NIL or T or a stream or a string)."
msgstr "El argumento destino no es NIL, ni tampoco T, un flujo o una cadena: ~S"

#: format.lsp:447
msgid "~S: The control-string must be a string, not ~S"
msgstr "~S: La cadena de control debe ser una cadena, y no ~S"

#: format.lsp:460
msgid "There are not enough arguments left for this directive."
msgstr "No hay argumentos suficientes para esta directiva."

#: format.lsp:560
msgid "The ~~:@R directive requires an integer in the range 1 - 4999, not ~S"
msgstr "La directiva ~~:@R necesita un entero en el rango 1 - 4999, no ~S"

#: format.lsp:581
msgid "The ~~@R directive requires an integer in the range 1 - 3999, not ~S"
msgstr "La directiva ~~@R necesita un entero en el rango 1 - 3999, no ~S"

#: format.lsp:647
msgid "The argument for the ~~R directive is too large."
msgstr "El argumento de la directiva ~~R es demasiado grande."

#: format.lsp:1369
msgid "The ~~R and ~~:R directives require an integer argument, not ~S"
msgstr "Las directivas ~~R y ~~:R necesitan un argumento entero, no ~S"

#: format.lsp:1393
msgid "The ~~C directive requires a character argument, not ~S"
msgstr "La directiva ~~C necesita un carácter como argumento, no ~S"

#: format.lsp:1620
msgid "The control string argument for the ~~? directive is invalid: ~S"
msgstr "La cadena de control de la directiva ~~? es inválida: ~S"

#: format.lsp:1627
msgid "The argument list argument for the ~~? directive is invalid: ~S"
msgstr "El argumento de la lista de argumentos de la directiva ~~? es inválido: ~S"

#: format.lsp:1693
msgid "The ~~[ parameter must be an integer, not ~S"
msgstr "El parámetro para ~~[ debe ser un entero, no ~S"

#: format.lsp:1714
msgid "The ~~[ directive cannot take both modifiers."
msgstr "La directiva ~~[ no puede tomar ambos modificadores."

#: format.lsp:1742
msgid "The ~~{ directive requires a list argument, not ~S"
msgstr "La directiva ~~{ requiere una lista de argumentos, no ~S"

#: format.lsp:2232
msgid "Too many arguments for this directive"
msgstr "Demasiados argumentos para esta directiva"

#: format.lsp:2775
msgid "The control-string must be a string, not ~S"
msgstr "La cadena de control debe ser una cadena, no ~S"

# paquete (?) sv
#
# Bueno, podría parecer muy conveniente. Sin embargo, verás, ..., lo de
# *package* está puesto a nivel de programa. Es decir, Bruno Haible y
# compañía lo tienen puesto así desde su propio programa. Por lo tanto,
# si lo cambio en un par de mensajes seguirá apareciendo en muchos otros
# sitios. Prefiero ser consistente y dejarlo así. cll
#
# Además, no está traducido ni en alemán ni en inglés. cll
#
#: user1.lsp:67
msgid "[*package* invalid]"
msgstr "[*package* inválido]"

#: user1.lsp:178
#, fuzzy
msgid "Values: "
msgstr "valores: "

# Me suele gustar más "utilice" (porque me parece más "fino"). sv
#
# De acuerdo, ..., cambiado `use' por `utilice'. A mí también me gusta más. cll
#
# Y además, (recomendación tuya, Santiago), `command' por `orden', en
# vez de `comando' - cll
#
#: user1.lsp:188
#, fuzzy
msgid ""
"\n"
"Help = this list\n"
"Use the usual editing capabilities.\n"
"(quit) or (exit) leaves CLISP."
msgstr ""
"\n"
"Help = esta lista\n"
"Utilice las órdenes de edición habituales"

#
# Cambiado `comando' por `orden', que parece ser muchísimo mejor - cll
#
#: user1.lsp:205
msgid ""
"\n"
"Help   = this command list\n"
"Abort  = abort to the next recent input loop\n"
"Unwind = abort to the next recent input loop\n"
"Mode-1 = inspect all the stack elements\n"
"Mode-2 = inspect all the frames\n"
"Mode-3 = inspect only lexical frames\n"
"Mode-4 = inspect only EVAL and APPLY frames (default)\n"
"Mode-5 = inspect only APPLY frames\n"
"Where  = inspect this frame\n"
"Up     = go up one frame, inspect it\n"
"Top    = go to top frame, inspect it\n"
"Down   = go down one frame, inspect it\n"
"Bottom = go to bottom (most recent) frame, inspect it\n"
"Backtrace-1 = list all stack elements\n"
"Backtrace-2 = list all frames\n"
"Backtrace-3 = list all lexical frames\n"
"Backtrace-4 = list all EVAL and APPLY frames\n"
"Backtrace-5 = list all APPLY frames\n"
"Backtrace   = list stack in current mode\n"
"Break+ = set breakpoint in EVAL frame\n"
"Break- = disable breakpoint in EVAL frame\n"
"Redo   = re-evaluate form in EVAL frame\n"
"Return = leave EVAL frame, prescribing the return values"
msgstr ""
"\n"
"Help   = esta lista de órdenes\n"
"Abort  = volver al bucle de entrada más reciente\n"
"Unwind = volver al bucle de entrada más reciente\n"
"Mode-1 = inspeccionar todos los elementos de la pila\n"
"Mode-2 = inspeccionar todos los marcos\n"
"Mode-3 = inspeccionar únicamente los marcos léxicos\n"
"Mode-4 = inspeccionar sólo los marcos de los tipos EVAL y APPLY (por\n"
"         defecto)\n"
"Mode-5 = inspeccionar sólo los marcos de tipo APPLY\n"
"Where  = inspeccionar el marco actual\n"
"Up     = ascender un marco, e inspeccionarlo\n"
"Top    = ir al primer marco, e inspeccionarlo\n"
"Down   = descender un marco e inspeccionarlo\n"
"Bottom = ir al último marco (el más reciente) e inspeccionarlo\n"
"Backtrace-1 = mostrar todos los elementos de la pila\n"
"Backtrace-2 = mostrar todos los marcos\n"
"Backtrace-3 = mostrar todos los marcos léxicos\n"
"Backtrace-4 = mostrar todos los marcos de los tipos EVAL y APPLY\n"
"Backtrace-5 = mostrar todos los marcos del tipo APPLY\n"
"Backtrace   = mostrar la pila en el modo actual\n"
"Break+ = establecer un punto de ruptura en un marco de tipo EVAL\n"
"Break- = desactivar un punto de ruptura en un marco de tipo EVAL\n"
"Redo   = re-evaluar la forma en un marco EVAL\n"
"Return = abandonar un marco EVAL con los valores de vuelta indicados"

#: user1.lsp:308
msgid ""
"\n"
"Continue = continue evaluation"
msgstr ""
"\n"
"Continue = continuar la evaluación"

#: user1.lsp:381
msgid "You can continue (by typing 'continue')."
msgstr "Puede continuar (tecleando `continue')."

#: conditio.lsp:1486 user1.lsp:390 user1.lsp:686
msgid "If you continue (by typing 'continue'): "
msgstr "Si continúa (tecleando `continue'): "

# Duda: Los `restarts' son un mecanismo muy, muy eficiente en Common
# Lisp para la recuperación de errores.
#
# Es posible programar una sección de código de modo que cuando sucede
# algún error se invoquen determinados `restarts' (elegidos y, más aún,
# programados por el propio programador). CLisp, entonces, presenta un
# menú con todos los `restarts' disponibles; el usuario debe elegir
# entre los posibles `restarts' para continuar la evaluación o
# cualquiera de las acciones de depuración que proporciona el entorno.
#
# Pero ¿cómo traducir `restart'? ¿re-entrada, ...? Hmmm, ..., no me
# suena nada bien. Por ese motivo, he preferido sustituir la palabra por
# una expresión: `También es posible continuar en los siguientes
# puntos:", y cuando no sea posible aplicar una expresión de este tipo,
# dejaré `restart' sin traducir hasta que se me ocurra algo más
# original.
#
# ¡¡Necesito ayuda!! :)
#
#: user1.lsp:404
msgid "The following restarts are available too:"
msgstr "También es posible continuar en los siguientes puntos:"

#: user1.lsp:407
msgid "The following restarts are available:"
msgstr "Es posible continuar en los siguientes puntos:"

# ¿form no era formulario? (o a lo mejor es algo de lisp que no sé). sv
#
# En Visual Basic (y los lenguajes orientados a eventos), form es formulario.
# Sin embargo, en Lisp form es forma. Se refiere a las sentencias Lisp. cll
#
#: user1.lsp:501
msgid ""
"\n"
"Step     = step into form: evaluate this form in single step mode\n"
"Next     = step over form: evaluate this form at once\n"
"Over     = step over this level: evaluate at once up to the next return\n"
"Continue = switch off single step mode, continue evaluation\n"
"Step-until, Next-until, Over-until, Continue-until:\n"
"           same as above, specify a condition when to stop"
msgstr ""
"\n"
"Step     = entrar en una forma: evaluar esta forma en el modo paso a paso\n"
"Next     = saltarse una forma: evaluar esta forma en un solo paso\n"
"Over     = saltarse este nivel: evaluar hasta el siguiente retorno\n"
"Continue = desactivar el modo paso a paso y continuar la evaluación\n"
"Step-until, Next-until, Over-until, Continue-until:\n"
"           lo mismo que antes, especifique una condición de parada"

# Duda: Francamente, no sé porqué motivo esto no fué traducido al
# FRANCÉS o al INGLÉS (compruébese en el código, ...) porque en
# realidad, queda pero que muy bien poner `paso' cuando se hace la
# depuración paso a paso, ...
#
# Este mensaje, de hecho, aparece cuando se hace algo del tipo:
#
# > (step (+ 2 3))
# step 1 --> (+ 2 3)
# Step 1>
#
# ..., donde, traduciendo el primer `step' al español, queda algo muy
# propio:
#
# > (step (+ 2 3))
# paso 1 --> (+ 2 3)
# Step 1>
#
# A mi me gusta así, ..., ¡¡A SACO!!
#
#: user1.lsp:536 user1.lsp:597
msgid "step "
msgstr "paso "

#: user1.lsp:544
msgid "no values"
msgstr "sin valores"

#: user1.lsp:549
msgid "value: "
msgstr "valor: "

#: user1.lsp:557
msgid " values: "
msgstr " valores: "

#: user1.lsp:629
msgid "condition when to stop: "
msgstr "condición de parada: "

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: conditio.lsp:1520 conditio.lsp:1547 user1.lsp:703
msgid "WARNING:"
msgstr "ATENCIÓN:"

# Con un poco de suerte, aquí se podría poner directamente " (s/n) ".
# En fileutils ya se puede. sv
#
# Bueno, pues sí, ..., sí podría hacerse. Ahora bien, para eso es
# necesario modificar el código fuente del clisp (lo cual no es nada
# complicado gracias a la localizacion de codigo fuente del modo .PO
# desde Emacs :). De momento, lo dejo tal cual (aunque queda pachín,
# pachán, ... :( ) y luego lo modificaré, ..., ¿vale?. cll
#
#: user1.lsp:757
msgid " (y/n) "
msgstr " (si(y)/no(n)) "

#: user1.lsp:771
msgid "Please answer with y or n : "
msgstr "Por favor, responda con y(si) o n(no) : "

#: user1.lsp:786
msgid " (yes/no) "
msgstr " (si(yes)/no(no)) "

#: user1.lsp:799
msgid "Please answer with yes or no : "
msgstr "Por favor, responda con yes(si) o no(no) : "

#: user2.lsp:35
msgid "special form"
msgstr "forma especial"

#: user2.lsp:40
msgid "function"
msgstr "función"

#: user2.lsp:44
msgid "macro"
msgstr "macro"

#: user2.lsp:59
msgid "constant"
msgstr "constante"

#: user2.lsp:63
msgid "variable"
msgstr "variable"

#: user2.lsp:71
msgid "type"
msgstr "tipo"

#: user2.lsp:77
msgid "class"
msgstr "clase"

#: user2.lsp:92
msgid "~%Description of~%"
msgstr "~%Descripción de~%"

# Duda: ¡Atención! "This is" se debería traducir por "Este es" o "Esta
# es". Desgraciadamente, cuando se escribe este mensaje (que es el
# principio de una frase más larga) no se dispone de ninguna variable
# cuyo contenido se pueda examinar para comprobar si se debe usar el
# masculino o el femenino. Sin embargo, "Se trata de" queda al pelo.
#
# Para que lo veais, a continuación muestro dos sesiones diferentes
# donde "Se trata de" queda que ni pintado, ... (sin embargo, sustituid
# mentalmente por "Este es" o "Esta es" y vereis que el primer caso,
# necesariamente debería ser masculino y el segundo femenino):
#
# > (describe 'a)
#
# Descripción de
# A
# Se trata de el símbolo A.
# El símbolo está en el #<PACKAGE USER> y es accesible desde el paquete USER.
#
# > (describe '(a b c))
#
# Descripción de
# (A B C)
# Se trata de una lista de longitud 3.
#
#: user2.lsp:97
msgid "~%This is "
msgstr "~%Se trata de "

#: user2.lsp:119
msgid "a list of length ~S."
msgstr "una lista de longitud ~S."

#: user2.lsp:125
msgid "a dotted list of length ~S."
msgstr "una lista punteada de longitud ~S."

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: user2.lsp:130
msgid "a cons."
msgstr "un cons."

#: user2.lsp:134
msgid "a cyclic list."
msgstr "una lista cíclica."

#: user2.lsp:140
msgid "the empty list, "
msgstr "la lista vacía, "

#: user2.lsp:144
msgid "the symbol ~S"
msgstr "el símbolo ~S"

#: user2.lsp:150
msgid ", a keyword"
msgstr ", una palabra clave"

#: user2.lsp:156
msgid ", a constant"
msgstr ", una constante"

#: user2.lsp:161
msgid ", a variable declared SPECIAL"
msgstr ", una variable declarada SPECIAL"

#: user2.lsp:165
msgid ", a variable"
msgstr ", una variable"

#: user2.lsp:170
msgid " (macro)"
msgstr " (macro)"

#: user2.lsp:180
msgid ", names "
msgstr ", nombra "

#: user2.lsp:185
msgid "a special form"
msgstr "una forma especial"

# Sugerencia: definición de macro. sv
#
# Hmmm, ..., lo de macro definición es bastante típico en informática
# (ya sabes, ...) Sin embargo, en Lisp se suele decir definición de
# macro, tal y como tú propones, ..., pues vale, ¡sugerencia
# completamente aceptada! cll
#
#: user2.lsp:190
msgid " with macro definition"
msgstr " con definición de macro"

#: user2.lsp:195
msgid "a function"
msgstr "una función"

#: user2.lsp:203
msgid "a macro"
msgstr "una macro"

#: user2.lsp:212
msgid ", names a type"
msgstr ", nombra un tipo"

#: user2.lsp:220
msgid ", names a class"
msgstr ", nombra una clase"

#: user2.lsp:231
msgid ", has the propert~@P ~{~S~^, ~}"
msgstr ", tiene ~[~;la propiedad~:;las propiedades~] ~{~S~^, ~}"

#: user2.lsp:238 user2.lsp:280 user2.lsp:339 user2.lsp:448 user2.lsp:478 user2.lsp:621
msgid "."
msgstr "."

#: user2.lsp:242
msgid "~%The symbol "
msgstr "~%El símbolo "

#: user2.lsp:248
msgid "lies in ~S"
msgstr "está en el ~S"

# Duda: He traducido al estilo del mensaje en francés: "n'appartient à
# aucun paquetage"
#
#: user2.lsp:253
msgid "is uninterned"
msgstr "no aparece en ningún paquete"

# Nota: Caso brillante de la generación de mensajes diferentes gracias a las
#       directivas condicionales del Clisp (y del Common Lisp en general).
#
#: user2.lsp:274
msgid " and is accessible in the package~:[~;s~] ~{~A~^, ~}"
msgstr " y es accesible desde ~:[el paquete~;los paquetes~] ~{~A~^, ~}"

#: user2.lsp:285
msgid "an integer, uses ~S bits, is represented as a ~(~A~)."
msgstr "un entero que usa ~S bits y se representa como un ~(~A~)."

#: user2.lsp:291
msgid "a rational, not integral number."
msgstr "un racional, no un número entero."

#: user2.lsp:296
msgid "a float with ~S bits of mantissa (~(~A~))."
msgstr "un número en coma flotante con ~S bits de mantisa (~(~A~))."

#: user2.lsp:302
msgid "a complex number "
msgstr "un número complejo "

#: user2.lsp:310
msgid "at the origin"
msgstr "en el origen"

#: user2.lsp:314
msgid "on the ~:[posi~;nega~]tive real axis"
msgstr "en el eje real ~:[posi~;nega~]tivo"

#: user2.lsp:320
msgid "on the ~:[posi~;nega~]tive imaginary axis"
msgstr "en el eje imaginario ~:[posi~;nega~]tivo"

#: user2.lsp:325
msgid "in ~:[~:[first~;fourth~]~;~:[second~;third~]~] the quadrant"
msgstr "en el ~:[~:[primer~;cuarto~]~;~:[segundo~;tercer~]~] cuadrante"

# Si es lo que me imagino, tal vez sería mejor poner "del plano complejo".
# (como matemático que soy, me suena mejor :-). sv
#
# Pues sí, es exactamente lo que te imaginas, ..., "el plano de los números
# gaussianos" era una >>horrible<< traducción, ... ¡Gracias! cll
#
#: user2.lsp:330
msgid " of the Gaussian number plane."
msgstr " del plano complejo."

#: user2.lsp:335
msgid "a character"
msgstr "un carácter"

#: user2.lsp:343
msgid "~%It is a ~:[non-~;~]printable character."
msgstr "~% Se trata de un carácter ~:[no ~;~]imprimible."

#: user2.lsp:349
msgid "~%Its use is non-portable."
msgstr "~%Su utilización no es portable."

#: user2.lsp:356
msgid "a~:[n interpret~; compil~]ed function."
msgstr "una función ~:[interpret~;compil~]ada."

#: user2.lsp:369
msgid "~%argument list: ~S"
msgstr "~%lista de argumentos: ~S"

#: user2.lsp:376
msgid "~%documentation: ~A"
msgstr "~%documentación: ~A"

#: user2.lsp:386
msgid "a built-in system function."
msgstr "una función predefinida del sistema."

#: user2.lsp:396
msgid "a special form handler."
msgstr "un manipulador de forma especial."

#: user2.lsp:402
msgid "a foreign pointer"
msgstr "una puntero externo"

#: user2.lsp:408
msgid "a foreign address"
msgstr "una dirección externa"

#: user2.lsp:414
msgid "a foreign variable of foreign type ~S."
msgstr "una variable externa del tipo extranjero ~S."

#: user2.lsp:421
msgid "a foreign function."
msgstr "una función externa."

#: user2.lsp:428
msgid "a~:[~:[ closed ~;n output-~]~;~:[n input-~;n input/output-~]~]stream."
msgstr "un flujo ~:[~:[cerrado~;de salida~]~;~:[de entrada~;de entrada/salida~]~]."

#: user2.lsp:436
msgid "the package named ~A"
msgstr "el paquete ~A"

#: user2.lsp:443
msgid ". It has the nicknames ~{~A~^, ~}"
msgstr ". Tiene los apodos ~{~A~^, ~}"

# Duda: Debo comprobarlo en el código fuente de CLisp pero estoy casi
# seguro que esto es mucho mejor dejarlo sin traducir, ... cll
#
#: user2.lsp:454
msgid "~%It "
msgstr "~%"

#: user2.lsp:459
msgid "imports the external symbols of the package~:[~;s~] ~{~A~^, ~} and "
msgstr "importa los símbolos externos de~:[l paquete~; los paquetes~] ~{~A~^, ~} y "

#: user2.lsp:464
msgid "exports ~:[no symbols~;the symbols~:*~{~<~%~:; ~S~>~^~}~]"
msgstr "~:[no exporta ningún símbolo~;exporta los símbolos~:*~{~<~%~:; ~S~>~^~}~]"

#: user2.lsp:473
msgid " to the package~:[~;s~] ~{~A~^, ~}"
msgstr " ~:[al paquete~;a los paquetes~]: ~{~A~^, ~}"

#: user2.lsp:482
msgid "a deleted package."
msgstr "un paquete borrado."

#
# Nota: Muy, muy importante.
#
# En la `españolización' de CLisp, debe programarse de nuevo la
# directiva ~P, para que los plurales se formen añadiendo "es" si el
# argumento no es `eql' a 1.
#
# Asimismo, debieran revisarse otras directivas de `format' como, por
# ejemplo, ~@P, ~:R, etc.
#
# ¡¡Pues no!! Cuando le dije esto a Bruno Haible, él me dijo que el
# estándar Common Lisp - The Language, no contemplaba la realización de
# este tipo de directivas en otros idiomas, sino especificamente en
# inglés. Ni español, ni alemán, ni francés, ...
#
#: user2.lsp:487
msgid "a hash table with ~S entr~:@P."
msgstr "una tabla hash con ~S entrada~:*~[s~;~:;s~]."

# Este mensaje tiene una especial dificultad, porque de el deberían
# salir cosas del tipo: "una tabla de lectura" (con `tabla de lectura'
# al final del mensaje) o "la tabla de lectura de Common Lisp" (con
# `tabla de lectura' al principio).
#
# Afortunadamente, la situación puede salvarse sin ningún problema
# gracias a la directiva ~:* de format
#
#: user2.lsp:493
msgid "~:[a~;the Common Lisp~] readtable."
msgstr "~:[una~;la~] tabla de lectura~:*~:[~; de Common Lisp~]"

#: user2.lsp:499
msgid "a ~:[~;portable ~]pathname~:[.~;~:*, with the following components:~{~A~}~]"
msgstr "una trayectoria~:[~; portátil~]~:[.~;~:*, constituída por: ~{~A~}~]"

#: user2.lsp:519
msgid "a random-state."
msgstr "un estado aleatorio."

#: user2.lsp:524
msgid "a byte specifier, denoting the ~S bits starting at bit position ~S of an integer."
msgstr "un especificador de byte que denota los ~S bits que comienzan en el bit ~S de un entero"

#: user2.lsp:530
msgid "a load-time evaluation promise."
msgstr "una promesa de evaluación en tiempo de carga."

#: user2.lsp:535
msgid "a label used for resolving #~D# references during READ."
msgstr "una etiqueta para resolver #~D# referencias en READ."

#: user2.lsp:541
msgid "a pointer into the stack. It points to:"
msgstr "Un puntero a la pila. Apunta a:"

#: user2.lsp:548
msgid "a special-purpose object."
msgstr "un objeto de propósito especial."

#: user2.lsp:553
msgid "a machine address."
msgstr "una dirección de máquina."

#: user2.lsp:561
msgid "a structure of type ~S."
msgstr "una estructura del tipo ~S."

#: user2.lsp:568
msgid "~%As such, it is also a structure of type ~{~S~^, ~}."
msgstr "Como tal, también es una estructura del tipo ~{~S~^, ~}."

#: user2.lsp:577
msgid "an instance of the CLOS class ~S."
msgstr "una instancia de la clase CLOS ~S."

#: user2.lsp:588
msgid "a~:[~; simple~] ~A dimensional array"
msgstr "una matriz~:[~; simple~] de dimensión ~A"

#: user2.lsp:594
msgid " (vector)"
msgstr " (vector)"

#: user2.lsp:599
msgid " of ~(~A~)s"
msgstr " de ~(~A~)s"

#: user2.lsp:605
msgid ", adjustable"
msgstr ", ajustable"

#: user2.lsp:610
msgid ", of size ~{~S~^ x ~}"
msgstr ", de tamaño ~{~S~^ x ~}"

#: user2.lsp:616
msgid " and current length (fill-pointer) ~S"
msgstr " y longitud actual (fill-pointer) ~S"

#: user2.lsp:627
msgid "~%For more information, evaluate ~{~S~^ or ~}."
msgstr "~%Para más información, evalúe ~{~S~^ o ~}."

#: user2.lsp:669
msgid "~S: ~S is not a function."
msgstr "~S: ~S no es una función."

#: user2.lsp:677
msgid "~%argument list: "
msgstr "~%lista de argumentos: "

#: user2.lsp:768
msgid "~S: argument must be ~S, ~S or ~S, not ~S"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: user2.lsp:804 user2.lsp:984
msgid "Total"
msgstr "Total"

#: user2.lsp:814
msgid "~%Bytes permanently allocated:   ~9D~%Bytes currently in use:        ~9D~%Bytes available until next GC: ~9D~%"
msgstr "~%Bytes permanentemente asignados:   ~9D~%Bytes actualmente en uso:        ~9D~%Bytes disponibles hasta el próximo GC: ~9D~%"

# Nota: La utilización de dribbling viene de la función dribble de Lisp.
#       Dicha función graba una sesión Lisp en el archivo que se indique en la
#       llamada a la función.
#
# La traducción no juega, de esa manera, con las palabras.
#
#: user2.lsp:1009
msgid "Already dribbling to ~S"
msgstr "Ya se está grabando la sesión en ~S"

#: user2.lsp:1097
msgid "Currently not dribbling."
msgstr "En este momento, no se está grabando la sesión."

#: user2.lsp:1126
msgid "No external editor installed."
msgstr "No hay ningún editor externo instalado"

#: user2.lsp:1200
msgid "~S cannot be edited."
msgstr "~S no puede ser editado."

#: user2.lsp:1221
msgid "~S: source code for ~S not available."
msgstr "~S: el código fuente de ~S no está disponible."

#: user2.lsp:1530
msgid "~S: File ~S already exists"
msgstr "~S: El fichero ~S ya existe"

#: trace.lsp:85 trace.lsp:276
msgid "~S: function name should be a symbol, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

#: trace.lsp:97
msgid "~S: undefined function ~S"
msgstr "~S: la función ~S no está definida"

#: trace.lsp:105
msgid "~S: cannot trace special form ~S"
msgstr "~S: no es posible rastrear la forma especial ~S"

#: trace.lsp:118
msgid "~&;; Tracing ~:[function~;macro~] ~S."
msgstr "~&;; Rastreando la ~:[función~;macro~] ~S."

#: trace.lsp:294
msgid "~S: ~S was traced and has been redefined!"
msgstr "~S: ¡~S estaba siendo rastreada y ha sido redefinida!"

#: macros3.lsp:13
msgid ""
"The form ~S yielded ~:[no values~;~:*~{~S~^ ; ~}~] ,~@\n"
"                       that's not of type ~S."
msgstr ""
"La forma ~S ~:[no produjo ningún valor~;produjo ~:*~{~S~^ ; ~}~] ,~@\n"
"                       que no es del tipo ~S."

#: macros3.lsp:68
msgid "LETF* code contains a dotted list, ending with ~S"
msgstr "El código del LETF* contiene una lista punteada que termina con ~S"

#: macros3.lsp:89
msgid "illegal syntax in LETF* binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF*: ~S"

#: macros3.lsp:235
msgid "LETF code contains a dotted list, ending with ~S"
msgstr "El código de LETF contiene una lista punteada que termina con ~S"

#: macros3.lsp:256
msgid "illegal syntax in LETF binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF: ~S"

# Este es el formato de las fechas, ... Lo he cogido de la traducción
# alemana y de la francesa, donde es al contrario que la inglesa.
#
#: compiler.lsp:217
msgid "~1{~5@*~D/~4@*~D/~3@*~D ~2@*~2,'0D.~1@*~2,'0D.~0@*~2,'0D~:}"
msgstr "~1{~3@*~D/~4@*~D/~5@*~D ~2@*~2,'0D:~1@*~2,'0D:~0@*~2,'0D~:}"

# Duda: En Lisp, todo el mundo sabe lo que es un `closure'. Bueno, me parece
#       que la mejor traducción es `cierre'.
#
# He visto que los traductores del libro Lisp (3ra edición), de Winston
# y Horn, dicen al final de la página 234 y principio de la 235: "Los
# procedimientos objeto, producidos a partir de una combinación de #' y
# lambda se denominan cerraduras léxicas. El término es usado porque la
# palabra cerradura sugiere que se están involucrando cercas, en tanto
# que la palabra léxica sugiere que las cercas son colocadas de acuerdo
# con las reglas del alcance léxico (o visibilidad) (...) Como no existe
# una forma impresa conveniente para la información de las cercas, la
# forma impresa de una cerradura léxica, sin ser clara, aparecería como:
# #<CERRADURA LÉXICA ...>." Pues bien, propongo que cuando se hagan
# referencias al léxico se diga "cerradura léxica" y, en otro caso,
# "cerradura".
#
# Estos términos me parecen mejores que "cierre léxico" o "cierre" - cll
#
#: compiler.lsp:359
msgid "Bad length of closure vector: ~S"
msgstr "Longitud incorrecta del vector de cerradura: ~S"

# Aquí también junto las exclamaciones. sv
#: compiler.lsp:1747
msgid "Compiler bug!! Occurred in ~A~@[ at ~A~]."
msgstr "¡¡Error del compilador!! Ocurrió en ~A~@[ en ~A~]."

# Soy alérgico al verbo "ignorar". Ignorar en español significa no saber.
# Y eso en inglés se dice "not to know".
# Posibilidades: Descartar, no tener en cuenta. sv
#
# :) Bueno, ... :) Lo cierto es que en el diccionario pone:
#
# "No saber una cosa o muchas cosas, o, de lo contrario, no tener
# noticia de ellas."
#
# O sea, que algo se ignora si no se tienen noticias de ello, ... Creo
# que la traducción está, por lo tanto, correcta. Ahora bien, "no tener
# en cuenta" o "descartar" también me parece muy correcto así que, ¿por
# qué no iba a cambiarlo? :) cll
#
#: compiler.lsp:2425
msgid "Bad declaration syntax: ~S~%Will be ignored."
msgstr "Sintaxis de la declaración incorrecta:~S~%No se tendrá en cuenta."

#: compiler.lsp:2447
msgid "Non-symbol ~S may not be declared SPECIAL."
msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#: compiler.lsp:2456
msgid "Non-symbol ~S may not be declared IGNORE."
msgstr "El \"no símbolo\" ~S no debe declararse IGNORE."

#: compiler.lsp:2465
msgid "Non-symbol ~S may not be declared IGNORABLE."
msgstr "El \"no-símbolo\" ~S no debe declararse IGNORABLE."

#: compiler.lsp:2474
#, fuzzy
msgid "Non-symbol ~S may not be declared READ-ONLY."
msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#: compiler.lsp:2481
msgid "Unknown declaration ~S.~%The whole declaration will be ignored."
msgstr "Declaración desconocida ~S.~%La declaración completa será ignorada."

#: compiler.lsp:2815
msgid " in line ~D"
msgstr " en la línea ~D"

#: compiler.lsp:2818
msgid " in lines ~D..~D"
msgstr " en las líneas ~D..~D"

#
# Duda: He querido traducir la palabra `warning' por `aviso' que es como
# debería decirse en español, ¿no?. ¿Hay algún término adoptado en
# es@li.org, para esta palabra?.
#
# Sí, atención. sv
#
# Si, si, ya lo he hecho, ... En todas partes he puesto "WARNING" por
# "ATENCIÓN". No es exactamente lo mismo, pero me parece una sugerencia
# genial, de hecho me gusta muchísimo más que aquello de "AVISO:". De
# esta manera, parecía que te estaban hablando los "super-tacañones" :) - cll
#
# Sin embargo, Santiago, este caso es bastante peculiar. Verás, si dejo
# "ATENCIÓN" aquí, entonces, durante la compilación de un proyecto con
# varios ficheros en Lisp, podría salir, por ejemplo, un mensaje como el
# siguiente (tomado de un ejemplo real, que conste, ...):
#
# --------------
# ATENCIÓN en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
# Y yo pregunto, en este caso ¿no es mejor poner "ADVERTENCIA"? La
# verdad es que "ADVERTENCIA" me suena mucho mejor que "ATENCIÓN" y que
# "AVISO". En este caso, lo que se tendría es:
#
# --------------
# ADVERTENCIA en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
#
#: compiler.lsp:2832
msgid "~%WARNING~@[ in function ~S~]~A :~%"
msgstr "~%ADVERTENCIA~@[ en la función ~S~]~A :~%"

#: compiler.lsp:2858
msgid "~%ERROR~@[ in function ~S~]~A :~%~?"
msgstr "~% ERROR~@[ en la función ~S~]~A : ~%~?"

#: compiler.lsp:3002
msgid "Code contains dotted list ~S"
msgstr "El código contiene la lista punteada ~S"

# En ocasiones como esta hemos puesto a veces:
# "insuficiente número de argumentos" sv
#
# ¡Pues no me gusta nada!, todavía si dijeses "número insuficiente de
# argumentos". No se, ..., la verdad es que a mí me gusta mucho más "muy
# pocos argumentos" o, si quieres, "pocos argumentos" pero eso de la
# "insuficiencia", ... (me trae otros recuerdos). cll
#
#: compiler.lsp:3008
msgid "Form too short, too few arguments: ~S"
msgstr "Forma demasiado corta, muy pocos argumentos: ~S"

#: compiler.lsp:3015
msgid "Form too long, too many arguments: ~S"
msgstr "Forma demasiado larga, demasiados argumentos: ~S"

#: compiler.lsp:3151
msgid "Invalid form: ~S"
msgstr "La forma ~S es inválida"

# Añado lo que faltaba. sv
#
# Hmmm, ¿se me olvidó algo?. Atención, jóvenes traductores: recordad que
# hay un momento en el que es necesario parar de trabajar, ..., la
# cabeza puede llegar a dar muchas vueltas :) cll
#
#: compiler.lsp:3205
msgid "Not the name of a function: ~S"
msgstr "No es el nombre de una función: ~S"

#: compiler.lsp:3282 compiler.lsp:3366
msgid ""
"~S is neither declared nor bound,~@\n"
"                        it will be treated as if it were declared SPECIAL."
msgstr ""
"~S no está ni declarado ni ligado,~@\n"
"                        será tratado como si hubiese sido declarado SPECIAL."

#: compiler.lsp:3387
msgid ""
"The constant ~S may not be assigned to.~@\n"
"                                                  The assignment will be ignored."
msgstr ""
"La constante ~S no puede asignarse. ~@\n"
"                                                  La asignación será ignorada."

#: compiler.lsp:3533
msgid "argument list to function ~S is dotted: ~S"
msgstr "el argumento de la función ~S es una lista punteada: ~S"

#: compiler.lsp:3541
msgid ""
"~S called with ~S~:[~; or more~] arguments, but it requires ~\n"
"                        ~:[~:[from ~S to ~S~;~S~]~;at least ~*~S~] arguments."
msgstr ""
"~S fue invocado con ~S~:[~; o más~] argumentos, pero requiere ~\n"
"                        ~:[~:[de ~S a ~S~;~S~]~;al menos ~*~S~] argumentos."

#: compiler.lsp:3558
msgid "keyword arguments to function ~S should occur pairwise: ~S"
msgstr "los argumentos clave de la función ~S deben aparecer por pares: ~S"

#
# Afortunadamente, la convención ~#[, para imprimir los términos de una
# lista (en inglés, como dice el estándar) sirve perfectamente para el
# español
#
#: compiler.lsp:3571
msgid ""
"keyword ~S is not allowed for function ~S.~\n"
"                              ~%The only allowed keyword~:[s are ~{~S~#[~; and ~S~:;, ~]~}~; is ~{~S~}~]."
msgstr ""
"la palabra clave ~S no está permitida en la función ~S.~\n"
"                              ~%La~:[s~;~] única~:*~:[s~;~] palabra~:*~:[s~;~] clave permitida~:*~:[s son ~{~S~#[~; y ~S~:;, ~]~}~; es ~{~S~}~]."

#: compiler.lsp:3587
msgid "argument ~S to function ~S is not a keyword"
msgstr "el argumento ~S para la función ~S no es un argumento clave"

#: compiler.lsp:4245
msgid ""
"~S called with ~S arguments, but it requires ~\n"
"                                   ~:[~:[from ~S to ~S~;~S~]~;at least ~*~S~] arguments."
msgstr ""
"~S ha sido invocado con ~S argumentos, pero requiere ~\n"
"                                   ~:[~:[de ~S a ~S~;~S~]~;al menos ~*~S~] argumentos."

#: compiler.lsp:4426
msgid "Illegal syntax in LET/LET*: ~S"
msgstr "Sintaxis inválida en LET/LET*: ~S"

#: compiler.lsp:4465
msgid "Lambda list marker ~S not allowed here."
msgstr "El marcador de la lista lambda ~S no está permitido aquí."

#: compiler.lsp:4473
msgid "Missing &REST parameter in lambda list ~S"
msgstr "La lista lambda ~S necesita un parámetro &REST"

#: compiler.lsp:4481
msgid "Lambda list element ~S is superfluous."
msgstr "El elemento ~S de la lista lambda es innecesario."

#: compiler.lsp:4658
msgid "Lambda lists with dots are only allowed in macros, not here: ~S"
msgstr "Sólo se permiten las listas lambda con puntos en la macros, no aquí: ~S"

#: compiler.lsp:4676
msgid "Illegal lambda list element ~S"
msgstr "Elemento inválido en lista lambda ~S"

#: compiler.lsp:4774
msgid "Binding variable ~S can cause side effects despite of IGNORE declaration~%since it is declared SPECIAL."
msgstr "Asociar la variable ~S puede causar otros efectos, a pesar de la declaración~%IGNORE puesto que está declarada como SPECIAL."

#: compiler.lsp:4780
msgid "variable ~S is used despite of IGNORE declaration."
msgstr "La variable ~S está siendo usada a pesar de la declaración IGNORE."

#: compiler.lsp:4793
msgid "variable ~S is not used.~%Misspelled or missing IGNORE declaration?"
msgstr "La variable ~S no está siendo usada.~%¿Está mal escrita o es que falta la declaración IGNORE?"

#: compiler.lsp:4801
#, fuzzy
msgid "The variable ~S is assigned to, despite of READ-ONLY declaration."
msgstr "La variable ~S está siendo usada a pesar de la declaración IGNORE."

#: compiler.lsp:4849 compiler.lsp:4987
msgid "Constant ~S cannot be bound."
msgstr "La constante ~S no puede ligarse."

#: compiler.lsp:5728
msgid "Misplaced declaration: ~S"
msgstr "Declaración situada incorrectamente: ~S"

#: compiler.lsp:5942
msgid "Odd number of arguments to SETQ: ~S"
msgstr "Número impar de argumentos de SETQ: ~S"

#: compiler.lsp:5981 compiler.lsp:6022 compiler.lsp:6122
msgid "Cannot assign to non-symbol ~S."
msgstr "No se puede asignar a un \"no-símbolo\" ~S."

#: compiler.lsp:5995
msgid "Odd number of arguments to PSETQ: ~S"
msgstr "Número impar de argumentos de PSETQ: ~S"

#: compiler.lsp:6262
msgid "Only symbols may be used as variables, not ~S"
msgstr "Sólo pueden usarse los símbolos como variables, no ~S"

#: compiler.lsp:6369
msgid "Illegal syntax in COMPILER-LET: ~S"
msgstr "Sintaxis inválida en COMPILER-LET: ~S"

#: compiler.lsp:6379
msgid "Block name must be a symbol, not ~S"
msgstr "El nombre de un bloque debe ser un símbolo, no ~S"

#: compiler.lsp:6430
msgid "RETURN-FROM block ~S is impossible from here."
msgstr "No es posible hacer RETURN-FROM del bloque ~S desde aquí."

#: compiler.lsp:6503
msgid "Only numbers and symbols are valid tags, not ~S"
msgstr "Sólo son etiquetas de salto válidas los números y los símbolos, no ~S"

#: compiler.lsp:6576
msgid "Tag must be a symbol or a number, not ~S"
msgstr "Una etiqueta de salto debe ser un símbolo o un número, no ~S"

#: compiler.lsp:6583
msgid "GO to tag ~S is impossible from here."
msgstr "No es posible ir (GO) a la etiqueta de salto ~S desde aquí."

#: compiler.lsp:6660
msgid "~S is not a function. It is a locally defined macro."
msgstr "~S no es una función. Se trata de una macro definida localmente."

#: compiler.lsp:6698
msgid "Only symbols and lambda expressions are function names, not ~S"
msgstr "Sólo los símbolos y las expresiones lambda son nombres de funciones válidos, no ~S"

#: compiler.lsp:6751
msgid "Illegal function definition syntax in ~S: ~S"
msgstr "La sintaxis para la definición de la función en ~S es inválida: ~S"

#: compiler.lsp:7193
msgid "Illegal syntax in SYMBOL-MACROLET: ~S"
msgstr "Sintaxis inválida en SYMBOL-MACROLET: ~S"

# Duda: He traducido `EVAL-WHEN situation' por `instante de EVAL-WHEN',
# puesto que el primer argumento de EVAL-WHEN es el *instante* en el que
# debe evaluarse la expresión que viene a continuación y, que de hecho,
# puede ser ---como dice el mensaje--- EVAL, LOAD o COMPILE.
#
#: compiler.lsp:7240
msgid "EVAL-WHEN situation must be EVAL or LOAD or COMPILE, but not ~S"
msgstr "El instante de EVAL-WHEN debe ser EVAL, LOAD o COMPILE, pero no ~S"

#: compiler.lsp:7287
msgid "CASE clause without objects: ~S"
msgstr "Cláusula CASE sin objetos: ~S"

#: compiler.lsp:7299
msgid "~S: the ~S clause must be the last one: ~S"
msgstr "~S: la clausula ~S debe ser la última: ~S"

#: compiler.lsp:7311
msgid "Duplicate ~S label ~S : ~S"
msgstr "~S : La etiqueta ~S se repite: ~S"

#: compiler.lsp:7575
msgid "Too many arguments to ~S"
msgstr "Demasiados argumentos para ~S"

#: compiler.lsp:7592
msgid "Too few arguments to ~S"
msgstr "Muy pocos argumentos para ~S"

# eso de función "a compilar" siempre
# me pareció un vicio moderno.
# Sugerencia: El nombre de la función que hay que compilar ... sv
#
# Perfecto, ... cll
#
#: compiler.lsp:12075
msgid "Name of function to be compiled must be a symbol, not ~S"
msgstr "El nombre de una función que hay que compilar debe ser un símbolo, no ~S"

#: compiler.lsp:12088
msgid "~S: redefining ~S; it was traced!"
msgstr "~S: redefiniendo ~S; ¡estaba siendo rastreada!"

#: compiler.lsp:12098 compiler.lsp:12135
msgid "~S is already compiled."
msgstr "~S ya está compilada."

#: compiler.lsp:12121 compiler.lsp:12718
msgid "Undefined function ~S"
msgstr "La función ~S no está definida"

# Sugerencia: No es blabla ni bla bla. sv
# El ni se ponía la segunda pero no la primera vez, ¿no?
#
# ¡No, hombre, no! Creo que estas equivocado, ..., en el diccionario
# Larousse de Inglés-Español pone:
#
# "nor conj. Ni: he is neither big nor small, no es ni grande ni
# pequeño; neither you nor I, ni tú ni yo || ..."
#
# O sea, que es " ... ni ... ni ..." cll
#
#: compiler.lsp:12146
msgid "Not a lambda expression nor a function: ~S"
msgstr "Ni es una expresión lambda ni es una función: ~S"

#: compiler.lsp:12367
msgid "~&Listing of compilation of file ~A~%on ~@? by ~A, version ~A"
msgstr "~&Listado de la compilación del fichero ~A~%el ~@? por ~A, versión ~A"

#: compiler.lsp:12412
msgid "~%Compiling file ~A ..."
msgstr "~%Compilando el fichero ~A ..."

#: compiler.lsp:12436
msgid "~&~%Compilation of file ~A is finished."
msgstr "~&~%La compilación del fichero ~A ha finalizado."

#
# Duda: ¡atención a la utilización de la directiva ~P!
#
# La siguiente traducción funcionará si, para el caso del español (como
# para el alemán), se pasa el parámetro (eql *error-count* 1), en
# segundo lugar.
#
# Ya no hace falta. Tal y como está hecho no es necesario pasar ningún
# parámetro extra. Así funciona correctamente.
#
# Aquí dudo porque atención no es tan "pluralizable" como aviso. sv
#
# Claro, de hecho, a mí también me pasa lo mismo. He preferido cambiar
# la traducción de "aviso" por "advertencia", en este mensaje y en aquél
# en el que se sacan los mensajes del compilador. ¿No os suena muchísimo
# mejor esta segunda alternativa? - cll
#
#: compiler.lsp:12441
msgid "~%~D error~:P, ~D warning~:P"
msgstr "~%~D error~:*~[es~;~:;es~], ~D advertencia~:P"

#: compiler.lsp:12448
msgid "~%There were errors in the following functions:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Ha habido errores en las siguientes funciones:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12457
msgid "~%The following functions were used but not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes funciones han sido utilizadas pero no definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12465
msgid "~%The following special variables were not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes variables especiales no han sido definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12471
msgid "~%The following special variables were defined too late:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes variables especiales fueron definidas demasiado tarde:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12477
msgid "~%The following functions were used but are deprecated:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes funciones han sido utilizadas pero no aprobadas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12536
msgid "~%~%Disassembly of function ~S"
msgstr "Desensamblado de la función ~S"

#: compiler.lsp:12549
msgid "~%~S required arguments"
msgstr "~%~S argumentos obligatorios"

#: compiler.lsp:12554
msgid "~%~S optional arguments"
msgstr "~%~S argumentos opcionales"

#: compiler.lsp:12559
msgid "~%~:[No rest parameter~;Rest parameter~]"
msgstr "~%~:[Sin parámetro resto~;Parámetro resto~]"

#: compiler.lsp:12566
msgid "~%~S keyword parameter~:P: ~{~S~^, ~}."
msgstr "~%~S parámetro~:P clave: ~{~S~^, ~}."

#: compiler.lsp:12572
msgid "~%Other keywords are allowed."
msgstr "~%Se permiten otros parámetros clave."

#: compiler.lsp:12576
msgid "~%No keyword parameters"
msgstr "~%Sin parámetros clave"

#: compiler.lsp:12595
msgid "Disassembly of function "
msgstr "Desensamblado de la función "

#: compiler.lsp:12615
msgid " required arguments"
msgstr " argumentos obligatorios"

#: compiler.lsp:12622
msgid " optional arguments"
msgstr " argumentos opcionales"

#: compiler.lsp:12629
msgid "Rest parameter"
msgstr "Parámetro resto"

#: compiler.lsp:12634
msgid "No rest parameter"
msgstr "Sin parámetro de resto"

#
# ¡¡Atención a la utilización de la directiva ~P!!
#
# Bueno, en este caso es perfecta :) No hay ningún problema de ningún
# tipo
#
#: compiler.lsp:12643
msgid " keyword parameter~P: "
msgstr "parámetro~P clave: "

#: compiler.lsp:12655
msgid "Other keywords are allowed."
msgstr "Se permiten otras palabras clave."

#: compiler.lsp:12662
msgid "No keyword parameters"
msgstr "Sin parámetros clave"

#: compiler.lsp:12743
msgid "Cannot disassemble ~S"
msgstr "No se puede desensamblar ~S"

#: defs2.lsp:63
msgid "~S: ~S is not a function"
msgstr "~S: ~S no es una función"

#: defs2.lsp:79
msgid "~S: package name ~S should be a string or a symbol"
msgstr "~S: el nombre del paquete ~S debe ser una cadena de caracteres o un símbolo"

#: defs2.lsp:88
msgid "~S ~A: symbol name ~S should be a string or a symbol"
msgstr "~S ~A: el nombre del símbolo ~S debe ser una cadena de caracteres o un símbolo"

#: defs2.lsp:110
msgid "~S ~A: the symbol ~A must not be specified more than once"
msgstr "~S ~A: el símbolo ~A no debe especificarse más de una vez"

#: defs2.lsp:126 defs2.lsp:136
msgid "~S ~A: the ~S option must not be given more than once"
msgstr "~S ~A: no se debe poner la opción ~S más de una vez"

#: defs2.lsp:182
msgid "~S ~A: unknown option ~S"
msgstr "~S ~A: la opción ~S es desconocida"

#: defs2.lsp:188
msgid "~S ~A: invalid syntax in ~S option: ~S"
msgstr "~S ~A: la sintaxis de la opción ~S es inválida: ~S"

#: defs2.lsp:194
msgid "~S ~A: not a ~S option: ~S"
msgstr "~S ~A: no se trata de una opción ~S: ~S"

#: defs2.lsp:252
msgid "This symbol will be created."
msgstr "Este símbolo será creado."

#: defs2.lsp:255
msgid "~S ~A: There is no symbol ~A::~A ."
msgstr "~S ~A: El símbolo ~A::~A no existe."

#: defs2.lsp:285
msgid "~S: the name of a symbol macro must be a symbol, not ~S"
msgstr "~S: el nombre de un símbolo de macro debe ser un símbolo, no ~S"

#: defs2.lsp:303
msgid "~S: the symbol ~S names a global variable"
msgstr "~S: el símbolo ~S nombra una variable global"

#: defs2.lsp:363
msgid "The object to be destructured should be a list with ~:[at least ~*~S~;~:[from ~S to ~S~;~S~]~] elements, not ~4@*~S."
msgstr "Los objetos a desmontar deben ser una lista ~:[con al menos ~*~S~;de ~:[~S a ~S~;~S~]~] elementos, y no ~4@*~S."

#: defs2.lsp:434
msgid "~S: macro name should be a symbol, not ~S"
msgstr "~S: el nombre de una macro debe ser un símbolo, no ~S"

#: defs2.lsp:471
msgid "~S: input stream ~S ends within read macro beginning to ~S"
msgstr "~S: el flujo de entrada ~S ha terminado durante el procesamiento de una macro de lectura que empezaba en ~S"

#: defs2.lsp:479
#, fuzzy
msgid "~S from ~S: character read should be a character: ~S"
msgstr "~S en ~S: el carácter leído debe ser un STRING-CHAR: ~S"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: defs2.lsp:497
msgid "~S from ~S: After ~S is ~S an undefined dispatch macro character"
msgstr "~S en ~S: Después de ~S está ~S, un macro carácter sencundario indefinido"

#: defs2.lsp:565 defs2.lsp:582
msgid "~S: ~S of ~S is ambiguous. Please use ~S or ~S."
msgstr ""

#: loop.lsp:47
msgid "~S: syntax error after ~A in ~S"
msgstr "~S: error de sintaxis después de ~A en ~S"

#: loop.lsp:259
#, fuzzy
msgid "~S: missing variable."
msgstr "~S: variable ausente"

#: loop.lsp:272
msgid "~S: After ~S, ~S is interpreted as a type specification"
msgstr "~S: Después de ~S, ~S es interpretado como una especificación de tipo"

#: loop.lsp:553
msgid "~S: ~A clauses should occur before the loop's main body"
msgstr "~S: las claúsulas ~A deben aparecer antes del cuerpo principal del bucle"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lsp:718
msgid "~S: After ~S a plural loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un plural, y no ~A"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lsp:727
msgid "~S: After ~S a singular loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un singular, y no ~A"

#: loop.lsp:878
msgid "~S: questionable iteration direction after ~A"
msgstr "~S: dirección incierta de la iteración después de ~A"

#: loop.lsp:892
msgid "~S: specifying ~A requires FROM or DOWNFROM"
msgstr "~S: especificar ~A requiere FROM o DOWNFROM"

#: loop.lsp:983
msgid "~S: illegal syntax near ~S in ~S"
msgstr "~S: sintaxis inválida cerca de ~S en ~S"

#: loop.lsp:992
msgid "~S: ambiguous result of loop ~S"
msgstr "~S: el resultado del bucle ~S es ambiguo"

#: loop.lsp:1155
msgid "~S is possible only from within ~S"
msgstr "~S sólo es posible desde ~S"

#: loop.lsp:1161
msgid "Use of ~S in FINALLY clauses is deprecated because it can lead to infinite loops."
msgstr "La utilización de ~S en las cláusulas FINALLY está desaconsejada puesto que puede provocar bucles infinitos"

#: loop.lsp:1167
msgid "~S is not possible here"
msgstr "~S es imposible aquí"

#: clos.lsp:166 clos.lsp:191
msgid "~S: argument ~S is not a symbol"
msgstr "~S: el argumento ~S no es un símbolo"

#: clos.lsp:175
msgid "~S: ~S does not name a class"
msgstr "~S: ~S no nombra una clase"

#: clos.lsp:199
msgid "~S: ~S is not a class"
msgstr "~S: ~S no es una clase"

#: clos.lsp:208
msgid "~S: cannot redefine built-in class ~S"
msgstr "~S: no se puede redefinir la clase predefinida ~S"

#: clos.lsp:217
msgid "~S: Redefining the COMMON LISP class ~S"
msgstr "~S: Redefiniendo la clase de COMMON LISP ~S"

#: clos.lsp:374
msgid "instance ~S of class ~S has no slots (wrong metaclass)"
msgstr "la instancia ~S de la clase ~S no tiene ranuras (metaclase errónea)"

#: clos.lsp:397 clos.lsp:450
msgid "~S: not a list of slots: ~S"
msgstr "~S: no es una lista de ranuras: ~S"

#: clos.lsp:407
msgid "~S: invalid slot and variable specification ~S"
msgstr "~S: especificación inválida de ranura y variable: ~S"

#: clos.lsp:415 clos.lsp:465
msgid "~S: variable ~S should be a symbol"
msgstr "~S: la variable ~S debe ser un símbolo"

#: clos.lsp:423
msgid "~S: slot name ~S should be a symbol"
msgstr "~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos.lsp:458
msgid "~S: invalid slot and accessor specification ~S"
msgstr "~S: especificación inválida de ranura y función de acceso: ~S"

#: clos.lsp:472
msgid "~S: accessor name ~S should be a symbol"
msgstr "~S: el nombre de la función de acceso ~S debe ser un símbolo"

#: clos.lsp:565
msgid "~S: class name ~S should be a symbol"
msgstr "~S: el nombre de la clase ~S debe ser un símbolo"

#: clos.lsp:574
msgid "~S ~S: expecting list of superclasses instead of ~S"
msgstr "~S ~S: se esperaba una lista de superclases en vez de ~S"

#: clos.lsp:582
msgid "~S ~S: superclass name ~S should be a symbol"
msgstr "~S ~S: el nombre de la superclase ~S debe ser un símbolo"

#: clos.lsp:596
msgid "~S ~S: expecting list of slot specifications instead of ~S"
msgstr "~S ~S: se esperaba una lista de especificación de ranuras en vez de ~S"

#: clos.lsp:608
msgid "~S ~S: slot name ~S should be a symbol"
msgstr "~S ~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos.lsp:615
msgid "~S ~S: There may be only one direct slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura directa con el nombre ~S."

#: clos.lsp:632
msgid "~S ~S: slot options for slot ~S don't come in pairs"
msgstr "~S ~S: las opciones de ranura para ~S no aparecen por pares"

#: clos.lsp:645
msgid "~S ~S, slot option for slot ~S: ~S is not a function name"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una función"

#: clos.lsp:657 clos.lsp:685
msgid "~S ~S, slot option for slot ~S: ~S is not a symbol"
msgstr "~S ~S, opción de ranura para ~S: ~S no es un símbolo"

#: clos.lsp:669 clos.lsp:695 clos.lsp:706 clos.lsp:716
msgid "~S ~S, slot option ~S for slot ~S may only be given once"
msgstr "~S ~S, la opción de ranura ~S para ~S solo debe indicarse una vez"

#: clos.lsp:677
msgid "~S ~S, slot option for slot ~S must have the value ~S or ~S, not ~S"
msgstr "~S ~S, la opción de ranura para ~S debe tener el valor ~S o ~S, y no ~S"

#: clos.lsp:723
msgid "~S ~S, slot option for slot ~S: ~S is not a string"
msgstr "~S ~S, opción de ranura para ~S: ~S no es una cadena de caracteres"

#: clos.lsp:732
msgid "~S ~S, slot option for slot ~S: ~S is not a valid slot option"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una opción de ranura válida"

#: clos.lsp:785
msgid "~S ~S, option ~S may only be given once"
msgstr "~S ~S, la opción ~S sólo se puede indicar una vez"

#: clos.lsp:796 clos.lsp:829
msgid "~S ~S, option ~S: ~S is not a symbol"
msgstr "~S ~S, opción ~S: ~S no es un símbolo"

#: clos.lsp:809
msgid "~S ~S: option ~S should be written ~S"
msgstr "~S ~S: la opción ~S debe escribirse como ~S"

#: clos.lsp:816
msgid "~S ~S, option ~S: arguments don't come in pairs"
msgstr "~S ~S, opción ~S: los argumentos no aparecen en pares"

#: clos.lsp:836
msgid "~S ~S, option ~S: ~S may only be given once"
msgstr "~S ~S, opción ~S: ~S sólo se puede poner una vez"

#: clos.lsp:858
msgid "~S ~S, option ~S: ~S is not a string"
msgstr "~S ~S, opción ~S: ~S no es una cadena de caracteres"

#: clos.lsp:869
msgid "~S ~S: invalid option ~S"
msgstr "~S ~S: la opción ~S es inválida"

#: clos.lsp:978
msgid "~S: Class ~S is being redefined, instances are obsolete"
msgstr "~S: La clase ~S ha sido redefinida, las instancias son obsoletas"

#: clos.lsp:1062
msgid "~S ~S: superclass ~S should belong to class STANDARD-CLASS"
msgstr "~S ~S: la superclase ~S debe pertenecer a la clase STANDARD-CLASS"

#: clos.lsp:1234
msgid "~S ~S: inconsistent precedence graph, cycle ~S"
msgstr "~S ~S: grafo de precedencia inconsistente, ciclo ~S"

#: clos.lsp:1275
msgid "(class-precedence-list ~S) and (class-precedence-list ~S) are inconsistent"
msgstr "(class-precedence-list ~S) y (class-precedence-list ~S) son inconsistentes"

#: clos.lsp:1433
msgid "~S: superclass ~S should belong to class BUILT-IN-CLASS"
msgstr "~S: la superclase ~S debe pertenecer a la clase BUILT-IN-CLASS"

#: clos.lsp:1477
msgid "~S: metaclass STRUCTURE-CLASS forbids more than one direct superclass"
msgstr "~S: la metaclase STRUCTURE-CLASS prohibe más de una superclase directa"

#: clos.lsp:1484
msgid "~S: superclass ~S should belong to class STRUCTURE-CLASS"
msgstr "~S: la superclase ~S debe pertenecer a la clase STRUCTURE-CLASS"

#: clos.lsp:1526
msgid "~S: metaclass STRUCTURE-CLASS does not support shared slots"
msgstr "~S: la metaclase STRUCTURE-CLASS no mantiene ranuras compartidas"

#: clos.lsp:1801
msgid "~S ~S: missing lambda list"
msgstr "~S ~S: falta la lista lambda"

#: clos.lsp:1815
msgid "STANDARD method combination doesn't allow the method qualifiers to be ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos.lsp:1970 clos.lsp:1977
msgid "~S ~S: ~S is invalid within ~S methods"
msgstr "~S ~S: ~S es inválido dentro de los métodos ~S"

#: clos.lsp:2229
msgid "Too few arguments to ~S: ~S"
msgstr "Muy pocos argumentos para ~S: ~S"

#: clos.lsp:2356
msgid "The generic function ~S is being modified, but has already been called."
msgstr "La función genérica ~S está siendo modificada, pero ya ha sido invocada."

#: clos.lsp:2921
msgid "~S in ~S: the new arguments ~S have a different effective method than the old arguments ~S"
msgstr "~S en ~S: los argumentos nuevos ~S tienen un método en vigor diferente que los argumentos antiguos ~S"

#: clos.lsp:2944
msgid "~S has ~S, but ~S has ~S required parameters"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros obligatorios"

#: clos.lsp:2951
msgid "~S has ~S, but ~S has ~S optional parameters"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros opcionales"

#: clos.lsp:2958 clos.lsp:2965
msgid "~S has &REST or &KEY, but ~S hasn't."
msgstr "~S tiene parámetros &REST o &KEY, pero ~S no."

#: clos.lsp:2979
msgid "~S doesn't accept the keywords ~S of ~S"
msgstr "~S no acepta las palabras clave ~S de ~S"

#: clos.lsp:3009
msgid "Replacing method ~S in ~S"
msgstr "Reemplazando el método ~S de ~S"

#: clos.lsp:3029
msgid "Removing method ~S in ~S"
msgstr "Borrando el método ~S de ~S"

#: clos.lsp:3058
msgid "~S has no method with qualifiers ~:S and specializers ~S"
msgstr "~S no tiene ningún método con cualificadores ~:S y especializadores ~S"

#: clos.lsp:3091 clos.lsp:3436
msgid "~S doesn't name a generic function"
msgstr "~S no es una función genérica"

#: clos.lsp:3159
msgid "~S ~S: Only ~S declarations are permitted: ~S"
msgstr "~S ~S: Sólo la declaraciones ~S están permitidas: ~S"

#: clos.lsp:3170
msgid "~S ~S: ~S may only be specified once."
msgstr "~S ~S: ~S sólo puede especificarse una vez."

#: clos.lsp:3180
msgid "~S ~S: A string must be specified after ~S : ~S"
msgstr "~S ~S: Debe especificarse una cadena de caracteres después de ~S: ~S"

#: clos.lsp:3187
msgid "~S ~S: Only one ~S string is allowed"
msgstr "~S ~S: Sólo se permite una cadena de caracteres ~S"

#: clos.lsp:3197
msgid "~S ~S: The only valid method combination is ~S : ~S"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos.lsp:3207
msgid "~S ~S: The only valid generic function class name is ~S : ~S"
msgstr "~S ~S: El único nombre válido de una clase de función genérica es ~S : ~S"

#: clos.lsp:3217
msgid "~S ~S: The only valid method class name is ~S : ~S"
msgstr "~S ~S: El único nombre válido de una clase de métodos es ~S : ~S"

#: clos.lsp:3240
msgid "~S ~S: ~S is not one of the required parameters: ~S"
msgstr "~S ~S: ~S no es uno de los parámetros obligatorios: ~S"

#: clos.lsp:3254
msgid "~S ~S: some variable occurs twice in ~S"
msgstr "~S ~S: alguna variable ha aparecido dos veces en ~S"

#: clos.lsp:3261
msgid "~S ~S: ~S is missing some required parameter"
msgstr "~S ~S: ~S necesita algunos parámetros obligatorios"

#: clos.lsp:3292
msgid "~S ~S: No initializations are allowed in a generic function lambda-list: ~S"
msgstr "~S ~S: No están permitidas las inicializaciones en la lista lambda de una función genérica: ~S"

#: clos.lsp:3300
msgid "~S ~S: variable name ~S should be a symbol"
msgstr "~S ~S: el nombre de la variable ~S debe ser un símbolo"

#: clos.lsp:3307
msgid "~S ~S: duplicate variable name ~S"
msgstr "~S ~S: el nombre de la variable ~S está duplicado"

#: clos.lsp:3360
msgid "~S ~S: invalid lambda list portion: ~S"
msgstr "~S ~S: parte de la lista lambda es inválida: ~S"

#: clos.lsp:3413
msgid "Removing all methods of ~S"
msgstr "Borrando todos los métodos de ~S"

#: clos.lsp:3423
msgid "Modifying the parameter profile of ~S"
msgstr "Modificando el perfil de parámetro de ~S"

#: clos.lsp:3483
msgid "~S: ~S is not a generic function specification"
msgstr "~S: ~S no es una especificación de función genérica"

#: clos.lsp:3548
msgid "~S: The name of a class must be a symbol, not ~S"
msgstr "~S: El nombre de una clase debe ser un símbolo, no ~S"

#: clos.lsp:3555
msgid "~S: The name of the built-in class ~S cannot be modified"
msgstr "~S: No es posible modificar el nombre de la clase predefinida ~S"

#: clos.lsp:3566
msgid "~S: When calling ~S with arguments ~S, no method is applicable."
msgstr "~S: No se puede aplicar ningún método al invocar ~S con los argumentos ~S."

#: clos.lsp:3575
msgid "~S: When calling ~S with arguments ~S, no primary method is applicable."
msgstr "~S: No se puede aplicar ningún método primario al invocar ~S con los argumentos ~S"

#: clos.lsp:3587
msgid "~S: When calling ~S with arguments ~S, there is no next method after ~S, and ~S was called."
msgstr "~S: Mientras se invoca ~S con los argumentos ~S, no hay ningún método después de ~S, y ~S fue llamado."

#: clos.lsp:3640
msgid "~S: The class ~S has no slot named ~S"
msgstr "~S: La clase ~S no tiene ninguna ranura llamada ~S"

#: clos.lsp:3652
msgid "~S: The slot ~S of ~S has no value"
msgstr "~S: La ranura ~S de ~S no tiene ningún valor"

# Duda: Lo que he dicho unos pocos mensajes más arriba --> Slot por
# slot, ...
#
# Pues no, ... A partir de la versión 1.4, `slot' es "ranura", tal y
# como se propone en la lista de spanglish.
#
#: clos.lsp:3683
msgid "~%Slots:"
msgstr "~%Ranuras:"

#: clos.lsp:3691
msgid "unbound"
msgstr "sin asociar"

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#: clos.lsp:3697
msgid "~%No slots."
msgstr "~%Sin ranuras."

#: conditio.lsp:84
msgid "~S: the name of a condition must be a symbol, not ~S"
msgstr "~S: el nombre de una condición debe ser un símbolo, y no ~S"

# En este mensaje, el término `parent-type' se refiere al segundo
# argumento de la macro `define-condition' que, según el estándar, se
# utiliza como lista de super-tipos del que se obtiene una nueva
# condición.
#
# Por ese motivo, he añadido la expresión "super-tipos" - cll
#
#: conditio.lsp:91
msgid "~S: the parent-type list must be a list of symbols, not ~S"
msgstr "~S: la lista de \"super-tipos\" debe ser una lista de símbolos, y no ~S"

#: conditio.lsp:98
msgid "~S: the slot description list must be a list, not ~S"
msgstr "~S: la lista de descripción de la ranura debe ser una lista, y no ~S"

#: conditio.lsp:154
msgid "~S: type ~S is not a subtype of ~S"
msgstr "~S: el tipo ~S no es un subtipo de ~S"

#: conditio.lsp:172
msgid "~S ~S: superfluous arguments ~S"
msgstr "~S ~S: los argumentos ~S son superfluos"

#: conditio.lsp:191
msgid "~S: the condition argument must be a string, a symbol or a condition, not ~S"
msgstr "~S: el argumento de la condición debe ser una cadena de caracteres, un símbolo o una condición, y no ~S"

#: conditio.lsp:569
msgid "~S: illegal syntax of clause ~S"
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: conditio.lsp:577
msgid "~S: misplaced ~S clause: ~S"
msgstr "~S: la clausula ~S está mal colocada: ~S"

#: conditio.lsp:585
msgid "~S: too many variables ~S in clause ~S"
msgstr "~S: demasiadas variables ~S en la clausula ~S"

# Duda: ¿y cómo traduzco `restart'?
#
# He decidido dejar `restart' sin traducir, ... :(
#
#: conditio.lsp:800
msgid "~S: ~S is not a valid restart name here. Use ~S instead."
msgstr "~S: ~S no es válido como nombre de `restart' aquí. En su lugar, use ~S."

#: conditio.lsp:823
msgid "~S: invalid restart name ~S"
msgstr "~S: ~S es un nombre inválido de `restart'"

#: conditio.lsp:832
msgid "~S: No restart named ~S is visible."
msgstr "~S: No hay ningún `restart' visible llamado ~S"

#: conditio.lsp:892 conditio.lsp:957
msgid "~S: not a list: ~S"
msgstr "~S: no es una lista: ~S"

#: conditio.lsp:903 conditio.lsp:968
msgid "~S: invalid restart specification ~S"
msgstr "~S: ~S no es una especificación válida de `restart'"

#: conditio.lsp:916 conditio.lsp:1010
msgid "~S: unnamed restarts require ~S to be specified: ~S"
msgstr "~S: es necesario especificar ~S en los `restart' sin nombre: ~S"

#: conditio.lsp:993
msgid "~S: missing lambda list in restart specification ~S"
msgstr "~S: falta la lista lambda en la especificación del `restart' ~S"

#: conditio.lsp:1020
msgid "~S: restart cannot be invoked interactively because it is missing a ~S option: ~S"
msgstr "~S: el `restart' no puede invocarse interactivamente porque falta la opción ~S: ~S"

#: conditio.lsp:1221
msgid "~%New ~S [value ~D of ~D]: "
msgstr ""

#: conditio.lsp:1435 conditio.lsp:1558
msgid "Return from ~S loop"
msgstr "Retorno del bucle ~S"

#
# En este caso he tenido que traducir `warning' por `advertencia', en
# vez de `atención'. ¿No querreis que diga algo así como "Esto es más
# serio que un toque de atención"? Así parecería que el compilador le va
# a meter una paliza al pobre programador, ... :) - cll
#
#: conditio.lsp:1534
msgid "~S: This is more serious than a warning: ~A"
msgstr "~S: Esto es más serio que una advertencia: ~A"

#: defs3.lsp:228
#, fuzzy
msgid "~S: argument ~S should be a string or a symbol"
msgstr "~: el argumento ~ debe ser una cadena o un símbolo"

#: xcharin.lsp:36
#, fuzzy
msgid "~: argument ~S is not a character"
msgstr "~: el argumento ~ no es un carácter"

#: xcharin.lsp:59
#, fuzzy
msgid "~S: the font argument should be an integer, not ~S"
msgstr "~: el argumento de la fuente debe ser un número y no ~"

#: xcharin.lsp:70
#, fuzzy
msgid "~S: the bits argument should be an integer, not ~S"
msgstr "~: el argumento de los bits debe ser un entero y no ~"

# Ya, ya se que eso de "los nombres de bit" puede sonar muy raro, pero
# es que realmente es así en Common Lisp.  Consúltese el Cltl2, 13.5
# Character Control-Bit Functions, página 385
#
#: xcharin.lsp:94
#, fuzzy
msgid "~S: the only bit names are ~S, ~S, ~S, ~S, not ~S"
msgstr "~: los únicos nombres de bit son :CONTROL, :META, :SUPER y :HYPER, y no ~"

# Creo que si ~S es un sólo carácter, te cabe en la misma línea :-) sv
#
#: foreign1.lsp:85
msgid "Cannot map string ~S to C since it contains a character ~S"
msgstr "La cadena ~S no puede convertirse a C puesto que contiene el carácter ~S"

#: foreign1.lsp:129
msgid "Incomplete FFI type ~S is not allowed here."
msgstr "El tipo incompleto FFI ~S no está permitido aquí"

#: foreign1.lsp:137
msgid "FFI type should be a symbol, not ~S"
msgstr "Un tipo FFI debe ser un símbolo, no ~S"

# Duda: pues un poco lo de siempre. FFI significa Foreign Function
# Interface y todo el mundo sabe que es el módulo de llamadas a
# funciones escritas en otro lenguaje (lo que yo he traducido como
# llamadas extranjeras). Los programadores avanzados en Lisp (y sólo
# ellos podrían ver un mensaje como este, ...) saben muy bien lo que es
# FFI. ¿Lo dejo así?, ...
#
# Uno de nuestros revisores (César Ballardini) dijo en cierta ocasión:
# "No es necesario explicar la terminología dentro de su propio contexto."
# Es decir: Si finalmente te decides por FFI (que por lo que dices
# parece lo más razonable), pon cuidado de no explicarlo tanto, por ejemplo,
# en el mensaje anterior al anterior a este. sv
#
# Vale, pues entonces se queda como FFI ¡y listo! cll
#
#: foreign1.lsp:143
msgid "Invalid FFI type: ~S"
msgstr "Tipo FFI inválido: ~S"

#: foreign1.lsp:162 foreign1.lsp:229
msgid "Invalid ~S component: ~S"
msgstr "Componente ~S inválida: ~S"

#: foreign1.lsp:340
msgid "Invalid option in ~S: ~S"
msgstr "Opción inválida en ~S: ~S"

#: foreign1.lsp:346
msgid "Only one ~S option is allowed: ~S"
msgstr "Sólo se permite una opción ~S: ~S"

#: foreign1.lsp:365
msgid "Invalid parameter specification in ~S: ~S"
msgstr "Especificación de parámetro inválida en ~S: ~S"

#: foreign1.lsp:428
msgid "The name must be a string, not ~S"
msgstr "El nombre debe ser una cadena, no ~S"

#: foreign1.lsp:435
msgid "The name ~S is not a valid C identifier"
msgstr "El nombre ~S no es un identificador válido en C"

#: foreign1.lsp:694
msgid "illegal foreign data type ~S"
msgstr "el tipo de datos extranjero ~ es inválido"

#: foreign1.lsp:826
msgid "~S: ~S option missing in ~S"
msgstr "~S: falta la opción ~S en ~S"

#: foreign1.lsp:1023
msgid "~S: :OUT argument is not a pointer: ~S"
msgstr "~S: el argumento :OUT no es un puntero: ~S"

#: foreign1.lsp:1089
msgid "~S is only allowed after ~S: ~S"
msgstr "Sólo se puede poner ~S después de ~S: ~S"

#: screen.lsp:226
msgid "Got bad response from ~S: ~S"
msgstr "Se obtuvo una respuesta incorrecta de ~S: ~S"

#: rexx1.lsp:146
msgid "No waiting for ~S possible."
msgstr "No se puede esperar por ~S."

#: affi1.lsp:39
msgid "Basename ~S not a keyword or libraryname ~S not a string"
msgstr "La base ~S no es una palabra clave o el nombre de la biblioteca ~S no es una cadena de caracteres"

#: affi1.lsp:48
msgid "Library redefinition: old ~S, new ~S"
msgstr "La biblioteca llamada ~S ha sido redefinida como ~S"

#: affi1.lsp:60
msgid "Unknown library: ~S"
msgstr "Biblioteca desconocida: ~S"

#: affi1.lsp:89
msgid "Library ~S is not open"
msgstr "La biblioteca ~S no está abierta"

#: affi1.lsp:153
msgid "Unknown function of library ~S: ~S"
msgstr "No se conoce ninguna función en la biblioteca ~S con el nombre ~S"

#: affi1.lsp:181
msgid "Offset must be a fixnum: ~S"
msgstr "El desplazamiento no es del tipo FIXNUM: ~S"

#: affi1.lsp:194
msgid "~&;; redefining foreign library function ~S~%;;  from ~S to ~S~%"
msgstr "~&;; redefiniendo la función ~S de la biblioteca externa~%;;  de ~S a ~S~% "

#: affi1.lsp:215
msgid "Unknown register: ~S"
msgstr "Registro desconocido: ~S"

#: affi1.lsp:229
msgid "Invalid parameter specification ~S in function ~S"
msgstr "La especificación de parámetros ~S de la función ~S es incorrecta"

#: affi1.lsp:243
msgid "Unknown library function: ~S"
msgstr "La función de biblioteca ~S no está definida"

#: affi1.lsp:262
msgid "Bad number of arguments for ~S: ~S"
msgstr "El número de argumentos de ~S es incorrecto: ~S"

#~ msgid "character ~ is not a string-char, cannot be output onto ~"
#~ msgstr "el carácter ~ no es del tipo STRING-CHAR, y por ello no puede escribirse en ~"

#~ msgid "~: argument should be a string-char, not ~"
#~ msgstr "~: el argumento debe ser del tipo STRING-CHAR, no ~"

#~ msgid "~: ~ is not a string-char"
#~ msgstr "~: ~ no es un STRING-CHAR"

# Duda: uufff!!! Keypad, keypad, ..., ¿Teclado auxiliar?
#
# A continuacion reproduzco la pregunta que formule en la lista de CLisp:
#
# > 2. When does the message "Keypad-" appear?. The Keypad is the set of
# > numeric keys that are at the left of the keyboard. But I need to know
# > with which kind of messages does it join to know how to translate it.
#
# Y la respuesta de Bruno Haible:
#
# In phrases like "Please press Keypad-Enter when done".
#
# Francamente, me parece que la utilizacion de Keypad, a secas, será lo
# mejor.
#
#
#~ msgid "Keypad-"
#~ msgstr "Keypad-"

#~ msgid " with additional bits"
#~ msgstr " con bits adicionales"

#~ msgid " from font ~S"
#~ msgstr " de la fuente ~S"

#~ msgid "cursor up"
#~ msgstr "cursor arriba"

#~ msgid "cursor down"
#~ msgstr "cursor abajo"

#~ msgid "cursor left"
#~ msgstr "cursor a la izquierda"

#~ msgid "cursor right"
#~ msgstr "cursor a la derecha"

#~ msgid "cursor to start of line"
#~ msgstr "cursor al principio de línea"

#~ msgid "cursor to end of line"
#~ msgstr "cursor al final de la línea"

#~ msgid "cursor to start of text"
#~ msgstr "cursor al principio del texto"

#~ msgid "cursor to end of text"
#~ msgstr "cursor al final del texto"

#~ msgid "page up"
#~ msgstr "retroceso de página"

#~ msgid "page down"
#~ msgstr "avance de página"

#~ msgid "line up"
#~ msgstr "retroceder una línea"

#~ msgid "line down"
#~ msgstr "avanzar una línea"

#~ msgid "set mark ~D"
#~ msgstr "poner la marca ~D"

#~ msgid "cursor to mark ~D"
#~ msgstr "mover el cursor a la marca ~D"

#~ msgid "delete character at cursor"
#~ msgstr "borrar el carácter bajo el cursor"

#~ msgid "combine two lines"
#~ msgstr "juntar dos líneas"

#~ msgid "delete character at cursor, across lines"
#~ msgstr "borrar el carácter bajo el cursor, a través de varias líneas"

#~ msgid "delete character before cursor"
#~ msgstr "borrar el carácter antes del cursor"

#~ msgid "delete character before cursor, across lines"
#~ msgstr "borrar el carácter antes del cursor, a través de varias líneas"

#~ msgid "delete line"
#~ msgstr "borrar una línea"

#~ msgid "delete part of line left to the cursor"
#~ msgstr "borrar la línea hasta donde está el cursor"

#~ msgid "delete up to end of line"
#~ msgstr "borrar hasta el final de la línea"

#~ msgid "begin new line at cursor"
#~ msgstr "comenzar una nueva línea en la posición del cursor"

#~ msgid "cursor to start of block"
#~ msgstr "mover el cursor al comienzo del bloque"

#~ msgid "cursor to end of block"
#~ msgstr "mover el cursor al final del bloque"

#~ msgid "set block start"
#~ msgstr "establecer el comienzo de un bloque"

#~ msgid "set block end"
#~ msgstr "establecer el final de un bloque"

#~ msgid "remove block marks"
#~ msgstr "desechar las marcas del bloque"

#~ msgid "delete block"
#~ msgstr "borrar un bloque"

#~ msgid "move block to cursor position"
#~ msgstr "mover el bloque a la posición del cursor"

#~ msgid "copy block to cursor position"
#~ msgstr "copiar un bloque a la posición del cursor"

#~ msgid "copy block into cut-and-paste buffer"
#~ msgstr "copiar un bloque en el buffer de cortar-y-pegar"

#~ msgid "yank block into cut-and-paste buffer"
#~ msgstr "insertar un bloque en el buffer de cortar-y-pegar"

#~ msgid "insert cut-and-paste buffer contents"
#~ msgstr "inserta los contenidos del buffer cortar-y-pegar"

#~ msgid " Key bindings "
#~ msgstr " Asociaciones de teclado "

#~ msgid "                           K E Y   B I N D I N G S"
#~ msgstr "                 A S O C I A C I O N E S   D E   T E C L A D O"

#~ msgid " File to load: "
#~ msgstr " Lectura del fichero: "

#~ msgid " Save as: "
#~ msgstr " Salvar como: "

#~ msgid "evaluate block contents"
#~ msgstr "evaluar los contenidos del bloque"

#~ msgid "skip whitespace right"
#~ msgstr "ignorar los espacios en blanco a la derecha"

#~ msgid "~S from ~S: |# is legal only after #|"
#~ msgstr "~ en ~: |# es legal solo después de #|"

#~ msgid "mark next Lisp object"
#~ msgstr "marcar el siguiente objeto Lisp"

#
# Duda: `surrounding' por `circundante'
#
# ¿ Qué os parece ?
#
#~ msgid "mark surrounding top level form"
#~ msgstr "marcar la forma circundante"

#
# Duda: `surrounding' por `circundante'
#
# ¿ Qué os parece ?
#
#~ msgid "evaluate surrounding top level form"
#~ msgstr "evaluar la forma circundante"

#~ msgid "insert spaces up to next tab stop"
#~ msgstr "insertar espacios hasta la siguiente marca de tabulación"

#~ msgid "search for a string"
#~ msgstr "buscar una cadena de caracteres"

#~ msgid " Search: "
#~ msgstr " Buscar: "

#~ msgid "continue searching"
#~ msgstr "continuar la búsqueda"

#~ msgid "show window ~D"
#~ msgstr "mostrar la ventana ~D"

#~ msgid "hide window ~D"
#~ msgstr "ocultar la ventana ~D"

#~ msgid "show help window (this text)"
#~ msgstr "muestra la ventana de ayuda (este texto) "

#~ msgid "show error window"
#~ msgstr "mostrar la ventana de error"

#~ msgid "show trace window"
#~ msgstr "mostrar la ventana de rastreo"

#~ msgid "delete current window"
#~ msgstr "borrar la ventana actual"

#~ msgid "load file"
#~ msgstr "cargar el fichero \""

#~ msgid "store to file"
#~ msgstr "almacenar en el fichero"

#~ msgid "store to new file"
#~ msgstr "almacenar en un fichero nuevo"

#~ msgid "quit editor"
#~ msgstr "salir del editor"

#~ msgid "hide top window"
#~ msgstr "ocultar la ventana superior"
