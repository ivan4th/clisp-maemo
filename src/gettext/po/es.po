# Mensajes en español para GNU CLISP.
# Copyright (C) 1996 Free Software Foundation, Inc.
# Carlos Linares López <clinares@delicias.dia.fi.upm.es>, 1997.
#
# Han contribuido a esta traducción:
#
# cll - Carlos Linares López 	(Traducción)
# sv  - Santiago Vila Doncel	(Revisión)
# lsg - Leonardo Sarasúa García	(Traducción y Revisión)
#
# Agradecimientos especiales a:
#
# Bruno Haible
# Marcus Daniels
# 					(Programadores de CLisp)
#
# Enrique Melero
# 				    (Coordinador de Spanish GNU)
#
# Por haber atendido siempre mis preguntas y por mostrar tanto interés
# en esta traducción.
#
# Asimismo, quisiera expresar mi agradecimiento a las siguientes
# personas, por responder pacientemente todas mis preguntas: Joerg
# Hoehle (traductor de la versión francesa) y Juan Jordana.
#
# Por último, a toda la lista de Spanish GNU Translation Team
# (es@li.org) por sus sugerencias.
#
# NOTAS.
#
# * Los mensajes en los que se han realizado anotaciones de interés,
# bien porque haya alguna duda, bien porque contenga notas importantes
# relativas a las traducciones tienen la palabra `Duda:' al principio de
# su comentario.
#
# * Por favor, si alguien realiza alguna modificación a este archivo que
# ponga sus iniciales al final del comentario explicando el cambio y el
# motivo. Si su nombre no está en esta cabecera que lo añada poniendo
# las iniciales.
#
# * Todas las líneas que comienzan con #~ son mensajes obsoletos que no
# hace falta revisar. En cualquier caso, intentaré normalmente
# eliminarlas.
#
# $Id$
# $Log$
# Revision 1.16  1999/07/20 23:01:51  haible
# Regenerated.
#
# Revision 1.12  1998/09/07 18:21:38  clinares
# Traducción de todos los mensajes para la versión del 29-8-1998. Estos
# cambios, sin embargo, serán publicados en alguna nueva versión de
# septiembre de este mismo año.
#
# Revision 1.9  1997/09/18 13:36:38  clinares
# He incluído nuevas modificaciones de Leo Sarasúa.
#
# Entre las más representativas está el hecho de haber modificado
# `trama' por `marco' y `# macro carácter' por `macro carácter
# secundario'. Nuevamente gracias, Leo, ...
#
# Revision 1.8  1997/09/05 17:23:30  clinares
# He introducido todas las modificaciones propuestas por Santiago Vila a
# la versión 1.6. Además, las he adaptado para el nuevo .pot que se
# empleó en la versión 1.7.
#
# Entre los cambios más importantes está: `command' es `orden', no
# `comando'; `warning' es, preferiblemente, `atención' y, en otro caso,
# propongo que sea `advertencia', en vez de `aviso'.
#
# Revision 1.7  1997/09/03 17:51:44  clinares
# He modificado la traducción de las directivas ~P, puesto que nunca se
# escribirán versiones en español de ellas, ya que el estándar Common
# Lisp - The Language es muy específico: solo en inglés. Ni en alemán,
# ni francés, ni español, ...
#
# Además, he adaptado los cambios del POT de la versión 1.6
# (POT-Creation-Date: 1997-05-04) a la última versión que existe
# actualmente (POT-Creation-Date: 1997-09-02). Para ello, he traducido 9
# mensajes nuevos, he corregido los mensajes difusos y he borrado todos
# los obsoletos.
#
# Revision 1.6  1997/08/30 14:04:08  clinares
# El 100% de los mensajes están traducidos :)
# En total, 9 meses de trabajo (es decir, ¡¡ha sido un parto!! :)
#
# Revision 1.5  1997/08/27 00:48:46  clinares
# Esta es la traducción que resulta de programar todos los cambios
# propuestos por lsg (Leonardo Sarasúa García). En total, ¡¡alrededor de
# 800 líneas!!, ahí es nada :)
#
# Muchísimas gracias, Leo. Te debo la cerveza más grande del mundo, ...
#
# ------------------------------------------------------------------
# msgfmt --statistics -c -v -o /dev/null /home/clinares/GNU/clisp.po
# 1406 mensajes traducidos.
# ------------------------------------------------------------------
#
msgid ""
msgstr ""
"Project-Id-Version: GNU clisp 1996-03-31\n"
"POT-Creation-Date: 1999-07-21 00:46:18 CEST\n"
"PO-Revision-Date: 1997-08-11 18:16 MET DST\n"
"Last-Translator: Carlos Linares López <clinares@delicias.dia.fi.upm.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: constobj.d:362
msgid "Please choose:"
msgstr "Por favor, escoja:"

#: constobj.d:366
msgid "Please choose one of ~:{~A~:^, ~} ."
msgstr "Por favor, elija uno/a de ~:{~A~:^, ~} ."

#: constobj.d:369
msgid "symbol ~A from #<PACKAGE ~A> will become a shadowing symbol"
msgstr "el símbolo ~A del paquete #<PACKAGE ~A> se convertirá en un símbolo que eclipsa a otro"

#: constobj.d:371
msgid "You may choose the symbol in favour of which to resolve the conflict."
msgstr "Puede elegir el símbolo en favor del cual se resolverá el conflicto."

#: constobj.d:373
msgid "uninterning ~S from ~S uncovers a name conflict."
msgstr "Al sacar ~S de ~S se ha puesto de manifiesto un conflicto entre nombres."

#: constobj.d:375 constobj.d:389
msgid "You may choose how to proceed."
msgstr "Puede elegir cómo continuar."

#: constobj.d:377
msgid "importing ~S into ~S produces a name conflict with ~S."
msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S."

#: constobj.d:379
msgid "importing ~S into ~S produces a name conflict with ~S and other symbols."
msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S y otros símbolos."

#
# publicar está mal y ademas no es consistente con el mensaje d:329 en el que dice 'sacar'
# En este y en otros mensajes, el texto no es una orden dada al usuario, sino una opción que
# se le ofrece. Por tanto, no debe traducirse como un imperativo (impórtelo)  sino en
# infinitivo (importarlo). Pero deberías confirmar esto. - lsg
#
# Si, creo que tienes toda la razón, ... Entonces pongo `sacar' que
# aunque suene muy burro, creo que es muy, muy claro, ...
#
#: constobj.d:381
msgid "((\"I\" \"import it and unintern the other symbol\" T) (\"N\" \"do not import it, leave undone\" NIL))"
msgstr "((\"I\" \"impórtarlo y sacar el otro símbolo\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Aquí tengo la misma duda anterior - lsg
#
#: constobj.d:384
msgid "((\"I\" \"import it, unintern one other symbol and shadow the other symbols\" T) (\"N\" \"do not import it, leave undone\" NIL))"
msgstr "((\"I\" \"importarlo, sacar uno de los otro símbolos y eclipsar el resto\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Lo mismo de antes - lsg
#
#: constobj.d:387
msgid "((\"I\" \"import it and shadow the other symbol\" T) (\"N\" \"do nothing\" NIL))"
msgstr "((\"I\" \"importarlo y eclipsar el otro símbolo\" T) (\"N\" \"no hacer nada\" NIL))"

#: constobj.d:391
msgid "symbol ~S should be imported into ~S before being exported."
msgstr "el símbolo ~S debe ser importado a ~S antes de ser exportado."

#
# La misma cuestión anterior entre imperativo e infinitivo - lsg
#
#: constobj.d:393
msgid "((\"I\" \"import the symbol first\" T) (\"N\" \"do nothing, don't export the symbol\" NIL))"
msgstr "((\"I\" importar el símbolo primero\" T) (\"N\" \"no hacer nada, no exportar el símbolo\"))"

#: constobj.d:396
msgid "You may choose in favour of which symbol to resolve the conflict."
msgstr "Puede elegir en favor de qué símbolo se debe resolver el conflicto."

#
# El segundo from deberia ser 'de', porque quiere decir que un símbolo
# a de un paquete A entra en conflicto con el símbolo b _del_ paquete
# B. Luego, debe ser 'de'.
#
#: constobj.d:398
msgid "exporting ~S from ~S produces a name conflict with ~S from ~S."
msgstr "la exportación de ~S desde ~S produce un conflicto de nombres con ~S de ~S."

#: constobj.d:400
msgid "Which symbol should be accessible in ~S ?"
msgstr "¿ Qué símbolo debe ser accesible en ~S ?"

#: constobj.d:404
msgid "the symbol to export, "
msgstr "el símbolo a exportar, "

#: constobj.d:406
msgid "the old symbol, "
msgstr "El símbolo original, "

#: constobj.d:408
msgid "You may choose for every conflict in favour of which symbol to resolve it."
msgstr "Puede elegir en favor de qué símbolo se debe resolver cada conflicto."

#
# Es una traducción un poco libre (literalmente sería "el nombre = ~S
# entra en conflicto...."), pero ésta me parece más corta y correcta. - lsg
#
#: constobj.d:410
msgid "~S name conflicts while executing USE-PACKAGE of ~S into package ~S."
msgstr "Conflicto de nombre ~S al ejecutar USE-PACKAGE de ~S al paquete ~S"

#: constobj.d:412
msgid "which symbol with name ~S should be accessible in ~S ?"
msgstr "¿ Qué símbolo con nombre ~S debe ser accesible en ~S ?"

#: constobj.d:414
msgid "You can input another name."
msgstr "Puede introducir otro nombre."

#: constobj.d:416
msgid "You can input another nickname."
msgstr "Puede introducir otro apodo."

#: constobj.d:418
msgid "a package with name ~S already exists."
msgstr "ya existe un paquete con el nombre ~S."

#
# Si fuera inglés corriente, estaría bien tu traducción, pero es inglés
# 'telegráfico', y en realidad quieren decir lo que te he escrito, es
# decir, 'nuevo' afecta a 'nombre', no a 'paquete'.
#
# Eres un gran maestro, algo así como un quinto dan de las traducciones,
# ... ¡Tienes toda la razón! :) - cll
#
#: constobj.d:420
msgid "Please input new package name:"
msgstr "Por favor, introduzca un nuevo nombre de paquete:"

#: constobj.d:422
msgid "Please input new package nickname:"
msgstr "Por favor, introduzca un nuevo apodo de paquete:"

# Ojo con el ignorar. sv
#
# No, ya te he puesto antes las acepciones de esta palabra y esta vez,
# viene al caso, ... cll
#
# O sea, que estás 'ignorando ' la sugerencia de sv, ;-) - lsg
#
# Muy bueno, muy bueno, ... :) Santiago, por aquí hay mucho cachondeo :) - cll
#
#
#: constobj.d:424
msgid "Ignore."
msgstr "Ignorar."

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~S.",
# pienso que "No hay ningún paquete con el nombre ~S" es ligeramente
# mejor, ¿qué te parece? - cll
#
#: constobj.d:426
msgid "~S: There is no package with name ~S."
msgstr "~S: No hay ningún paquete con el nombre ~S."

#: constobj.d:428
msgid "~*Nevertheless delete ~S."
msgstr "~*No obstante borre ~S."

#
# Leo, en vez de "está siendo utilizado", ¿no crees que es mejor "es
# utilizado"? - cll
#
# Propongo *se utiliza*, es mucho más español. sv
#
# Pero, ¿cómo pones algo así? "~S se utiliza en ~{~S~^, ~}.", ¿por
# ejemplo? Es que el problema es que no ~S (el primero) no "se utiliza"
# en la segunda expresión, sino que la segunda expresión es una que
# emplea a la primera. No se si me explico, ...
#
# En cualquier caso, creo que tienes toda la razón al decir "es mucho
# más español", es que de hecho la expresión "es utilizado" aunque es
# correcta, no parece muy española, por favor, ¿sugerencias? - cll
#
#: constobj.d:430
msgid "~S: ~S is used by ~{~S~^, ~}."
msgstr "~S: ~S es utilizado por ~{~S~^, ~}."

#: constobj.d:444
msgid "January"
msgstr "Enero"

#: constobj.d:448
msgid "February"
msgstr "Febrero"

#: constobj.d:452
msgid "March"
msgstr "Marzo"

#: constobj.d:456
msgid "April"
msgstr "Abril"

#: constobj.d:460
msgid "May"
msgstr "Mayo"

#: constobj.d:464
msgid "June"
msgstr "Junio"

#: constobj.d:468
msgid "July"
msgstr "Julio"

#: constobj.d:472
msgid "August"
msgstr "Agosto"

#: constobj.d:476
msgid "September"
msgstr "Septiembre"

#: constobj.d:480
msgid "October"
msgstr "Octubre"

#: constobj.d:484
msgid "November"
msgstr "Noviembre"

#: constobj.d:488
msgid "December"
msgstr "Diciembre"

#: constobj.d:503
msgid "ANSI C program"
msgstr "programa ANSI C"

#: constobj.d:507
msgid "GNU C++ "
msgstr "GNU C++"

#: constobj.d:510
msgid "GNU C "
msgstr "GNU C "

#: constobj.d:517
msgid "C++ compiler"
msgstr "Compilador de C++"

#: constobj.d:520
msgid "C compiler"
msgstr "Compilador de C"

# Ojo: ¿¿No sería "INGLÉS"?? sv
#
# No, esto está bien, esta expresión se utiliza en una parte del código
# de CLisp en la que se realiza la inicialiación dependiente del idioma,
# de modo que en la traducción alemana pone "DEUTSCH" y en la francesa
# "FRANCAIS", pues en la española, "ESPAÑOL", como corresponde - cll
#
#: constobj.d:525
msgid "ENGLISH"
msgstr "ESPAÑOL"

#: constobj.d:684
msgid "The value of ~S was not a pathname. ~:*~S is being reset."
msgstr "El valor de ~S no es del tipo PATHNAME. ~:*~S se reinicializará."

# Duda: ¿Creando *el* directorio? ¿Creando *un* directorio? De momento,
# simplemente "Creando directorio" - cll
#
#: constobj.d:689
msgid "Creating directory: "
msgstr "Creando directorio: "

#: constobj.d:838
msgid ""
"The variable ~S had an illegal value.\n"
"~S has been reset to ~S."
msgstr ""
"La variable ~S tenía un valor inválido.\n"
"~S ha sido inicializado a ~S."

#: constobj.d:840
msgid ""
"Floating point operation combines numbers of different precision.\n"
"See ANSI CL 12.1.4.4 and the CLISP impnotes for details.\n"
"The result's actual precision is controlled by\n"
"~S.\n"
"To shut off this warning, set ~S to ~S."
msgstr ""
"Las operaciones en coma flotante combinan números de diferentes precisiones.\n"
"Para más detalles, consulte ANSI CL 12.1.4.4 y las notas de implementación de\n"
"CLISP.\n"
"La precisión actual del resultado está controlada por\n"
"~S.\n"
"Para eliminar este aviso, establezca el valor de ~S a ~S."

#: constobj.d:855
msgid "Bye."
msgstr "Adiós."

#: constobj.d:857
msgid "Press a key to terminate..."
msgstr ""

# Un poco más en español podría ser: "Entorno siguiente: " sv
#
# Hmmm, ..., aquí no estoy de acuerdo contigo. No me suena bien lo del
# "Entorno siguiente", ... cll
#
#: constobj.d:862
msgid ""
"\n"
"  Next environment: "
msgstr ""
"\n"
"  Siguiente entorno: "

#: constobj.d:864
msgid ""
"\n"
"APPLY frame with breakpoint for call "
msgstr ""
"\n"
"marco APPLY con punto de ruptura para invocar "

#: constobj.d:866
msgid ""
"\n"
"APPLY frame for call "
msgstr ""
"\n"
"marco APPLY para invocar "

#: constobj.d:868
msgid ""
"\n"
"EVAL frame with breakpoint for form "
msgstr ""
"\n"
"marco EVAL con punto de ruptura para la forma "

#: constobj.d:870
msgid ""
"\n"
"EVAL frame for form "
msgstr ""
"\n"
"marco EVAL para la forma "

#
# A ver aquí, que hay mogollón, hay mogollón, ...
#
# Leo, tu opinas que aquí deberíamos traducir:
#
# "variables con vinculación de recintos (~ = dinámicamente):"
#
# Sin embargo, yo creo que lo más correcto es:
#
# "trama de ligadura de las variables (~ = dinámicamente):"
#
# Puesto que esto se refiere al tipo de tramas que hay en la pila,
# cuando ésta está siendo examinada. De hecho, la traducción francesa
# es:
#
# "Le «frame» de liaison de variables (~ signifiant dynamique) lie :"
#
# ..., que viene a ser algo como lo que he puesto yo. - cll
#
#: constobj.d:872
msgid ""
"\n"
"frame binding variables (~ = dynamically):"
msgstr ""
"\n"
"marco de ligadura de las variables (~ = dinámicamente):"

#: constobj.d:875
msgid ""
"\n"
"CALLBACK frame"
msgstr ""
"\n"
"marco CALLBACK"

#: constobj.d:878
msgid ""
"\n"
"frame binding variables "
msgstr ""
"\n"
"marco de ligadura de las variables"

#: constobj.d:880
msgid ""
"\n"
"frame binding functions "
msgstr ""
"\n"
"marco de ligadura de las funciones "

#: constobj.d:882
msgid " binds (~ = dynamically):"
msgstr " vincula (~ = dinámicamente):"

#: constobj.d:885
msgid ""
"\n"
"block frame "
msgstr ""
"\n"
"marco de bloque"

#: constobj.d:887
msgid ""
"\n"
"nested block frame "
msgstr ""
"\n"
"marco anidado de bloque"

#: constobj.d:889
msgid " for "
msgstr " para "

#: constobj.d:891
msgid ""
"\n"
"compiled block frame for "
msgstr ""
"\n"
"marco de bloque compilado para "

#: constobj.d:893
msgid ""
"\n"
"tagbody frame "
msgstr ""
"\n"
"marco de cuerpo de etiquetas de salto"

# Duda: Aquí lo de `nested' es bastante puñetero. Creo que no debe
# traducirse por `anidado' (que no tendría demasiado sentido, creo),
# sino por `encajada', haciendo referencia a la trama a la que se llega
# por el uso de las etiquetas de salto, ...
#
# Sin embargo, no estoy demasiado seguro, ... ¡¡Socorro!! - cll
#
# A propósito de esta cuestión, pregunté en la lista de correo de CLisp:
#
# > `nested' have various meanings. It can mean that one thing is `into'
# > other one or that one thing is `joined' with other one. In this
# > message, I think you are talking about the frame you arrive when using
# > a tag, as if you were `joining' a new frame, is it so?
#
# Y la respuesta de Bruno Haible fue:
#
# No. In CLISP it's yet another (maybe new?) meaning. Interpretation frames
# are normally built up in the stack. However, when a closure is created,
# some parts of the frames must be moved out to the heap, so that the
# closure points to valid data, called "environment", even after the frame
# has been deestablished. We called this process "nesting" of a frame.
# Any better vocabulary? Can you propose a good german or french translation?
#
# Asi que, la verdad, "anidado" me parece correcto. Para ello, imaginaos
# una trama (o marco), de la que se "re-elabora" una parte denominada
# "entorno" pero que solo tiene sentido dentro de esta trama (o marco),
# puesto que se ha levantado un `closure'. - cll
#
#: constobj.d:895
msgid ""
"\n"
"nested tagbody frame "
msgstr ""
"\n"
"marco anidado del cuerpo de etiquetas de salto"

#: constobj.d:897
msgid " for"
msgstr " para"

#: constobj.d:900
msgid ""
"\n"
"compiled tagbody frame for "
msgstr ""
"\n"
"marco compilado del cuerpo de etiquetas de salto para "

#
# Ésta estaba claramente mal - lsg
#
#: constobj.d:902
msgid ""
"\n"
"catch frame for tag "
msgstr ""
"\n"
"marco de captura para la etiqueta "

# Handler, otra buena.. Sugerencias? - lsg
#
# Duda: ¿cómo traducir `handler'?
#
# Pues bien, he elegido el término `manipulador' puesto que eso es,
# precisamente, lo que es un `handler' en Common Lisp. De hecho, el
# estándar Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr.,
# en la página 872 dice:
#
# "The process of signaling involves the search for an invocation of a
# handler, a piece of code that will attempt to deal appropiately with
# the situation"
#
# Y atención a la siguiente observación: (en la misma página, a
# continuación del párrafo anterior)
#
# "If a handle is found, it may either handle the situation, by
# performing some non-local transfer of control, or decline to handle
# it, by failing to perform a non-local transfer of control. If it
# declines, other handlers are sought".
#
# En fin, a la vista de esta definición y de la siguiente aclaración,
# propongo `manejador' para su traducción - cll
#
#: constobj.d:904
msgid ""
"\n"
"handler frame for conditions"
msgstr ""
"\n"
"marco de manipulación (HANDLER) para las condiciones"

#
# Estaba mal. Yo pondria: "recinto de unwind-protect" - lsg
#
# Y yo creo que si cambiamos `recinto' por `trama' ya es la leche de
# perfecto ;) - cll
#
# Leo, como puedes ver he cambiado en todos lados `trama' por `marco' - cll
#
#: constobj.d:906
msgid ""
"\n"
"unwind-protect frame"
msgstr ""
"\n"
"marco `unwind-protect'"

# Duda: Lo de `driver' lo dejo sin traducir, ...
#
# En la traducción francesa está sin traducir y en el estándar de Common
# Lisp no se hace ni la mas mínima referencia a algo que se llame así.
#
# "recinto de driver" - lsg
#
# Vale, ¡pero vamos!, que cambio `recinto' por `trama' - cll
#
#: constobj.d:908
msgid ""
"\n"
"\n"
"driver frame"
msgstr ""
"\n"
"\n"
"marco `driver'"

# "Entornos con vinculación de recintos" - lsg
#
# Aquí volvemos un poco a lo del mensaje constobj.d:915 Según creo,
# estos mensajes se refieren al tipo de tramas que hay en la pila, no se
# trata de un entorno (en el sentido que en Lisp tiene esta palabra).
#
# La traducción francesa dice:
#
# "«frame» de liaison d'environnements"
#
# ¿Que os parece?
#
#: constobj.d:910
msgid ""
"\n"
"frame binding environments"
msgstr ""
"\n"
"marco de ligadura del entorno"

#: spvw.d:598
msgid "could not make symbol value per-thread"
msgstr ""

# "*** - desbordamiento de la pila del programa - REINICIALIZANDO" - lsg
#
# En mi opinión, RESET debe traducirse como un imperativo - cll
#
#: spvw.d:662
msgid ""
"\n"
"*** - Program stack overflow. RESET"
msgstr ""
"\n"
"*** - Desbordamiento de la pila del programa. REINICIE"

# ¡ Toma puntilloso que soy! Lisp debería escribirse con mayúscula.
# "*** - desbordamiento de la pila de Lisp - REINICIALIZANDO" - lsg
#
# No, no, nada de REINICIALIZANDO. Debe ser un imperativo: REINICIE.
# Por ejemplo, si durante una sesión con CLisp haces:
#
# > (defun foo (a) (foo (1- a)))
# FOO
# > (foo 2)
#
# *** - Desbordamiento de la pila de Lisp. REINICIE
# >
#
# ..., pero el intérprete se queda esperando a que tú sigas tecleando,
# es decir, él solo no se pone a reiniciar nada, ...
#
# Por otra parte, tienes toda la razón, Lisp debe ir con mayúsculas :) - cll
#
#: spvw.d:667
msgid ""
"\n"
"*** - Lisp stack overflow. RESET"
msgstr ""
"\n"
"*** - Desbordamiento de la pila de Lisp. REINICIE"

#
# Muy bueno el apunte sobre ese acento en "cómo". Gracias, Santiago - cll
#
#: spvw.d:806
msgid ""
"internal error: statement in file ~, line ~ has been reached!!\n"
"Please send the authors of the program a description how you produced this error!"
msgstr ""
"error interno: ¡¡en la sentencia del fichero ~, línea ~!!\n"
"¡Por favor, envíe a los autores del programa una descripción de cómo\n"
"se produjo este error!"

#
# Por qué traduces signature asi?
# "Signatura desconocida de una FSUBR\n" - lsg
#
# Bueno, pues porque la traducción francesa dice:
#
# "Type d'argument inconnu pour FSUBR"
#
# Y mientras no sepa qué leches es eso del FSUBR (o SUBR, ver mensaje
# siguiente), pues para no pillarme los dedos lo dejaré tal y como lo
# puso Joerg Hoehle - cll
#
#: spvw.d:868
msgid "Unknown signature of an FSUBR\n"
msgstr "Tipo de argumento desconocido para FSUBR\n"

# ¿¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:977
msgid "Unknown signature of a SUBR\n"
msgstr "Tipo de argumento desconocido para SUBR\n"

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#: spvw.d:1597
msgid "module `%s' requires package %s.\n"
msgstr "el módulo `%s' necesita el paquete %s.\n"

# Antes de entrar en el debate sobre la traducción de port:
# ¿Es tan fundamentalmente distinto version y port en este contexto como
# para que no se pueda utilizar también versión para "port"? sv
#
# ¡¡Madre mía!! Eso de "antes de entrar" me ha dado muchísimo miedo,
# ... :) Asi que no se hable más, pongo "versión" :) No, ahora fuera
# cachondeo, en el contexto de estos mensajes la expresión "versión" es
# perfecta, ... - cll
#
#: spvw.d:1734
#, fuzzy
msgid "                    Amiga version: Jörg Höhle\n"
msgstr "                    Versión para Amiga: Jörg Höhle\n"

#: spvw.d:1738
#, fuzzy
msgid "                    RISCOS port: Peter Burwood, Bruno Haible\n"
msgstr "                    Versión para RISCOS: Peter Burwood, Bruno Haible\n"

#: spvw.d:1742
#, fuzzy
msgid "                    DOS port: Jürgen Weber, Bruno Haible\n"
msgstr "                    Versión para DOS: Jürgen Weber, Bruno Haible\n"

#: spvw.d:1961
msgid "Syntax for %s: nnnnnnn or nnnnKB or nMB\n"
msgstr "Sintaxis de %s: nnnnnnn or nnnnKB or nMB\n"

#
# "%s fuera de intervalo\n"
# No me gusta del todo. A lo mejor:
# "%s fuera de limites\n" - lsg
#
# Al final me he decidido por:
#
# "%s se ha salido del rango\n"
#
# ¿No te mola más? - cll
#
#: spvw.d:1965
msgid "%s out of range\n"
msgstr "%s se ha salido del rango\n"

#: spvw.d:1977
msgid "memory size"
msgstr "tamaño de memoria"

#: spvw.d:1987
msgid "stack size"
msgstr "tamaño de la pila"

#: spvw.d:2311
msgid "Return value of malloc() = %x is not compatible with type code distribution.\n"
msgstr "El valor devuelto por malloc() = %x no es compatible con la distribución del código de tipo.\n"

# solo es con acento.
# "sólo %d bytes disponibles\n" - lsg
#
# ¡¡Madre mía!! Tienes toda la razón del mundo - cll :)
#
#: spvw.d:2318
msgid "Only %d bytes available.\n"
msgstr "Sólo quedan %d bytes disponibles.\n"

# Duda: Imagino que SP es el "Stack Pointer". Pero entonces, ¿a qué
# viene decir "SP stack"? ¿Se referirán con ello a la pila del sistema?
# - cll
#
#: spvw.d:2552
msgid "Couldn't determine the end of the SP stack!\n"
msgstr "No fue posible determinar el final de la pila SP!\n"

# "AVISO: No se ha especificado un fichero de inicializacion.\n" - lsg
#
# El mensaje inglés está en pretérito (specified) por eso yo he
# preferido poner "especificó" en vez de "ha especificado" - cll
#
# Pero Carlos, se ha especificado, es también pretérito,
# pretérito perfecto (compuesto), pero pretérito a fin de cuentas.
# No se ha especificado está más en la línea los demás
# mensajes de los otros ficheros .po. sv
#
# Vale, vale, ... La verdad es que a mí las dos me suenan igual de bien,
# de modo que, a tenor de la voluntad popular (dos votos contra uno),
# pues se pone como propuso Leo - cll
#
# Otra nota de interés es la siguiente: he cambiado "aviso" por
# "atención". Creo que así suena mejor. Sugerencia de Santiago - cll
#
#: spvw.d:2777
msgid ""
"\n"
"WARNING: No initialisation file specified.\n"
msgstr ""
"\n"
"ATENCIÓN: No se ha especificado ningún fichero de inicialización.\n"

#: spvw.d:2781
msgid "Please try: "
msgstr "Por favor, intente:"

#: spvw.d:2970
msgid "Not enough memory for Lisp.\n"
msgstr "No hay memoria suficiente para Lisp.\n"

# "*** - Memoria virtual agotada. REINICIALIZACION " - lsg
#
# Yo creo que el mensaje debe acabar en un imperativo: REINICIALIZAR - cll
#
#: spvw_alloca.d:51
msgid ""
"\n"
"*** - Virtual memory exhausted. RESET"
msgstr ""
"\n"
"*** - Memoria virtual agotada. REINICIE"

# "*** - Memoria agotada. REINICIALIZACION " - lsg
#
# Más de lo mismo - cll
#
#: spvw_alloca.d:53
msgid ""
"\n"
"*** - Memory exhausted. RESET"
msgstr ""
"\n"
"*** - Memoria agotada. REINICIE"

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:64 spvw_mmap.d:203 spvw_mmap.d:369 spvw_multimap.d:165
msgid "Cannot map memory to address 0x%x ."
msgstr "No se puede asignar la memoria a la dirección 0x%x ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:173
msgid "Cannot reserve address range at 0x%x ."
msgstr "No se puede reservar el rango de direcciones a 0x%x ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:184
msgid "Cannot reserve address range 0x%x-0x%x ."
msgstr "No se puede reservar el rango de direcciones 0x%x-0x%x ."

#: spvw_mmap.d:234
msgid "CreateFileMapping() failed."
msgstr "CreateFileMapping() falló."

#: spvw_mmap.d:241
msgid "MapViewOfFileEx(addr=0x%x,off=0x%x) failed."
msgstr "MapViewOfFileEx(dirección=0x%x,segmento=0x%x) falló."

#: spvw_mmap.d:248
msgid "MapViewOfFileEx() returned 0x%x instead of 0x%x.\n"
msgstr "MapViewOfFileEx() devolvió 0x%x en vez de 0x%x.\n"

#: spvw_mmap.d:264
msgid "VirtualFree() failed."
msgstr "VirtualFree() falló."

#: spvw_mmap.d:279
msgid "VirtualProtect() failed."
msgstr "VirtualProtect() falló."

#: spvw_mmap.d:345 spvw_multimap.d:111
msgid "Cannot open /dev/zero ."
msgstr "No se puede abrir /dev/zero."

# "msync(0x%x,0x%x,MS_INVALIDATE) fracasó." - lsg
#
# O "falló" en vez de "fracasó". ¿Qué te parece? - cll
#
#: spvw_multimap.d:137
msgid "msync(0x%x,0x%x,MS_INVALIDATE) fails."
msgstr "msync(0x%x,0x%x,MS_INVALIDATE) falló."

#: spvw_multimap.d:196
msgid "Cannot open %s ."
msgstr "No se puede abrir %s."

#: spvw_multimap.d:207
msgid "Cannot delete %s ."
msgstr "No se puede borrar %s ."

# He seguido la propuesta de Santiago Vila. A partir de ahora, y siempre
# que sea posible, el término "warning" se traducirá por "atención". En
# aquellos casos en que esto no es posible, lo he indicado
# explícitamente con un comentario indicando el motivo. - cll
#
#: spvw_multimap.d:221
msgid "** WARNING: ** Too few free disk space for %s .\n"
msgstr "** ATENCIÓN: ** Hay muy poco espacio libre en disco para %s .\n"

#: spvw_multimap.d:224
msgid "Please restart LISP with fewer memory (option -m).\n"
msgstr "Por favor, vuelva a ejecutar LISP con menos memoria (opción -m).\n"

#: spvw_multimap.d:229
msgid "Cannot make %s long enough."
msgstr "No es posible agrandar %s lo suficiente."

#: spvw_multimap.d:246
msgid "Cannot fill %s ."
msgstr "No se puede rellenar %s ."

#: spvw_multimap.d:262
msgid "Cannot close %s ."
msgstr "No se puede cerrar %s ."

#: spvw_multimap.d:297
msgid "Cannot close /dev/zero ."
msgstr "No se puede cerrar /dev/zero ."

#
# Muy buena tu sugerencia, Leo. Se queda tal y como tu propones - lsg
#
# ¿Apoyo o soporte? sv
#
# Bueno, si, tienes razón. De hecho ésta era una de esas traducciones
# "raras". El problema es que no estaba seguro de que el término
# "soporte" fuese aceptado. Pero si es así, pues perfecto - cll
#
#: spvw_multimap.d:332
msgid "Recompile your operating system with SYSV IPC support.\n"
msgstr "Recompile su sistema operativo con soporte para SYSV IPC.\n"

#
# "no se puede asignar un segmento privado en la memoria compartida" - lsg
#
#: spvw_multimap.d:344
msgid "Cannot allocate private shared memory segment."
msgstr "No se puede asignar un segmento privado en la memoria compartida."

#: spvw_multimap.d:365
msgid "Cannot map shared memory to address 0x%x."
msgstr "No se puede asignar la memoria compartida a la direccion 0x%x."

#: spvw_multimap.d:387
msgid "Cannot fill shared memory."
msgstr "No se puede rellenar la memoria compartida."

#: spvw_multimap.d:393
msgid "Could not fill shared memory."
msgstr "No se pudo rellenar la memoria compartida."

#
# En este y en otros tantos mensajes, he seguido tu consejo, Leo. He
# traducido `remove' por `desechar' en todos los sitios. - cll
#
#: spvw_multimap.d:407
msgid "Cannot remove shared memory segment."
msgstr "No se puede desechar el segmento de memoria compartida."

#: spvw_fault.d:446
msgid "mprotect() fails."
msgstr "mprotect() falló."

# "SIGSEGV no puede ser subsanado. Dirección del error =3D 0x%x.\n" - lsg
#
# Si, me gusta más tu traducción. Yo había puesto:
#
# "No se puede evitar SIGSEGV. Dirección de fallo = 0x%x.\n"
#
# Pero el caso es que un SIGSEGV no tiene porque evitarse puesto que es
# una señal que, para cuando sale este mensaje, ya se ha recibido. El
# problema ---realmente--- es que no fue posible "subsanar" la
# señal. Muy bien - cll
#
# De todas formas, prefiero ponerlo al revés ("No se puede subsanar" en
# vez de "... no puede ser subsanado"). Por otra parte, en vez de
# "error" prefiero "fallo" puesto que eso es exactamente de lo que se
# trata. No de un error por algo que alguien hizo mal, sino de un fallo
# del sistema, ... - cll
#
#: spvw_sigsegv.d:30
msgid ""
"\n"
"SIGSEGV cannot be cured. Fault address = 0x%x.\n"
msgstr ""
"\n"
"No se puede subsanar SIGSEGV. Dirección de fallo = 0x%x.\n"

#: spvw_sigsegv.d:68
msgid "Apollo 13 scenario: Stack overflow handling failed. On the next stack overflow we will crash!!!\n"
msgstr "Escenario Apollo 13: Falló la manipulación del desbordamiento de pila. ¡¡¡ Nos estrellaremos en el siguiente desbordamiento de pila !!!\n"

#: spvw_sigint.d:112 spvw_sigint.d:141
msgid "Ctrl-C: User break"
msgstr "Ctrl-C: Interrupción del usuario"

#: spvw_garcol.d:2000
msgid "munmap() fails."
msgstr "munmap() falló."

#: spvw_allocate.d:32
msgid "No more room for LISP objects"
msgstr "No queda espacio para almacenar más objetos LISP"

#
# "*** - no queda espacio para almacenar objetos LISP - REINICIALIZANDO" - lsg
#
# Yo sigo en mis trece, ... Debe ser un imperativo: REINICIE - cll
#
#: spvw_allocate.d:52
msgid ""
"\n"
"*** - No more room for LISP objects: RESET"
msgstr ""
"\n"
"*** - No queda espacio para almacenar más objetos LISP: REINICIE"

#: spvw_allocate.d:255 spvw_allocate.d:314 spvw_allocate.d:389
msgid "Trying to make room through a GC...\n"
msgstr "Intentando obtener más espacio a través de un GC ...\n"

#: spvw_memfile.d:211
msgid "disk full"
msgstr "el disco está lleno"

#
# "error del sistema operativo al cargar el fichero de inicialización `%s'\n" - lsg
#
# Así dicho parece que la culpa ha sido la carga del fichero de
# inicialización, cuando en realidad, el mensaje dice "durante". El
# error puede haber sido algo distinto de la carga. Por ejemplo, la
# carga puede ser correcta pero puede no cargarse en memoria (se me
# ocurre así de pronto), o cualquier otra cosa. Por eso prefiero la
# traducción:
#
# "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"
#
# - cll
#
#: spvw_memfile.d:706
msgid "operating system error during load of initialisation file `%s'\n"
msgstr "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"

#: spvw_memfile.d:1151
msgid "Cannot map the initialisation file into memory."
msgstr "No puedo escribir el fichero de inicialización en memoria."

#: spvw_memfile.d:1399
msgid "operating system error during load of initialisation file\n"
msgstr "error del sistema operativo durante la carga del fichero de inicialización\n"

#: spvw_memfile.d:1405
msgid "initialisation file was not created by this version of LISP\n"
msgstr "el fichero de inicialización no fue creado con esta versión de LISP\n"

#: spvw_memfile.d:1409
msgid "not enough memory for initialisation\n"
msgstr "no hay memoria suficiente para la inicialización\n"

# "~: ~ es una constante, no se puede asignar dinámicamente" - lsg
#
# ¡Bingo! - cll
#
#: eval.d:541
msgid "~: ~ is a constant, cannot be bound dynamically"
msgstr "~: ~ es una constante, no se puede asignar dinámicamente"

#: control.d:2241 eval.d:1444
msgid "Too many documentation strings in ~"
msgstr "Demasiadas cadenas de documentación en ~"

# Quito el guión, ya que en el mensaje siguiente lo tienes sin él. sv
# Otra posibilidad es: falta la lista lambda para ~. sv
#
# Es que de hecho, debe ir sin guión, ... evidentemente. cll
#
# Por otra parte, mejor pensado, me gusta la alternativa que das - cll
#
#: eval.d:1638
msgid "FUNCTION: lambda-list for ~ is missing"
msgstr "FUNCTION: falta la lista lambda de ~"

#
# "FUNCTION: la lista lambda de ~ debe ser una lista, no un(a) ~" - lsg
#
# Lo de "un(a)" no me mola, aunque sin esa palabra el mensaje queda más
# "telegráfico", me parece más apropiado para tratarse del "diálogo con
# un ordenador" :) - cll
#
#: eval.d:1647
msgid "FUNCTION: lambda-list for ~ should be a list, not ~"
msgstr "FUNCTION: la lista lambda de ~ debe ser una lista, no ~"

#: eval.d:1754
msgid "FUNCTION: illegal declaration ~"
msgstr "FUNCTION: declaración inválida ~"

# Duda: Nótese cómo la traducción dice `declararse SPECIAL'. Esto es
# así, porque en Common Lisp existe SPECIAL para declarar variables
# especiales. Por eso, si digo `declararse SPECIAL' estoy diciendo
# `declararse especial con SPECIAL', pero esto último me parece muy
# rebuscado, ¿o es lo correcto?
#
# La traducción es perfectamente fiel. Déjala así. sv
#
# Además, he quitado el "por ello". cll
#: eval.d:1765
msgid "FUNCTION: ~ is not a symbol, cannot be declared SPECIAL"
msgstr "FUNCTION: ~ no es un símbolo, no puede declararse SPECIAL"

#: eval.d:1840
msgid "FUNCTION: too long variable specification after &OPTIONAL: ~"
msgstr "FUNCTION: especificacion de variable demasiado larga despues de &OPTIONAL: ~"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#: eval.d:1876
msgid "FUNCTION: &REST var must be followed by &KEY or &AUX or end of list: ~"
msgstr "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX o del final de lista: ~"

#
# Igualmente: "FUNCTION: &REST debe ir seguido de una variable: ~" - lsg
#
# Pues si, es que cuando uno está mucho tiempo traduciendo del inglés,
# llega un momento en que empieza coger los hábitos de ese lenguaje y
# empieza a expresarse de una manera extraña, ... - cll
#
#: eval.d:1882
msgid "FUNCTION: &REST must be followed by a variable: ~"
msgstr "FUNCTION: &REST debe ir seguido de una variable: ~"

#: eval.d:1931
#, fuzzy
msgid "FUNCTION: ~ in ~ is not a symbol"
msgstr "FUNCTION: ~ en ~ no es una palabra clave"

#: eval.d:1979
msgid "FUNCTION: incorrect variable specification after &KEY: ~"
msgstr "FUNCTION: especificación de variable incorrecta después de &KEY: ~"

#
# Y de nuevo "FUNCTION: &ALLOW-OTHER-KEYS debe ir seguido de &AUX o del
# final de lista: ~" - lsg
#
# Pues si, :) - cll
#
#: eval.d:1986
msgid "FUNCTION: &ALLOW-OTHER-KEYS must be followed by &AUX or end of list: ~"
msgstr "FUNCTION: &ALLOW-OTHER-KEYS debe ir seguido por &AUX o el fin de lista: ~"

#: eval.d:2019
msgid "FUNCTION: too long variable specification after &AUX: ~"
msgstr "FUNCTION: especificacion de variable demasiado larga despues de &AUX: ~"

#: eval.d:2040
msgid "FUNCTION: badly placed lambda-list keyword ~: ~"
msgstr "La palabra clave ~ de la lista lambda está mal situada: ~"

# Sugerencia: may not -> no puede. sv
# Sugerencia: comerse el "y por ello". sv
#: eval.d:2045
msgid "FUNCTION: ~ is not a symbol, may not be used as a variable"
msgstr "FUNCTION: ~ no es un símbolo, no puede usarse como una variable"

# me comería el "y por ello", todo el mundo lo entenderá, y además no
# está en el original. sv
#
# No sólo eso, sino que además el mensaje queda demasiado largo. Será
# mucho más cómodo, para quien esté trabajando, ver mensajes cortos,
# ... sugerencia aceptada. cll
#
#: eval.d:2050
msgid "FUNCTION: ~ is a constant, may not be used as a variable"
msgstr "FUNCTION: ~ es una constante, no puede usarse como una variable"

#: eval.d:2057
msgid "FUNCTION: too many parameters in the lambda-list ~"
msgstr "FUNCTION: demasiados parámetros en la lista lambda ~"

#: eval.d:2064
msgid "FUNCTION: a dot in a lambda-list is allowed only for macros, not here: ~"
msgstr "FUNCTION: sólo en las macros se permite utilizar un punto en la lista lambda, no aquí: ~"

#: eval.d:2138
#, fuzzy
msgid "~: ~ is a special form, not a function"
msgstr "APPLY: ~ es una forma especial, no una función"

#: eval.d:2154 symbol.d:30
msgid "~: ~ is a macro, not a function"
msgstr "~: ~ es una macro, no una función"

#: eval.d:2170
msgid "~: the function ~ is undefined"
msgstr "~: la función ~ no está definida"

#: eval.d:2222 sequence.d:1103
msgid "~: ~ is not a function"
msgstr "~: ~ no es una función"

#: eval.d:2284
msgid "EVAL/APPLY: keyword arguments for ~ should occur pairwise"
msgstr "EVAL/APPLY: los argumentos clave de ~ deben aparecer por pares"

#
# 'Se han pasado demasiados argumentos a ~" - lsg
#
# Bueno, tu traducción es absolutamente válido. Tal vez, algo más
# informal que la mía, por aquello de "pasado" en vez de
# "entregado". Bueno, pues si te parece, esta vez lo dejo como lo tenía
# yo - cll
#
#: eval.d:2296 eval.d:2592
msgid "EVAL/APPLY: too many arguments given to ~"
msgstr "EVAL/APPLY: se han entregado demasiados argumentos a ~"

#: eval.d:2310
#, fuzzy
msgid "EVAL/APPLY: ~ is not a symbol"
msgstr "EVAL/APPLY: ~ no es una palabra clave"

#: eval.d:2334
msgid "EVAL/APPLY: keyword ~ is illegal for ~. The possible keywords are ~"
msgstr "EVAL/APPLY: el argumento clave ~ es inválido en ~. Los posibles argumentos clave son ~"

#
# "EVAL/APPLY: no se han pasado suficientes argumentos a ~" - lsg
#
# Hmmm, ... Si me gusta, es más "explicativo". Si, me gusta, si, si
# Lo único que te trastoco es lo de "pasado" por "entregado". Ya sabes,
# un toque de distinción :) - cll
#
#: eval.d:2516
msgid "EVAL/APPLY: too few arguments given to ~"
msgstr "EVAL/APPLY: no se han entregado suficientes argumentos a ~"

#
# "EVAL: la variable ~ no tiene asignado ningún valor" - lsg
#
# Bueno, he quitado lo de "asignado" porque parece de "perogrullo", pero
# lo demás se queda - cll
#
#: eval.d:2992
msgid "EVAL: variable ~ has no value"
msgstr "EVAL: la variable ~ no tiene ningún valor"

#: eval.d:3021
msgid "EVAL: illegal form ~"
msgstr "EVAL: forma ~ inválida"

#: control.d:99 eval.d:3095 eval.d:4095 eval.d:5003
msgid "~: ~ is not a function name"
msgstr "~: ~ no es el nombre de una función"

# "EVAL: no se han pasado suficientes argumentos a la forma especial ~:~" - lsg
#
# Bueno, pues te digo lo mismo que en el mensaje eval.d:2572, ... - cll
#
#: eval.d:3171
msgid "EVAL: too few parameters for special-form ~: ~"
msgstr "EVAL: no se han entregado suficientes argumentos a la forma especial ~: ~"

#
# "Se han pasado demasiados parámetros a la forma especial ~: ~" - lsg
#
# O sea, que quite lo de "para" y ponga "a". Pues vale, tienes toda la
# razón del mundo - cll
#
#: eval.d:3182
msgid "EVAL: too many parameters for special-form ~: ~"
msgstr "EVAL: se han entregado demasiados parámetros a la forma especial ~: ~"

#: eval.d:3192
msgid "EVAL: dotted parameter list for special form ~: ~"
msgstr "EVAL: la lista de parámetros para la forma especial ~ está punteada: ~"

#
# "EVAL: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Una vez más, te digo lo mismo que en el mensaje eval.d:2572 - cll
#
#: eval.d:3257
msgid "EVAL: too few arguments given to ~: ~"
msgstr "EVAL: no se han entregado suficientes argumentos a ~: ~"

#
# "Se han pasado demasiados argumentos a ~: ~" - lsg
#
# Me gusta más "entregado" que "pasado" - cll
#
#: eval.d:3269
msgid "EVAL: too many arguments given to ~: ~"
msgstr "EVAL: se han entregado demasiados argumentos a ~: ~"

#
# "EVAL: la lista de argumentos pasada a ~ es punteada: ~" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#: eval.d:3281
msgid "EVAL: argument list given to ~ is dotted: ~"
msgstr "EVAL: la lista de argumentos entregada a ~ está punteada: ~"

#: eval.d:4107
msgid "APPLY: argument list given to ~ is dotted"
msgstr "APPLY: la lista de argumentos entregada a ~ está punteada"

#
# "Se han pasado demasiados argumentos a ~" - lsg
#
# Una vez más, me gusta más "entregar" que "pasar" - cll
#
#: eval.d:4118
msgid "APPLY: too many arguments given to ~"
msgstr "APPLY: se han entregado demasiados argumentos a ~"

#
# "APPLY: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Pues eso, que me gusta más "entregar" - cll
#
#: eval.d:4129
msgid "APPLY: too few arguments given to ~"
msgstr "APPLY: se han entregado pocos argumentos a ~"

#
# "el símbolo ~ no tiene valor asignado" - lsg
#
# En algún otro sitio ha aparecido algo parecido a esto. Verás, como me
# parece evidente que si un símbolo no tiene valor, es que no tiene
# valor asignado, pues prefiero omitir lo de "asignado" y evitar que el
# usuario lea términos innecesarios - cll
#
#: eval.d:6541 eval.d:6556
msgid "symbol ~ has no value"
msgstr "el símbolo ~ no tiene valor"

#: eval.d:6570
msgid "assignment to constant symbol ~ is impossible"
msgstr "no pueden realizarse asignaciones sobre el símbolo constante ~"

#
# "~: se ha invocado ~ con demasiados argumentos" - lsg
#
# ¡¡¡ Traducción brillantísima !!! Te ha quedado perfecto. Lo que yo había puesto:
#
# "~: se han entregado demasiados argumentos a ~"
#
# queda como más "indio". Tu traducción me encanta - cll
#
#: control.d:2153 eval.d:7160
msgid "~: too many arguments given to ~"
msgstr "~: se ha invocado ~ con demasiados argumentos"

# Duda: tagbody es de muy difícil traducción.
#       Echando un ojo a la traducción en francés me he encontrado con que está
#       tal cual, ... De momento se queda así hasta que otros miembros del
#       equipo decidan cualquier otra cosa, ...
#
# No es que sepa lo que es, pero, si tag es etiqueta, tagbody podría ser
# "el cuerpo de la etiqueta" (¿tiene sentido esto?), con lo cual, una
# posibilidad sería (para simplificar) "el cuerpo de las etiquetas..." sv
#
# Otra de las propuestas a esta cuestión en la lista de correo
# es@li.org, ha sido: "el contenido de las etiquetas ~ ya ha sido
# abandonado". Esta traducción me gusta, ... cll
#
# ( Desafortunadamente, no recuerdo el nombre de la persona que lo
# sugirió, ... cll )
#
# "(~ ~): ya se ha salido del cuerpo de etiquetas ~" - lsg
#
# Debo rendirme a la evidencia, ... La propuesta de Leo, no solo para
# este término sino todos cuanto se refieren a la traducción de `tag' y
# `tagbody' es perfecta y, además, sigue los pasos de la de Santiago, de
# modo que "moción aceptada" :)
#
#: eval.d:7326 eval.d:7362
msgid "(~ ~): the tagbody of the tags ~ has already been left"
msgstr "(~ ~): ya se ha salido del cuerpo de etiquetas ~"

#: control.d:1874 eval.d:7421
msgid "~: there is no CATCHer for tag ~"
msgstr "~: No hay ningún capturador (CATCH) para la etiqueta de salto ~"

#: eval.d:7443
msgid "STACK corrupted"
msgstr "Pila (STACK) corrupta"

#: eval.d:7768
msgid "~: ~ is not a correct index into ~"
msgstr "~: ~ no es un índice correcto en ~"

#: eval.d:8365
msgid "undefined bytecode in ~ at byte ~"
msgstr "Código de octeto ~ indefinido en el octeto ~"

#: eval.d:8375
msgid "too many return values"
msgstr "Demasiados valores devueltos"

#: eval.d:8382
msgid "Corrupted STACK in ~ at byte ~"
msgstr "Pila corrupta en ~ en el byte ~"

#: control.d:58
msgid "~: function name ~ should be a symbol"
msgstr "~: el nombre de la función ~ debe ser un símbolo"

#: control.d:82
msgid "~: undefined function ~"
msgstr "~: la función ~ no está definida"

#: control.d:118
msgid "~: ~ has no dynamic value"
msgstr "~: ~ no tiene ningún valor dinámico"

#
# "~: ~ no tiene una definición global de función " - lsg
#
# Atención, atención ¿qué es global, la definición o la función?
#
# Yo he traducido:
#
# "~: ~ no tiene ninguna definición global de función"
#
# y la traducción francesa dice:
#
# "~ : ~ n'a pas de définition globale de fonction." - cll
#
#: control.d:156 symbol.d:22
msgid "~: ~ has no global function definition"
msgstr "~: ~ no tiene ninguna definición global de función"

#: control.d:228
msgid "~: the value of the constant ~ may not be altered"
msgstr "~: no puede alterarse el valor de la constante ~"

#: control.d:253
msgid "~ called with odd number of arguments: ~"
msgstr "~ invocado con un número impar de argumentos: ~"

#: control.d:263
msgid "dotted list given to ~ : ~"
msgstr "lista punteada entregada a ~: ~"

#: control.d:354
msgid "~: the value of the constant ~ must not be removed"
msgstr "~: no se debe desechar el valor de la constante ~"

#: control.d:376
msgid "~: the special form definition of ~ must not be removed"
msgstr "~: no se debe desechar la definición de la forma especial de ~"

#: control.d:446
msgid "~: doc-strings are not allowed here: ~"
msgstr "~: aquí no se permiten cadenas de documentación: ~"

#: control.d:513
msgid "~: ~ is not a symbol, but was declared SPECIAL"
msgstr "~: ~ no es un símbolo, pero ha sido declarado SPECIAL"

#: control.d:552 control.d:804
msgid "~: illegal variable specification ~"
msgstr "~: especificación inválida de variable ~"

#: control.d:587
#, fuzzy
msgid "~: symbol ~ is declared special and must not be declared a macro"
msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: control.d:594
msgid "~: symbol ~ must not be declared SPECIAL and a macro at the same time"
msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: control.d:604 control.d:817
msgid "~: ~ is a constant, cannot be bound"
msgstr "~: ~ es una constante, y por ello no puede ligarse"

#: control.d:623
msgid "~: too many variables and/or declarations"
msgstr "~: demasiadas variables y/o declaraciones"

#: control.d:883
msgid "~: ~ is not a function specification"
msgstr "~: ~ no es la especificación de una función"

#: control.d:1025
msgid "~: ~ is not a macro specification"
msgstr "~: ~ no es la especificación de una macro"

#: control.d:1033
msgid "~: macro name ~ should be a symbol"
msgstr "~: el nombre de la macro ~ debe ser un símbolo"

#: control.d:1137
msgid "~: clause ~ should be a list"
msgstr "~: la clausula ~ debe ser una lista"

#: control.d:1168
msgid "~: missing key list: ~"
msgstr "~: falta la lista de claves: ~"

#: control.d:1177
msgid "~: the ~ clause must be the last one"
msgstr "~: la clausula ~ debe ser la última"

#: control.d:1234
msgid "~: the block named ~ has already been left"
msgstr "~: el bloque de nombre ~ ya ha sido abandonado"

#: control.d:1269
msgid "~: no block named ~ is currently visible"
msgstr "~: no hay ningún bloque visible con el nombre ~"

#: control.d:1515
msgid "~: ~ is neither tag nor form"
msgstr "~: ~ no es ni una etiqueta de salto ni una forma"

#: control.d:1557
msgid "~: illegal tag ~"
msgstr "~: etiqueta de salto inválida ~"

#: control.d:1596
msgid "~: tagbody for tag ~ has already been left"
msgstr "~: ya se ha salido del cuerpo de etiquetas de ~"

#: control.d:1611
msgid "~: no tag named ~ is currently visible"
msgstr "~: no hay ninguna etiqueta de salto visible con el nombre ~"

#: control.d:1629
msgid "~: too many values"
msgstr "~: demasiados valores"

#: control.d:1668
msgid "~: too many arguments to ~"
msgstr "~: se han entregado demasiados argumentos a ~"

#: control.d:1909
msgid "Argument ~ is not a macroexpansion environment"
msgstr "El argumento ~ no es un entorno para la expansión de macros"

#: control.d:1965
msgid "declarations ~ are not allowed here"
msgstr "las declaraciones ~ no están permitidas aquí"

#: control.d:1986
msgid "~: ~ evaluated to the values ~, not of type ~"
msgstr "~: La forma ~ ha producido los valores ~, ninguno de los cuales es del tipo ~"

#: control.d:2001
msgid "~: bad declaration ~"
msgstr "~: declaración incorrecta ~"

#: control.d:2104
msgid "~: ~ may not be used as an environment"
msgstr "~: ~ no puede usarse como un entorno"

#: control.d:2234
msgid "no doc-strings allowed here: ~"
msgstr "no se permite la utilización de cadenas de documentación aquí: ~"

#: control.d:2299
msgid "keyword argument list ~ has an odd length"
msgstr "la lista de argumentos clave ~ tiene longitud impar"

#: control.d:2329
msgid "illegal keyword/value pair ~, ~ in argument list. The allowed keywords are ~"
msgstr "par argumento clave/valor inválido ~, ~ en la lista de argumentos. Los parámetros clave permitidos son ~"

#: encoding.d:40
msgid "Character #\\u$$$$ cannot be represented in the character set ~"
msgstr ""

#: encoding.d:198
msgid "character #x$$$$$$$$ in ~ conversion, not a Unicode-16, sorry"
msgstr ""

#: encoding.d:369
msgid "invalid byte #x$$ in ~ conversion, not a Unicode-16"
msgstr ""

#: encoding.d:386
msgid "invalid byte sequence #x$$ #x$$ in ~ conversion"
msgstr ""

#: encoding.d:406
msgid "invalid byte sequence #x$$ #x$$ #x$$ in ~ conversion"
msgstr ""

#: encoding.d:952
msgid "invalid byte #x$$ in ~ conversion"
msgstr ""

#: encoding.d:1291
#, fuzzy
msgid "~: illegal :CHARSET argument ~"
msgstr "~: argumento :TEST inválido ~"

#: encoding.d:1304
#, fuzzy
msgid "~: illegal :LINE-TERMINATOR argument ~"
msgstr "~: argumento :TEST inválido ~"

#: encoding.d:1316
#, fuzzy
msgid "~: illegal :INPUT-ERROR-ACTION argument ~"
msgstr "~: argumento :DIRECTION inválido ~"

#: encoding.d:1328
#, fuzzy
msgid "~: illegal :OUTPUT-ERROR-ACTION argument ~"
msgstr "~: argumento :DIRECTION inválido ~"

#: encoding.d:1371
#, fuzzy
msgid "~: argument ~ is not a character set"
msgstr "~: el argumento ~ no es un carácter"

#: encoding.d:1896
#, fuzzy
msgid "~: ~ is not a 1:1 encoding"
msgstr "~: ~ no es un registro"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#
#: pathname.d:1104 pathname.d:1149
msgid "~: host should be NIL or a string, not ~"
msgstr "~: el anfitrión debe ser, o bien NIL, o una cadena, pero no ~"

#
# Duda: he traducido hostname por "nombre del `host'". ¿Qué os parece?
#
#: pathname.d:1122 pathname.d:1166
msgid "~: illegal hostname ~"
msgstr "~: nombre de anfitrión inválido ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:1188
msgid "~: host should be NIL, not ~"
msgstr "~: el anfitrión debe ser NIL, no ~"

#: pathname.d:1311
msgid "~: argument should be a string, symbol, file stream or pathname, not ~"
msgstr "~: el argumento debe ser o bien una cadena, o un símbolo, o un flujo de fichero o un PATHNAME pero no ~"

#: pathname.d:1349
msgid "~: filename for ~ is unknown"
msgstr "~: el nombre de fichero de ~ es desconocido"

#: pathname.d:1868 pathname.d:2167
msgid "~: there is no environment variable ~"
msgstr "~: no hay ninguna variable de entorno ~"

#: pathname.d:2115
msgid "~: there is no user named ~"
msgstr "~: no hay ningún usuario con el nombre ~"

#: pathname.d:2483
msgid "~: syntax error in filename ~ at position ~"
msgstr "~: error de sintáxis en el nombre del fichero ~, en la posición ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:2496
msgid "~: hosts ~ and ~ of ~ should coincide"
msgstr "~: los anfitriones ~ y ~ de ~ deben coincidir"

#: pathname.d:2721
msgid "~: argument ~ is not a logical pathname, string, stream or symbol"
msgstr "~: el argumento ~ no es un PATHNAME \"lógica\", una cadena de caracteres, un flujo o un símbolo"

#: pathname.d:2776
msgid "~: endless loop while resolving ~"
msgstr "~: bucle infinito para ~"

#: pathname.d:2798
msgid "~: unknown logical host ~ in ~"
msgstr "~: anfitrión ~ desconocido en ~"

#: pathname.d:2810
msgid "~: No replacement rule for ~ is known."
msgstr "~: No se conoce ninguna regla de sustitución para ~."

#: pathname.d:3178
msgid "~: :VERSION-argument should be NIL or a positive fixnum or :WILD or :NEWEST, not ~"
msgstr "~: el argumento :VERSION debe ser NIL, un número positivo del tipo fixnum, :WILD o :NEWEST pero no ~"

#: pathname.d:3204
msgid "~: :VERSION-argument should be NIL or :WILD or :NEWEST, not ~"
msgstr "~: el argumento :VERSION debe ser o bien NIL, o :WILD o :NEWEST, pero no ~"

#: pathname.d:4230
msgid "~: illegal ~ argument ~"
msgstr "~: el argumento de ~ es inválido: ~"

# Duda: Wildcard por comodín, ..., está bien, ¿no?
#
#: pathname.d:4540
msgid "wildcards are not allowed here: ~"
msgstr "Aquí no están permitidos los comodines: ~"

#: pathname.d:4569
msgid "~: argument ~ should be ~, ~, ~, ~, ~, ~ or ~"
msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#: pathname.d:5694
msgid "~: replacement pieces ~ do not fit into ~"
msgstr "~: las piezas de intercambio ~ no caben en ~"

#: pathname.d:5760
msgid "~: ~ is not a specialization of ~"
msgstr "~: ~ no es una especialización de ~"

#: pathname.d:5809
msgid "(~ ~ ~ ~) is ambiguous: ~"
msgstr "(~ ~ ~ ~) es ambiguo: ~"

#: pathname.d:5834
msgid "nonexistent directory: ~"
msgstr "directorio inexistente: ~"

#: pathname.d:5849
msgid "~: File ~ already exists"
msgstr "~: El fichero ~ ya existe"

#: pathname.d:6188 pathname.d:7013
msgid "no directory ~ above ~"
msgstr "no existe el directorio ~ bajo ~"

#: pathname.d:6196
msgid "\"..\\\\\" after \"...\\\\\" is invalid: ~"
msgstr "\"..\\\\\" después de \"...\\\\\" es inválido: ~"

#: pathname.d:6391
msgid "Couldn't access current directory"
msgstr "No se pudo acceder al directorio actual"

#: pathname.d:6538
msgid "~: ~ names a file, not a directory"
msgstr "~: ~ es el nombre de un fichero, no de un directorio"

#: pathname.d:6587 pathname.d:6777 pathname.d:7132
msgid "~: ~ names a directory, not a file"
msgstr "~: ~ es el nombre de un directorio, no de un fichero"

# Casi lo mismo. Bueno, al menos aquí hay dos puntos. sv
#
# Tienes razón. Ahora que veo este mensaje me lío a poner dos puntos en
# los mensajes anteriores. cll
#
#: pathname.d:6631
msgid "UNIX error while GETWD: ~"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Si la tildecilla se sustituye por aquello que devolvió la orden GETWD,
# la frase resultante no tiene mucho sentido.
# Sugerencia: "La ejecución de GETWD en Unix devolvió ~" sv
#
# Hmmm, ..., podría ser, pero verás: en primer lugar, el texto que está
# asociado con la etiqueta "UNIX GETWD returned ~" es "UNIX error while
# GETWD" (fichero pathname.d, línea 6176); segundo, en CLisp se sigue la
# convención de colocar primero un mensaje y después, al final, aquello
# que originó el mensaje y, francamente, no quiero cambiar esta
# convención. Es decir, no quiero faltar al estilo original de los
# autores del programa. cll
#
# Por este motivo, creo que lo más conveniente es dejarlo como está. cll
#
#: pathname.d:6640
msgid "UNIX GETWD returned ~"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Lo mismo. sv
#
# Lo mismo también ;) cll
#
#: pathname.d:6734
msgid "UNIX REALPATH returned ~"
msgstr "Se produjo un error UNIX durante la ejecución de REALPATH: ~"

#: pathname.d:6946
msgid "~: If a device is specified, the directory must begin with ~: ~"
msgstr "~: Si se especifica un dispositivo, el directorio debe comenzar con ~: ~"

#: pathname.d:7334
msgid "no file name given: ~"
msgstr "no se ha entregado ningún nombre de fichero: ~"

#: pathname.d:7347
msgid "not a directory: ~"
msgstr "no es un directorio: ~"

#: pathname.d:7412
msgid "~: file ~ does not exist"
msgstr "~: el fichero ~ no existe"

#: pathname.d:7441
msgid "~: pathname with type but without name makes no sense: ~"
msgstr "~: un PATHNAME con tipo, pero sin nombre, no tiene ningún sentido: ~"

#: pathname.d:7669
msgid "cannot delete file ~ since there is file stream open to it"
msgstr "no se puede borrar el fichero ~ puesto que hay un flujo abierto sobre el"

#: pathname.d:7726
msgid "cannot rename file ~ since there is file stream open to it"
msgstr "no se puede renombrar el fichero ~ puesto que hay un flujo abierto sobre el"

#: pathname.d:8310
msgid "file ~ does not exist"
msgstr "el fichero ~ no existe"

#: pathname.d:8316
msgid "a file named ~ already exists"
msgstr "ya existe un fichero con el nombre ~"

#: pathname.d:8366
msgid "~: illegal :DIRECTION argument ~"
msgstr "~: argumento :DIRECTION inválido ~"

#: pathname.d:8385
msgid "~: illegal :IF-EXISTS argument ~"
msgstr "~: argumento :IF-EXISTS inválido ~"

#: pathname.d:8399
msgid "~: illegal :IF-DOES-NOT-EXIST argument ~"
msgstr "~: argumento :IF-DOES-NOT-EXIST inválido ~"

#: pathname.d:9901
msgid "root directory not allowed here: ~"
msgstr "el directorio raíz no está permitido aquí: ~"

# En la lista de "spanglish" pone:
#
# command                 orden, mandato (NO "comando")
#
# Asi que, muchas gracias Santiago por la indicación, ... - cll
#
#: pathname.d:10641 pathname.d:10685 pathname.d:10745
msgid "~: the command should be a string, not ~"
msgstr "~: la orden debe ser una cadena y no ~"

#: pathname.d:10988
msgid "~: library directory is not known, use a command line option to specify it"
msgstr ""

# Duda: En este mensaje, el primer "~" se sustituye por el nombre de una
# función y el segundo "~" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: stream.d:221 stream.d:15023
msgid "~ on ~ is illegal"
msgstr "~ no es posible sobre el flujo ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#: stream.d:449 stream.d:654
#, fuzzy
msgid "Return value ~ of call to ~ should be an integer between ~ and ~."
msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

#: stream.d:555
msgid "~: the last character read from ~ was not ~"
msgstr "~: el último carácter leído de ~ no era ~"

# Duda: A continuación vienen muchos mensajes que empiezan por "~ from
# ~". Para ayudar en su trabajo a quienes estén revisando este trabajo
# (no me canso de darte las gracias, Santiago, ..., y a quienes se
# animen) aclaro que el primer "~" se sustituye por el nombre de una
# función cuya evaluación (o ejecución, pero esto no es correcto en
# Lisp, ... se prefiere el término evaluación porque se está a nivel de
# intérprete) produce el error; el segundo "~" se refiere al nombre del
# flujo desde el cual se leyó dicha función. Luego, a continuación,
# viene el mensaje de error propiamente dicho.
#
# Por ejemplo, la siguiente instrucción en CLisp:
#
# > (read)
#
# ..., si se teclea:
#
# #<...>
#
# ..., produce el siguiente error: (en español, ya traducido)
#
# *** - READ en #<TERMINAL-STREAM>: los objetos escritos de la manera
# #<...> no pueden volverse a leer
#
# ¿De acuerdo?
#
# A continuación reproduzco un par de mails donde se explica el
# mecanismo general de estos mensajes, a propósito de la pregunta que
# puse en la lista de correo de CLisp:
#
# Mi pregunta fue:
#
# > 21. There are a few messages which begin with "~ from ~". They are
# > very easy to translate but they use a lot of prepositions, and words
# > that could be translated in masculine or feminine. So, I need some
# > real examples of their use.
#
# Las respuestas fueron:
#
#
# ---------------------------------------------------------------------------
# Look in io.d:
#     { pushSTACK(*stream_); # Wert fu:r Slot STREAM von STREAM-ERROR
#       pushSTACK(ch); # Character
#       pushSTACK(*stream_); # Stream
#       pushSTACK(S(read));
#       //: DEUTSCH "~ von ~: Gelesenes Zeichen ist kein String-Char: ~"
#       //: ENGLISH "~ from ~: character read should be a string-char: ~"
#       //: FRANCAIS "~ de ~ : le caracte!re lu n'est pas de type STRING-CHAR."
# The first ~ is the function name, the second the stream that was being
# read from or written to and the third is the character that was read/written.
#
# So it says something like "READ from #<STREAM ...>: illegal character"
#
# 						(Joerg Hoehle)
#
# ---------------------------------------------------------------------------
# A general question here: I thought gettext was coming with an Emacs
# mode called "po-mode", which helps you in translating the messages.
# In particular, there are keystroke commands for showing the C/Lisp source
# surrounding the original reference to a message. From this context,
# you should at least be able to guess the meaning of the objects which
# are substituted for the ~. Note, however, that the first ~ corresponds
# the last pushSTACK command before the string, the second ~ to the
# second-to-last pushSTACK command etc.
#
# 						(Bruno Haible)
#
# ---------------------------------------------------------------------------
#
#: stream.d:564
msgid "~ from ~ without ~ before it"
msgstr "~ en ~ sin ~ antes de él"

#: stream.d:825
msgid "~: cannot output to ~"
msgstr "~: no se puede escribir en ~"

#: stream.d:840
msgid "~ is not a character, cannot be output onto ~"
msgstr "~ no es un carácter, no puede escribirse en ~"

#: stream.d:855
msgid "~ is not an integer, cannot be output onto ~"
msgstr "~ no es un entero, no puede escribirse en ~"

#: stream.d:869
msgid "integer ~ is out of range, cannot be output onto ~"
msgstr "el entero ~ está fuera del dominio, no puede imprimirse en ~"

#: stream.d:919
#, fuzzy
msgid "~: argument ~ should be an input stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: stream.d:936
#, fuzzy
msgid "~: argument ~ should be an output stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: stream.d:1239
msgid "~: argument should be a symbol, not ~"
msgstr "~: el argumento debe ser un símbolo, no ~"

#: stream.d:2158 stream.d:2616
msgid "~ is beyond the end because the string ~ has been adjusted"
msgstr "~ está más allá del final porque la cadena ~ ha sido ajustada"

#: stream.d:2280
msgid "~: ~ is not a string input stream"
msgstr "~: ~ no es un flujo de entrada de cadenas de caracteres"

#: charstrg.d:2575 stream.d:2366
#, fuzzy
msgid "~: ~ argument must be a subtype of ~, not ~"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: stream.d:2399
msgid "~: ~ is not a string output stream"
msgstr "~: ~ no es un flujo de salida de cadenas de caracteres"

# Duda: He traducido `fill pointer' por "puntero de relleno". En
# realidad, los `fill-pointer' son exactamente, eso:
#
# "The fill pointer constitutes the "active length" of the vector; all
# vector elements whose index is less than the fill pointer are active,
# and the others are inactive." (Guy L. Steele, Jr; Common Lisp, The
# Language - 2nd Edition; pag. 454).
#
#: stream.d:2437
msgid "~: argument ~ should be a string with fill pointer"
msgstr "~: El argumento ~ debe ser una cadena con un puntero de relleno"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:2721
msgid "~: ~ is not a buffered input stream"
msgstr "~: ~ no es un flujo de entrada con buffer"

#: stream.d:3023
msgid "~: stream must be a generic-stream, not ~"
msgstr "~: el flujo debe ser un `generic-stream', no ~"

#: stream.d:3107
#, fuzzy
msgid "~: illegal :BUFFERED argument ~"
msgstr "~: argumento :TEST inválido ~"

#: stream.d:3219
msgid "~: illegal :ELEMENT-TYPE argument ~"
msgstr "~: argumento :ELEMENT-TYPE inválido ~"

#: stream.d:3286
#, fuzzy
msgid "~: illegal :EXTERNAL-FORMAT argument ~"
msgstr "~: argumento :TEST inválido ~"

#: stream.d:3697
msgid "~: Ctrl-C: User break"
msgstr "~: Ctrl-C: Interrupción del usuario"

#: stream.d:3744
#, fuzzy
msgid "unknown character set ~"
msgstr "Registro desconocido: ~S"

#: stream.d:5792
msgid "Unbuffered streams need an ~ with a bit size being a multiple of 8, not ~"
msgstr ""

#: stream.d:6183
msgid "Closed ~ because disk is full."
msgstr "Se ha cerrado ~ porque el disco está lleno."

#: stream.d:6358
msgid "cannot position ~ beyond EOF"
msgstr "no es posible colocarse en ~ más allá de EOF"

# Duda: lo del fichero `regular' por `normal'. De hecho, yo juraría que
# en la asignatura de Sistemas Operativos, en mi Facultad, los
# llamábamos "ficheros normales". ¿Qué tal os suena?.
#
#: stream.d:7818
#, fuzzy
msgid "~: argument ~ ~ was specified, but ~ is not a regular file."
msgstr "~: ~ no es un fichero normal."

#: stream.d:7850
msgid "~: arguments ~ ~ and ~ ~ were specified, but ~ is not a regular file."
msgstr ""

# Duda: aqui he traducido de la version francesa (no se frances, pero
# por lo que parece que pone, ...)
#
#: stream.d:7912
msgid "file ~ is not an integer file"
msgstr "el fichero ~ no tiene el formato de un fichero de enteros"

#: stream.d:9696
msgid "character ~ contains bits, cannot be output onto ~"
msgstr "el carácter ~ contiene bits, que no pueden imprimirse en ~"

# Duda: Aunque RAW significa `crudo', y `modo crudo' es una expresión
# muy conocida en español, lo dejo como RAW (y en mayúsuculas), para que
# quede claro que me refiero a la palabra reservada RAW (igual que
# ocurre en la versión original)
#
#: stream.d:10363
msgid "RAW mode not supported on ~"
msgstr "Modo RAW no soportado en ~"

#: stream.d:10743
msgid "~: argument ~ should be a window stream"
msgstr "~: el argumento ~ debe ser un WINDOW-STREAM"

#: stream.d:11547
msgid "cannot output to standard output"
msgstr "no se puede escribir en la salida estándar"

#: stream.d:12796
msgid "environment has no TERM variable"
msgstr "no existe ninguna variable de entorno TERM"

#: stream.d:12801
msgid "terminal type ~ unknown to termcap"
msgstr "No existe ninguna entrada para el tipo de terminal ~ en termcap"

# Duda: Juan Jordana (de la lista de CLisp) propone usar la expresión:
#
# 	Terminal incompleta (o errónea): Terminal de impresora.
#
# 	y me gusta, salvo que prefiero decir a continuación algo del
# 	tipo "usando el modo de impresora" o algo así, ¿no os parece
# 	mejor?
#
#: stream.d:12821
msgid "insufficient terminal: hardcopy terminal"
msgstr "terminal insuficiente: usando el modo de impresora"

# Duda: ¿Pues qué voy a decir? La traducción siguiente es una auténtica
# traducción libre. De todos modos, tanto la versión francesa como la
# alemana (aunque no sé ni alemán ni francés) hacen ---por lo visto---,
# lo que yo: una traducción libre.
#
#: stream.d:12825
msgid "insufficient terminal: overstrikes, cannot clear output"
msgstr "teminal insuficiente: no se puede inicializar la salida"

#: stream.d:12829
msgid "insufficient terminal: cannot scroll"
msgstr "terminal insuficiente: no se puede desplazar la pantalla"

#: stream.d:12834
msgid "insufficient terminal: cannot clear screen"
msgstr "terminal insuficiente: no se puede borrar la pantalla"

#: stream.d:12838
msgid "insufficient terminal: cannot position cursor randomly"
msgstr "terminal insuficiente: no se puede situar el cursor aleatoriamente"

#: stream.d:13294
msgid "~: package SCREEN is not implemented"
msgstr "~: el paquete SCREEN no está implementado"

# Duda: he dejado `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: stream.d:14701
msgid "host should be string, not ~"
msgstr "el anfitrión debe ser una cadena de caracteres y no ~"

# Duda: Pues otra vez como siempre, ..., he dejado `display' tal
# cual. Pienso que todo el mundo sabe lo que es un `display' ¿no?
#
# Por otra parte (como ya sucedió en un mensaje anterior), ..., `fixnum'
# por ser el nombre de un subtipo (o tipo, si se quiere) en Lisp, está
# sin traducir, ...
#
#: stream.d:14709
msgid "display should be a nonnegative fixnum, not ~"
msgstr "el `display' debe ser un entero del tipo FIXNUM >=0, y no ~"

#: stream.d:14750 stream.d:14799
msgid "~: stream must be a socket-stream, not ~"
msgstr "~: el flujo debe ser un `socket-stream' y no ~"

#: stream.d:14811
msgid "~: argument ~ should be a vector of type (ARRAY (UNSIGNED-BYTE 8) (*))"
msgstr "~: el argumento ~ debe ser un vector del tipo (ARRAY (UNSIGNED-BYTE 8) (*)) "

#: io.d:977 stream.d:14832 stream.d:16809 stream.d:17019
msgid "~: input stream ~ has reached its end"
msgstr "~: el flujo de entrada ~ ha alcanzado su final"

#: stream.d:15016
msgid "~: ~ is not a SOCKET-SERVER"
msgstr "~: ~ no es un SOCKET-SERVER"

#: stream.d:15077
#, fuzzy
msgid "~: argument ~ is neither an open SOCKET-STREAM nor a positive FIXNUM"
msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#: stream.d:15256
#, fuzzy
msgid "~: argument ~ is not an open SOCKET-STREAM"
msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#: stream.d:15268
msgid "~: argument ~ is not a SOCKET-STREAM"
msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#: stream.d:15505
msgid "The value of ~ is not a stream: ~"
msgstr "El valor de ~ no es un flujo: ~"

#: stream.d:15510
msgid "The value of ~ is not an appropriate stream: ~"
msgstr "El valor de ~ no es un flujo apropiado: ~"

#: stream.d:15523
msgid "The value of ~ was not a stream: ~. It has been changed to ~."
msgstr "El valor de ~ no era un flujo: ~. Ha sido cambiado por ~."

#: stream.d:15541
msgid "readline library: out of memory."
msgstr "biblioteca readline: la memoria ha sido agotada."

#: stream.d:15738
#, fuzzy
msgid "~: The ~ of ~ cannot be changed from ~ to ~."
msgstr "~: ~ no puede convertirse al tipo ~"

#: stream.d:16303
#, fuzzy
msgid "Return value ~ of call to ~ is not a string."
msgstr "El valor de ~ no es un flujo: ~"

#: stream.d:16752
msgid "Return value ~ of call to ~ is not a fixnum >= 0 or NIL."
msgstr ""

#: stream.d:16770
msgid "~ needs an ~ with a bit size being a multiple of 8, not ~"
msgstr ""

#: stream.d:16790
#, fuzzy
msgid "~: illegal endianness argument ~"
msgstr "~: el argumento de ~ es inválido: ~"

#: stream.d:17249
msgid "~: argument ~ is not an open file stream"
msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#: stream.d:17282
#, fuzzy
msgid "~: position argument should be ~ or ~ or a nonnegative integer, not ~"
msgstr "~: el argumento de posición debe ser ~, ~ o un número no negativo del tipo FIXNUM, pero no ~"

#: socket.d:955
#, fuzzy
msgid "~: ~"
msgstr "~: incorrecto ~"

#: io.d:463
msgid "The value of ~ was not a readtable. It has been reset."
msgstr "El valor de ~ no es una tabla de lectura. Ha sido inicializado/a."

#: io.d:545
msgid "~: argument ~ is not a readtable"
msgstr "~: el argumento ~ no es una tabla de lectura"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
# Al final, por iniciativa de Leo, he cambiado `# macro carácter', que
# no me gustaba demasiado por `macro carácter secundario', que me parece
# mucho mejor. - cll
#
#: io.d:721
msgid "~: ~ is a dispatch macro character"
msgstr "~: ~ es un macro carácter secundario"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:782
msgid "~: ~ is not a dispatch macro character"
msgstr "~: ~ no es un macro carácter secundario"

#: io.d:810
msgid "~: digit $ not allowed as sub-char"
msgstr "~: el dígito $ no está permitido como un sub-carácter"

#: io.d:855
msgid "~: new value ~ should be ~, ~, ~ or ~."
msgstr "~: el nuevo valor ~ debe ser ~, ~, ~ o ~."

#: io.d:891
msgid ""
"The value of ~ should be an integer between 2 and 36, not ~.\n"
"It has been reset to 10."
msgstr ""
"El valor de ~ debe ser un entero entre 2 y 36, no ~.\n"
"Ha sido inicializado a 10."

#: io.d:941
#, fuzzy
msgid "~ from ~: character read should be a character: ~"
msgstr "~ en ~: el carácter leído debe ser un STRING-CHAR: ~"

#: io.d:993
msgid "~: input stream ~ ends within an object. Last opening parenthesis probably in line ~."
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto. El último paréntesis abierto es, probablemente, el de la línea ~."

#: io.d:1000
msgid "~: input stream ~ ends within an object"
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto"

#: io.d:1302
msgid "~ from ~: illegal character ~"
msgstr "~ en ~: carácter inválido ~"

#
# Duda: Lo mismo de antes, he dejado `token' sin traducir
#
#: io.d:1315
msgid "~: input stream ~ ends within a token after single escape character"
msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape simple"

#
# Duda: A ver, ¿la palabra `token'?
#       Mientras no se os ocurra algo mejor, lo he dejado en inglés, ...
#
#: io.d:1362
msgid "~: input stream ~ ends within a token after multiple escape character"
msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape múltiple"

#: io.d:1902
msgid "~ from ~: ~ has no macro character definition"
msgstr "~ en ~: ~ no tiene ninguna definición de macro carácter"

#: io.d:1916
msgid "~ from ~: macro character definition for ~ may not return ~ values, only one value."
msgstr "~ en ~: la definición del macro carácter para ~ no puede devolver ~ valores, sólo puede ser uno."

#: io.d:1940
msgid "~: input stream ~ ends within read macro beginning to ~"
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba una macro de lectura en ~"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:1970
msgid "~ from ~: After ~ is ~ an undefined dispatch macro character"
msgstr "~ en ~: Después de ~ está ~, que no es un macro carácter secundario"

#: io.d:1984
msgid "~ from ~: dispatch macro character definition for ~ after ~ may not return ~ values, only one value."
msgstr "~ en ~: la definición del macro carácter secundario de ~ después de ~ sólo puede devolver un valor, no ~"

# Duda: He traducido `token' tal cual, ... Santiago, imagino que la
# palabra token se queda tal cual. Quiero decir, ¿es necesario lo de las
# comillas? - cll
#
#: io.d:2057
msgid "~ from ~: a token consisting only of dots cannot be meaningfully read in"
msgstr "~ en ~: no puede leerse correctamente un `token' que consiste únicamente en puntos"

# Duda: Todo el mundo sabe que `colon' es el signo de dos puntos
# `:'. Bueno, pues la traducción del siguiente mensaje podría ser algo
# del estilo: "demasiados signos de dos puntos en el token ...", sin
# embargo, me ha parecido mejor poner los dos puntos directamente, ...
#
#: io.d:2154
msgid "~ from ~: too many colons in token ~"
msgstr "~ en ~: demasiados `:' en el `token' ~"

#: io.d:2203
msgid "~ from ~: there is no package with name ~"
msgstr "~ en ~: no existe ningún paquete con el nombre ~"

#: io.d:2233
msgid "~ from ~: ~ has no external symbol with name ~"
msgstr "~ en ~: ~ no tiene ningún símbolo externo con el nombre ~"

#: io.d:2277
msgid "~ from ~: token \".\" not allowed here"
msgstr "~ en ~: el `token' \".\" no está permitido aquí"

#: io.d:2326 io.d:6150
msgid "~: the value of ~ has been arbitrarily altered"
msgstr "~: el valor de ~ ha sido arbitrariamente alterado"

#: io.d:2341
msgid "~: no entry for ~ from ~ in ~ = ~"
msgstr "~: no existe ninguna entrada para ~ de ~ en ~ = ~"

#: io.d:2539
msgid "~ from ~: illegal end of dotted list"
msgstr "~ en ~: fin de lista punteada inválido"

#: io.d:2610
msgid "~ from ~: an object cannot start with ~"
msgstr "~ en ~: un objeto no puede comenzar por ~"

#: io.d:2693
msgid "~: input stream ~ ends within a string"
msgstr "~: el flujo de entrada ~ termina con una cadena"

#: io.d:2754
msgid "~ from ~: no number allowed between # and $"
msgstr "~ en ~: no debe haber ningún número entre # y $"

#: io.d:2846
msgid "~: input stream ~ ends within a comment #$ ... $#"
msgstr "~: el flujo de entrada ~ termina dentro un comentario #$ ... $#"

#: io.d:2925
#, fuzzy
msgid "~ from ~: font number ~ for character is too large, should be = 0"
msgstr "~ en ~: el número ~ para la fuente de caracteres es demasiado grande, debe ser < ~"

# Duda: Vamos a ver, ... porque esto es muy curioso, ... En Common Lisp,
# los caracteres tienen tres atributos (Common Lisp, The Language, 2nd
# Edition - Guy L. Steel, página 374): código, bits y fuente. El
# atributo "bits" se refiere a otras señales que se pueden activar por
# la pulsación simultánea de varias teclas (o sea, el Control, Mays,
# etc.) Para identificar convenientemente las pulsaciones simultáneas de
# teclas con las que se conocen como teclas de control, existen
# "nombres" (he aquí el quiz de la cuestión, ...) para referirse a
# dichas combinaciones.
#
# Bueno, pues este es, entonces, el problema para traducir "character
# bit with name". La verdad, no me extraña que los indios hablasen como
# hablaban, ... esto no puede ser más críptico :)
#
# Yo he optado por "nombre para los bits de carácter", ... ¿qué os
# parece? - cll
#
#: io.d:2955
msgid "~ from ~: there is no character bit with name ~"
msgstr "~ en ~: no hay ningún nombre para los bits de carácter que sea ~"

#: io.d:3014
msgid "~ from ~: there is no character with name ~"
msgstr "~ en ~: no hay ningún carácter con el nombre ~"

#: io.d:3075
msgid "~ from ~: token ~ after #$ is not a rational number in base ~"
msgstr "~ en ~: el `token' ~ después de #$ no es un número racional en base ~"

#: io.d:3141
msgid "~ from ~: the number base must be given between # and R"
msgstr "~ en ~: el número de la base debe estar entre # y R"

#: io.d:3156
msgid "~ from ~: The base ~ given between # and R should lie between 2 and 36"
msgstr "~ en ~: La base ~ entre # y R debe estar entre 2 y 36"

#: io.d:3200
msgid "~ from ~: bad syntax for complex number: #C~"
msgstr "~ en ~: sintaxis incorrecta del número complejo: #C~"

#: io.d:3232
msgid "~ from ~: token expected after #:"
msgstr "~ en : ~: se esperaba un `token' después de #:"

#: io.d:3258
msgid "~ from ~: token ~ after #: should contain no colon"
msgstr "~ en ~: el `token' ~ después de #: no debe contener dos puntos"

#: io.d:3308
msgid "~ from ~: only zeroes and ones are allowed after #*"
msgstr "~ en ~: sólo se permiten ceros y unos después de #*"

#: io.d:3337
msgid "~ from ~: bit vector is longer than the explicitly given length ~"
msgstr "~ en ~: la longitud del vector de bits es mayor que la longitud explícitamente indicada ~"

#: io.d:3346
msgid "~ from ~: must specify element of bit vector of length ~"
msgstr "~ en ~: debe especificar un elemento para el vector de bits de longitud ~"

#: io.d:3420
msgid "~ from ~: vector is longer than the explicitly given length ~"
msgstr "~ en ~: el vector tiene una longitud mayor que la explícitamente indicada ~"

#: io.d:3429
msgid "~ from ~: must specify element of vector of length ~"
msgstr "~ en ~: debe especificar un elemento para el vector de longitud ~"

#: io.d:3509
msgid "~ from ~: bad syntax for array: #A~"
msgstr "~ en ~: sintaxis incorrecta en la matriz: #A~"

#: io.d:3572
msgid "~ from ~: ~ = ~ doesn't allow the evaluation of ~"
msgstr "~ en ~: ~ = ~ no permite la evaluación de ~"

#: io.d:3691
msgid "~ from ~: a number must be given between # and $"
msgstr "~ en ~: debe indicarse un número entre # y $"

#: io.d:3703
msgid "~ from ~: label #~? too large"
msgstr "~ en ~: la etiqueta #~? es demasiado grande"

# Duda: En Common Lisp existe lo que se denominan "Listas de asociación"
# (Common Lisp, The Language, 2nd Edition - Guy L. Steel, página 431) o,
# en inglés, "Association Lists" que abreviadamente se conocen como
# "alist" o "a-list". En realidad, aunque en español, mucha gente dice
# "alistas", esto no me parece correcto y me parece mucho más formal
# decir "listas de asociación".
#
# De hecho, el término "listas de asociación" será facílisimamente
# reconocible por el programador, mientras que "alista" exige estar un
# poquito más experimentado con el Lisp.
#
# Más aún, los traductores del libro "Lisp" (3ra edición) de Winston y
# Horn, utilizan la expresión "lista de asociación" en la presentación
# de la función ASSOC en la página 34, aunque luego también se refieran
# a ellas como "listas-a".
#
#: io.d:3725
msgid "~ from ~: the value of ~ has been altered arbitrarily, it is not an alist: ~"
msgstr "~ en ~: el valor de ~ ha sido modificado arbitrariamente, no es una lista de asociación: ~"

#: io.d:3742
msgid "~ from ~: label #~= may not be defined twice"
msgstr "~ en ~: la etiqueta #~= no puede definirse dos veces"

#: io.d:3768
msgid "~ from ~: #~= #~# is illegal"
msgstr "~ en ~: #~= #~# no está permitido"

#: io.d:3793
msgid "~ from ~: undefined label #~#"
msgstr "~ en ~: la etiqueta #~# no está definida"

#: io.d:3809
msgid "~ from ~: objects printed as #<...> cannot be read back in"
msgstr "~ en ~: los objetos escritos de la manera #<...> no pueden volverse a leer"

#: io.d:3826
msgid "~ from ~: objects printed as # in view of ~ cannot be read back in"
msgstr "~ en ~: los objetos escritos como # a causa de ~ no pueden volverse a leer"

# Duda: `feature' puede ser característica, propiedad, ... Yo me he
# decidido por la última. Sin embargo, ¿hay algún término oficial para
# esta palabra (muy común, por cierto)?
#
#: io.d:3906
msgid "~ from ~: illegal feature ~"
msgstr "~ en ~: propiedad inválida ~"

#: io.d:4037
msgid "~ from ~: #S must be followed by the type and the contents of the structure, not ~"
msgstr "~ en ~: #S debe estar seguido del tipo y contenidos de la estructura, no ~"

#: io.d:4049
msgid "~ from ~: the type of a structure should be a symbol, not ~"
msgstr "~ en ~: el tipo de una estructura debe ser un símbolo, no ~"

#: io.d:4063
msgid "~ from ~: bad HASH-TABLE"
msgstr "~ en ~: HASH-TABLE incorrecta"

#: io.d:4090
msgid "~ from ~: bad ~"
msgstr "~ en ~: ~ es incorrecto"

#: io.d:4119
msgid "~ from ~: no structure of type ~ has been defined"
msgstr "~ en ~: no se ha definido ninguna estructura del tipo ~"

#: io.d:4130
msgid "~ from ~: bad ~ for ~"
msgstr "~ en ~: ~ es incorrecto en ~"

#: io.d:4142
msgid "~ from ~: structures of type ~ cannot be read in, missing constructor function"
msgstr "~ en ~: las estructuras del tipo ~ no pueden leerse, no se conoce la función de construcción"

#: io.d:4161
msgid "~ from ~: a structure ~ may not contain a component \".\""
msgstr "~ en ~: una estructura ~ no debe contener un componente \".\""

#: io.d:4172
msgid "~ from ~: ~ is not a symbol, not a slot name of structure ~"
msgstr "~ en ~: ~ no es un símbolo, ni el nombre de una ranura ni una estructura ~"

#: io.d:4182
msgid "~ from ~: missing value of slot ~ in structure ~"
msgstr "~ en ~: falta el valor de la ranura ~ en la estructura ~"

#
# Duda: slots se queda tal cual, ...
#
# De acuerdo con la lista spanglish, `slot' se traducirá, en todo el
# CLisp, como "ranura".
#
#: io.d:4202
msgid "~ from ~: too many slots for structure ~"
msgstr "~ en ~: hay demasiadas ranuras en la estructura ~"

#
# "~ en ~: sintaxis inválida del vector de código de recinto tras #~Y" - lsg
#
# Hmmm, no me acaba de gustar, ... - cll
#
#: io.d:4248
msgid "~ from ~: illegal syntax of closure code vector after #~Y"
msgstr "~ en ~: sintaxis inválida del vector de código de la cerradura después de #~Y"

#: io.d:4298
msgid "~ from ~: object #Y~ has not the syntax of a compiled closure"
msgstr "~ en ~: el objeto #Y~ no tiene la sintaxis de una cerradura compilada"

#
# pathname NO es array!
# "~ en ~: sintaxis incorrecta en nombre de path: #A~" - lsg
#
# Si, es verdad, aquí se me había ido la mano, ...
#
# Además, PATHNAME no se traduce puesto que, o bien se refiere al tipo
# de datos PATHNAME o a la función PATHNAME (en este caso, al tipo de
# datos). Como ambos términos están definidos en el estándar de Common
# Lisp: Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr., pues
# no se traduce y se pone en mayúsculas para distinguirlo de otros
# términos. - cll
#
#: io.d:4432
msgid "~ from ~: bad syntax for pathname: #P~"
msgstr "~ en ~: la sintaxis del PATHNAME: #P~ es incorrecta"

#: io.d:4631 io.d:9545
msgid "~: ~ is not a character"
msgstr "~: ~ no es un carácter"

# Nota: El siguiente mensaje se debe a la función PEEK-CHAR (Common
# Lisp, The Language - 2nd Edition; Guy L. Steele, Jr; pag. 574), que
# realiza la lectura del siguiente objeto de un flujo de caracteres
# según el valor de su primer argumento opcional `peek-type' que solo
# puede valer, como reza el mensaje, NIL, T o un carácter.
#
#: io.d:4675
msgid "~: peek type should be NIL or T or a character, not ~"
msgstr "~: el tipo del PEEK solo puede ser NIL, T o un carácter, y no ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#: io.d:4823
msgid "~: ~ argument should be an integer between 2 and 36, not ~"
msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

# "~: la cadena ~ no tiene sintaxis de entero" - lsg
#
# He cambiado lo "de entero" por "de un número entero", que parece más
# inteligible - cll
#
#: io.d:4914
msgid "~: string ~ does not have integer syntax"
msgstr "~: la cadena ~ no tiene la sintaxis de un número entero"

#: io.d:5077
msgid "~: Despite of ~, ~ cannot be printed readably."
msgstr "~: A pesar de ~, ~ no puede imprimirse de manera legible."

#: io.d:5102
msgid ""
"~: the value ~ of ~ is neither ~ nor ~ nor ~.\n"
"It is reset to ~."
msgstr ""
"~: el valor ~ de ~ no es ~ ni ~ ni ~.\n"
"Ha sido inicializado a ~."

#: io.d:5510
msgid "~: must be a positive integer or NIL, not ~"
msgstr "~: debe ser un número positivo entero o NIL, pero no ~"

# "~: espacio insuficiente en la pila para realizar un análisis de circularidad" - lsg
#
# Vale - cll
#
#: io.d:6359
msgid "~: not enough stack space for carrying out circularity analysis"
msgstr "~: no hay espacio suficiente en la pila para realizar un análisis de circularidad"

#: io.d:7939
msgid "~: bad ~"
msgstr "~: incorrecto ~"

#: io.d:8053 record.d:225
msgid "~: ~ is not a structure"
msgstr "~: ~ no es una estructura"

#: io.d:8855
msgid "~: an unknown record type has been generated!"
msgstr "~: se ha generado un tipo de registro desconocido!"

#
# ¡¡Large no es largo, sino grande!! - lsg
#
# Tienes toda la razón, ya lo he cambiado en todos los mensajes - cll
#
#: array.d:226
msgid "index too large"
msgstr "índice demasiado grande"

# FIXME. Esto no cabe en 80 columnas. Comunicar al autor (?) sv
#
# "Una formación ha sido acortada mediante un ajuste al trasladar otra formación hacia ella"
# O bien, para que quepa en 80 columnas:
# "Una formación ha sido acortada al trasladar otra formación hacia ella" - lsg
#
# Yo había puesto:
#
# "Una matriz ha sido acortada debido a un ajuste cuando otra se ha desplazado "
# "hacia ella"
#
# Y ciertamente me gusta más tu traducción, salvo que en vez de
# formaciones hay que hablar de matrices, ¿no crees? - cll
#
#: array.d:234
msgid "An array has been shortened by adjusting it while another array was displaced to it."
msgstr "Una matriz ha sido acortada al trasladar otra matriz ella"

# "~: ~ no es una formación" - lsg
#
# Aunque en la lista de spanglish.txt pone "formación", en este caso
# creo que será mucho más conveniente poner "matriz" porque de hecho,
# los mensajes se refieren a matrices, ... - cll
#
#: array.d:333
msgid "~: ~ is not an array"
msgstr "~: ~ no es una matriz"

#: array.d:367 foreign.d:2216
msgid "~: got ~ subscripts, but ~ has rank ~"
msgstr "~: se encontraron ~ subíndices, pero ~ tiene rango ~"

#: array.d:384 foreign.d:2233
msgid "~: subscripts ~ for ~ are not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: los subíndices ~ de ~ no son del tipo '(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:411 foreign.d:2244
msgid "~: subscripts ~ for ~ are out of range"
msgstr "~: los subíndices ~ de ~ han excedido el rango"

#: array.d:471
msgid "~: index ~ for ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: el índice ~ de ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:491
msgid "~: index ~ for ~ is out of range"
msgstr "~: el índice ~ de ~ ha excedido el rango"

#: array.d:656
msgid "~: ~ does not fit into ~, bad type"
msgstr "~: ~ no cabe en ~, tipo incorrecto"

#: array.d:847
msgid "~: ~ is not an nonnegative integer less than the rank of ~"
msgstr "~: ~ no es un entero no negativo menor que el rango de ~"

#: array.d:1040
msgid "~: ~ is not an array of bits"
msgstr "~: ~ no es una matriz de bits"

#: array.d:1551
msgid "~: The arguments ~ and ~ should be arrays of bits with the same dimensions"
msgstr "~: Los argumentos ~ y ~ deben ser matrices de bits de la misma dimensión"

#: array.d:1561
msgid "~: The arguments ~, ~ and ~ should be arrays of bits with the same dimensions"
msgstr "~: Los argumentos ~, ~ y ~ deben ser matrices de bits de la misma dimensión"

#: array.d:1697
msgid "~: vector ~ has no fill pointer"
msgstr "~: el vector ~ no tiene ningún puntero de relleno"

#: array.d:1743
msgid "~: ~ has length zero"
msgstr "~: ~ tiene longitud nula"

#: array.d:1772
msgid "~ works only on adjustable arrays, not on ~"
msgstr "~ funciona sólo con matrices ajustables, no con ~"

#: array.d:1790
msgid "~: extension ~ should be a positive fixnum"
msgstr "~: la extensión ~ debe ser un número positivo del tipo FIXNUM"

#: array.d:1813
msgid "~: extending the vector by ~ elements makes it too long"
msgstr "~: ampliar el vector en ~ elementos, lo hace muy grande"

#: array.d:1904
msgid "~: cannot push ~ into array ~ (bad type)"
msgstr "~: no se puede introducir ~ en la matriz ~ (tipo incorrecto)"

#: array.d:2185
msgid "~: dimension ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: la dimensión ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:2226
msgid "~: dimensions ~ produce too large total-size"
msgstr "~: las dimensiones ~ producen un tamaño total demasiado grande"

#: array.d:2260
msgid "~: ambiguous, more than one initialisation specified"
msgstr "~: ambiguo, se ha especificado más de una inicialización"

#: array.d:2271
msgid "~: ~ must not be specified without ~"
msgstr "~: ~ no debe especificarse sin ~"

#: array.d:2386
msgid "~: the initial-element ~ is not of type ~"
msgstr "~: el INITIAL-ELEMENT ~ no es del tipo ~"

#: array.d:2470
msgid "~: ~ is of incorrect length"
msgstr "~: ~ no tiene la longitud correcta"

#: array.d:2500
msgid "~: ~-argument ~ is not an array"
msgstr "~: El ~ argumento ~ no es una matriz"

#: array.d:2527
msgid "~: ~-argument ~ does not have element type ~"
msgstr "~: El ~ argumento ~ no tiene como tipo de elemento ~"

#: array.d:2542
msgid "~: ~-argument ~ is not of type `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"
msgstr "~: El ~ argumento ~ no es del tipo `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"

#: array.d:2553
msgid "~: array-total-size + displaced-offset (= ~) exceeds total size ~ of ~-argument"
msgstr "~: array-total-size + displaced-offset (= ~) excede el tamaño total ~ del ~ argumento"

#: array.d:2577
msgid "~: fill-pointer ~ should be a nonnegative fixnum"
msgstr "~: El puntero de relleno ~ debe ser un número no negativo del tipo FIXNUM"

#: array.d:2587
msgid "~: fill-pointer argument ~ is larger than the length ~"
msgstr "~: El argumento FILL-POINTER ~ es mayor que la longitud ~"

#
# "~: el rango intentado ~ es demasiado grande" - lsg
#
# De acuerdo - cll
#
#: array.d:2657
msgid "~: attempted rank ~ is too large"
msgstr "~: el rango intentado ~ es demasiado grande"

#: array.d:2671
msgid "~: ~ may not be specified for an array of rank ~"
msgstr "~: ~ no debe especificarse para una matriz de rango ~"

#: array.d:2854
msgid "~: array ~ is not adjustable"
msgstr "~: la matriz ~ no es ajustable"

#: array.d:2876
msgid "~: rank ~ of array ~ cannot be altered: ~"
msgstr "~: no es posible cambiar el rango ~ de la matriz ~: ~"

#
# "~: los elementos de la formación ~ no son de tipo ~" - lsg
#
# Una excelente traducción. Lo único que hago es cambiar "formación" por
# "matriz" y listo - cll
#
#: array.d:2891
msgid "~: array ~ does not have element-type ~"
msgstr "~: los elementos de la matriz ~ no son del tipo ~"

#: array.d:2946
msgid "~: cannot displace array ~ to itself"
msgstr "~: no se puede desplazar la matriz ~ hacia ella misma"

#: array.d:2968
msgid "~: array ~ has no fill-pointer"
msgstr "~: la matriz ~ no tiene ningún puntero de relleno"

#: array.d:2984
msgid "~: the fill-pointer of array ~ is ~, greater than ~"
msgstr "~: el puntero de relleno de la matriz ~ es ~ que es mayor que ~"

# ... de la misma forma que uno no pone "START Índice" sv
#
# Si, si, ..., tienes toda la razón, ... cll
#
#: array.d:3114
msgid "Illegal START index ~ for ~"
msgstr "Índice START ~ inválido en ~"

#: array.d:3148
msgid "Illegal END index ~ for ~"
msgstr "Índice END ~ inválido en ~"

#: array.d:3161
msgid "~: invalid bit-vector length ~"
msgstr "~: la longitud de BIT-VECTOR ~ es inválida"

# Duda: hash lo he traducido por hash. ¿Alguna sugerencia? ¿Tablas de
# acceso rápido, o algo así?. Tened en cuenta que en Common Lisp, las
# tablas hash son una estructura bien definida que cuenta con sus
# propias instrucciones. A mí me gusta tal cual, ...
# Sugerencia: tabla de `hash'. sv
#
# No, no, no, no, ... :) `hash table' es `tabla hash'. Si se quiere,
# podríamos traducir la palabra `hash' pero si se deja es `tabla
# hash'. Todos los informáticos las llamamos así. Jamás he oído `Tabla
# *de* hash' cll
#
#: hashtabl.d:1065
msgid "Hash table size ~ too large"
msgstr "La tabla hash ~ es demasiado grande"

#
# "error interno al redimensionar ~" - lsg
#
# Me gusta, salvo que el error ocurre "durante" - cll
#
#: hashtabl.d:1110
msgid "internal error occured while resizing ~"
msgstr "error interno durante el redimensionamiento de ~"

#: hashtabl.d:1216
msgid "~: illegal :TEST argument ~"
msgstr "~: argumento :TEST inválido ~"

#: hashtabl.d:1231
msgid "~: :SIZE argument should be a fixnum >=0, not ~"
msgstr "~: el argumento :SIZE debe ser del tipo FIXNUM >= 0, no ~"

#: hashtabl.d:1251
msgid "~: :REHASH-SIZE argument should be a float > 1, not ~"
msgstr "~: el argumento :REHASH-SIZE debe ser del tipo FLOAT > 1, no ~"

#: hashtabl.d:1294
msgid "~: :REHASH-THRESHOLD argument should be a float between 0 and 1, not ~"
msgstr "~: el argumento :REHASH-THRESHOLD debe ser un número del tipo FLOAT entre 0 y 1, no ~"

#: hashtabl.d:1365
msgid "~: internal error while building ~"
msgstr "~: error interno durante la construcción de ~"

#: hashtabl.d:1406
msgid "~: argument ~ is not a hash-table"
msgstr "~: el argumento ~ no es una tabla hash"

#: list.d:521
msgid "~: ~ is not a nonnegative fixnum and therefore not a valid index"
msgstr "~: ~ no es un FIXNUM no negativo y por ello, no es un índice válido"

#: list.d:594
msgid "~: ~ is not a nonnegative integer and therefore not a valid argument"
msgstr "~: ~ no es un entero no negativo y por ello, no es un argumento válido"

#: list.d:711
msgid "~: ~ is not a nonnegative fixnum and therefore not a valid list length"
msgstr "~: ~ no es un FIXNUM no negativo y por ello, no es una longitud de lista válida"

#: list.d:982
msgid "~: ~ is not a pair"
msgstr "~: ~ no es un par"

#: list.d:1628
msgid "~: lists ~ and ~ are not of same length"
msgstr "~: las listas ~ y ~ no son de la misma longitud"

#: list.d:1820
msgid "~: index ~ too large for ~"
msgstr "~: el índice ~ es demasiado grande para ~"

#: list.d:1876
msgid "~: start index ~ too large for ~"
msgstr "~: el índice :START ~ es demasiado grande para ~"

#: list.d:1919
msgid "~: end index ~ too large for ~"
msgstr "~: el índice :END ~ es demasiado grande para ~"

#: package.d:358
msgid "symbol ~ cannot be deleted from symbol table"
msgstr "el símbolo ~ no puede ser borrado de la tabla de símbolos"

#: package.d:729
msgid "~ inconsistent: symbol ~ is a shadowing symbol but not present"
msgstr "inconsistencia en ~: el símbolo ~ es un símbolo que eclipsa a otro/s, sin embargo no está presente."

#: package.d:1191
msgid "UNEXPORT in ~ is illegal"
msgstr "UNEXPORT en ~ es inválido"

#
# "UNEXPORT sólo funciona con símbolos accesibles, no con ~ en ~" - lsg
#
# Ya, o sea, que cambie "sobre" por "con". Vale, me gusta mucho más tu
# mensaje que el mío - cll
#
#: package.d:1215
msgid "UNEXPORT works only on accessible symbols, not on ~ in ~"
msgstr "UNEXPORT sólo funciona sobre símbolos accesibles, no con ~ en ~"

#: package.d:1817
msgid "The value of *PACKAGE* was not a package. Old value ~. New value ~."
msgstr "El valor de *PACKAGE* no era un paquete. Valor anterior ~. Nuevo valor ~."

#: package.d:1836
msgid "Package ~ has been deleted."
msgstr "El paquete ~ ha sido borrado."

#: package.d:1846
msgid "There is no package with name ~"
msgstr "No hay ningún paquete con el nombre ~"

#: package.d:1855
msgid "~: argument should be a package or a package name, not ~"
msgstr "~: el argumento debe ser un paquete o el nombre de un paquete, no ~"

#: package.d:1866
msgid "~: argument should be a string, not ~"
msgstr "~: el argumento debe ser una cadena de caracteres, no ~"

#: package.d:1886
msgid "~: argument ~ should be a string or a symbol"
msgstr "~: el argumento ~ debe ser una cadena o un símbolo"

#: package.d:1984
msgid "~: there is already a package named ~"
msgstr "~: ya hay un paquete llamado ~"

#: package.d:2105 predtype.d:1771
msgid "~: argument ~ is not a symbol"
msgstr "~: el argumento ~ no es un símbolo"

#
# "~: el argumento debe ser un símbolo o una lista de símbolos, no ~" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: package.d:2154
msgid "~: argument should be a symbol or a list of symbols, not ~"
msgstr "~: el argumento debe ser un símbolo o una lista de símbolos, no ~"

#: package.d:2366
msgid "Cannot change the case sensitiveness of ~."
msgstr "No es posible cambiar las mayúsculas/minúsculas de ~."

#: record.d:33
msgid "~: ~ is not a valid index into ~"
msgstr "~: ~ no es un índice válido en ~"

#: record.d:44
msgid "~: ~ is not a record"
msgstr "~: ~ no es un registro"

#: record.d:104
msgid "~: length ~ is illegal, should be of type (INTEGER (0) (65536))"
msgstr "~: la longitud ~ es inválida, debe ser del tipo (INTEGER (0) (65536))"

#: record.d:141
msgid "~: ~ is not a structure of type ~"
msgstr "~: ~ no es una estructura del tipo ~"

#: record.d:188
#, fuzzy
msgid "~: Slot ~ of ~ has no value"
msgstr "~: Una ranura de ~ no tiene valor"

#: record.d:287
msgid "~: ~ is not a closure"
msgstr "~: ~ no es una cerradura"

#: record.d:300
msgid "~: This is not a compiled closure: ~"
msgstr "~: No se trata de una cerradura compilada: ~"

#: record.d:371
msgid "~ is not a valid code-vector byte"
msgstr "~ no es un byte CODE-VECTOR válido"

#: record.d:387
msgid "~: invalid code-vector ~"
msgstr "~: CODE-VECTOR inválido ~"

#: record.d:397
msgid "~: function ~ is too big: ~"
msgstr "~: la función ~ es demasiado grande: ~"

#: record.d:425 record.d:467
msgid "~: This is not a generic function: ~"
msgstr "~: Ésta no es una función genérica: ~"

#: record.d:435
#, fuzzy
msgid "~: This is not a prototype of a generic function: ~"
msgstr "~: Ésta no es una función genérica: ~"

#: record.d:576
#, fuzzy
msgid "~: ~ is not a weak pointer"
msgstr "~: ~ no es un puntero de pila"

#: record.d:639
msgid "~: ~ is not a class"
msgstr "~: ~ no es una clase"

#: record.d:674
#, fuzzy
msgid "ALLOCATE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "SHARED-INITIALIZE: la lista de argumentos clave ~ tiene longitud impar"

#
# Yo pondría un guión entre argumento y clave. - lsg
#
# Hmm, o sea `argumento-clave'. No, no me gusta y de hecho, en el
# "Vocabulario bilingüe de términos técnicos" de "Lisp" (3ra edición) de
# Winston y Horn, los traductores al español ponen en la página 649:
#
# keyword arguments - argumentos clave
#
# sin guión por medio - cll
#
#: record.d:865
msgid ""
"~: illegal keyword/value pair ~, ~ in argument list.\n"
"The allowed keywords are ~"
msgstr ""
"~: par argumento clave/valor inválido ~, ~ en la lista de argumentos.\n"
"Los parámetros clave permitidos son ~"

#: record.d:899
msgid "SHARED-INITIALIZE: keyword argument list ~ has an odd length"
msgstr "SHARED-INITIALIZE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:1013
msgid "REINITIALIZE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "REINITIALIZE-INSTANCE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:1112
msgid "INITIALIZE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "INITIALIZE-INSTANCE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:1239
msgid "MAKE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "MAKE-INSTANCE: la lista de argumentos clave ~S tiene longitud impar"

#: record.d:1300
msgid "~ method for ~ returned ~"
msgstr ""

#: sequence.d:219
msgid "There are no sequences of type ~"
msgstr "No hay secuencias del tipo ~"

#: sequence.d:266
msgid "~ is not a sequence"
msgstr "~ no es una secuencia"

#: sequence.d:283
msgid "sequence type forces length ~, but result has length ~"
msgstr ""

#: sequence.d:299
msgid "~: ~ should be an integer >=0, not ~"
msgstr "~: ~ debe ser un entero >=0, no ~"

#: sequence.d:350 sequence.d:381
msgid "~: ~ = ~ should not be greater than ~ = ~"
msgstr "~: ~ = ~ no debe ser mayor que ~ = ~"

#: sequence.d:494
msgid "~: the index should be a fixnum >=0, not ~"
msgstr "~: el índice debe ser un número >=0 del tipo FIXNUM, no ~"

#: sequence.d:511
msgid "~ ~: the index should be a fixnum >=0, not ~"
msgstr "~ ~: el índice debe ser del tipo fixnum >=0, no ~"

#: sequence.d:650
msgid "~: ~ is not a sequence"
msgstr "~: ~ no es una secuencia"

#: sequence.d:753 sequence.d:986
msgid "~: bad length ~"
msgstr "~: longitud incorrecta ~"

#: sequence.d:854
msgid "~: size should be an integer >=0, not ~"
msgstr "~: el tamaño debe ser un entero >=0, no ~"

#: sequence.d:862
msgid "~: :update must not be specified without :initial-element"
msgstr "~: no debe especificarse :update sin :initial-element"

#: sequence.d:1824
msgid "~: Must not specify both arguments to :TEST and :TEST-NOT"
msgstr "~: Los argumentos :TEST y :TEST-NOT no deben tener valor simultáneamente"

#: sequence.d:1953
msgid "~: sequence ~ is too long"
msgstr "~: la secuencia ~ es demasiado larga"

#: sequence.d:2415
msgid "too long sequence ~"
msgstr "secuencia demasiado larga ~"

#: charstrg.d:697 charstrg.d:776 charstrg.d:806 charstrg.d:850
msgid "This is not a string: ~"
msgstr "Esto no es una cadena: ~"

#: charstrg.d:1141
msgid "~: the radix must be an integer between 2 and 36, not ~"
msgstr "~: la base debe ser un entero entre 2 y 36, no ~"

#: charstrg.d:1474
msgid "~: the code argument should be an integer, not ~"
msgstr "~: el argumento del código debe ser un entero y no ~"

# "~: no se puede convertir ~ al tipo character"
#
# No sé si traducir la palabra character, puesto que es una palabra
# clave en Lisp. - lsg
#
# Yo ya había traducido este mensaje como:
#
# "~: ~ no puede convertirse a un carácter"
#
# Pero el tuyo me gusta mucho más, salvo que `character', puesto que es
# un término definido en el estándar Common Lisp, debe ir en mayúsculas
# - cll
#
#: charstrg.d:1494
msgid "~: cannot coerce ~ to a character"
msgstr "~: no se puede convertir ~ al tipo CHARACTER"

#: charstrg.d:1530
msgid "~: the weight argument should be an integer, not ~"
msgstr "~: el argumento de ponderación debe ser un entero, y no ~"

#: charstrg.d:1568
msgid "~: argument should be an integer, not ~"
msgstr "~: el argumento debe ser un entero, no ~"

#: charstrg.d:1592
msgid "~: index should be an integer, not ~"
msgstr "~: el índice debe ser un entero, no ~"

#: charstrg.d:1598
msgid "~: ~-index should be an integer, not ~"
msgstr "~: el índice ~ debe ser un entero, no ~"

#: charstrg.d:1613
msgid "~: index should be NIL or an integer, not ~"
msgstr "~: el índice debe ser NIL o un entero, no ~"

#: charstrg.d:1619
msgid "~: ~-index should be NIL or an integer, not ~"
msgstr "~: el índice ~ debe ser NIL o un entero, no ~"

#: charstrg.d:1634
msgid "~: index should not be negative: ~"
msgstr "~: el índice no debe ser negativo: ~"

#: charstrg.d:1640
msgid "~: ~-index should not be negative: ~"
msgstr "~: el índice ~ no debe ser negativo: ~"

#: charstrg.d:1661
msgid "~: index ~ should not be greater than the length of the string"
msgstr "~: el índice ~ no debe ser mayor que la longitud de la cadena"

#: charstrg.d:1667
msgid "~: ~-index ~ should not be greater than the length of the string"
msgstr "~: el índice ~ = ~ no debe ser mayor que la longitud de la cadena"

#: charstrg.d:1688
msgid "~: index ~ should be less than the length of the string"
msgstr "~: el índice ~ debe ser menor que la longitud de la cadena"

#: charstrg.d:1694
msgid "~: ~-index ~ should be less than the length of the string"
msgstr "~: el índice ~ = ~ debe ser menor que la longitud de la cadena"

#: charstrg.d:1792
#, fuzzy
msgid "~: argument should be a character, not ~"
msgstr "~: el argumento debe ser un entero, no ~"

#: charstrg.d:1857 charstrg.d:1949 charstrg.d:2850
msgid "~: :start-index ~ must not be greater than :end-index ~"
msgstr "~: El índice :start ~ no debe ser mayor que el índice :end ~"

#: charstrg.d:1908
#, fuzzy
msgid "~: argument ~ should be a string, a symbol or a character"
msgstr "~: el argumento ~ debe ser del tipo string o string-char, o un símbolo"

#: charstrg.d:2004
msgid "~: :start1-index ~ must not be greater than :end1-index ~"
msgstr "~: El índice start1 ~ no debe ser mayor que el índice :end1 ~"

#: charstrg.d:2027
msgid "~: :start2-index ~ must not be greater than :end2-index ~"
msgstr "~: El índice :start2 ~ no debe ser mayor que el índice :end2 ~"

#: charstrg.d:2559
msgid "~: the string length ~ should be nonnegative fixnum"
msgstr ""
"~: la longitud de la cadena de caracteres ~ debe ser un número no negativo\n"
"del tipo FIXNUM"

#: charstrg.d:2589
#, fuzzy
msgid "~: :initial-element ~ should be of type character"
msgstr "~: El :INITIAL-ELEMENT ~ debe ser del tipo STRING-CHAR"

#
# Duda: esta traducción ha sido muy difícil, y está basada en la
# traducción francesa que dice: "~: Mauvais mode de saut d'environnement
# ~."
#
#: debug.d:664
msgid "~: bad frame climbing mode ~"
msgstr "~: modo de salto de marco incorrecto"

#: debug.d:683
msgid "~: ~ is not a stack pointer"
msgstr "~: ~ no es un puntero de pila"

#: debug.d:861
msgid "~: ~ is not a pointer to an EVAL/APPLY frame"
msgstr "~: ~ no es un puntero a un marco de tipo EVAL/APPLY"

#: debug.d:1112
msgid "~: environment is not an alist"
msgstr "~: el entorno no es una a-lista"

#: debug.d:1205
msgid "~: unknown frame type"
msgstr "~: tipo de marco desconocido"

#: error.d:48 reploop.lsp:291
msgid "Unprintable error message"
msgstr "Mensaje de error no imprimible"

#: error.d:629
msgid "~: User break"
msgstr "~: Interrupción del usuario"

#: error.d:677
msgid "~: ~ is not a list"
msgstr "~: ~ no es una lista"

#: error.d:692
msgid "~: A true list must not end with ~"
msgstr "~: Una auténtica lista no debe finalizar con ~"

#: error.d:709
msgid "~: ~ is not a symbol"
msgstr "~: ~ no es un símbolo"

#: error.d:738
msgid "~: ~ is not a simple-vector"
msgstr "~: ~ no es un SIMPLE-VECTOR"

#: error.d:753
msgid "~: ~ is not a vector"
msgstr "~: ~ no es un vector"

#: error.d:768
msgid "~: argument ~ should be a nonnegative fixnum"
msgstr "~: el argumento ~ debe ser un número no negativo del tipo fixnum"

#: error.d:783
msgid "~: argument ~ is not a character"
msgstr "~: el argumento ~ no es un carácter"

#: error.d:797
msgid "~: argument ~ is not a string"
msgstr "~: el argumento ~ no es un string"

#: error.d:811
msgid "~: argument ~ is not a simple string"
msgstr "~: el argumento ~ no es una cadena simple"

#: error.d:824
msgid "Attempt to modify a read-only string: ~"
msgstr ""

#: error.d:839
#, fuzzy
msgid "~: argument ~ is neither a string nor an integer"
msgstr "~: el argumento ~ no es un string"

#: error.d:854
msgid "~: argument ~ should be a stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: error.d:871
msgid "~: argument ~ should be a stream of type ~"
msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#: error.d:886
msgid ""
"~: argument ~ is not a function.\n"
"To get a function in the current environment, write (FUNCTION ...).\n"
"To get a function in the global environment, write (COERCE '... 'FUNCTION)."
msgstr ""

#: error.d:903 error.d:918
msgid "~: ~ is not an 8-bit number"
msgstr "~: ~ no es un número de 8 bits"

#: error.d:933 error.d:948
msgid "~: ~ is not a 16-bit number"
msgstr "~: ~ no es un número de 16 bits"

#: error.d:963 error.d:978
msgid "~: ~ is not an 32-bit number"
msgstr "~: ~ no es un número de 32 bits"

#: error.d:993 error.d:1008
msgid "~: ~ is not an 64-bit number"
msgstr "~: ~ no es un número de 64 bits"

#: error.d:1027
msgid "~: ~ is not an `unsigned int' number"
msgstr "~: ~ no es un número del tipo `unsigned int'"

#: error.d:1046
msgid "~: ~ is not an `int' number"
msgstr "~: ~ no es un número del tipo `int'"

#: error.d:1065
msgid "~: ~ is not a `unsigned long' number"
msgstr "~: ~ no es un número del tipo `unsigned long'"

#: error.d:1084
msgid "~: ~ is not a `long' number"
msgstr "~: ~ no es un número del tipo `long'"

#: error.d:1099
msgid "~: ~ is not a single-float"
msgstr "~: ~ no es un SINGLE-FLOAT"

#: error.d:1114
msgid "~: ~ is not a double-float"
msgstr "~: ~ no es un DOUBLE-FLOAT"

# Sugerencia: "Error del Sistema Operativo Amiga " sv
#
# ¡Ajá! me parece muchísimo mejor que lo que había puesto, ...
#
#: erramiga.d:10
msgid "Amiga OS error "
msgstr "Error del Sistema Operativo Amiga "

#: erramiga.d:39
msgid "not enough memory available"
msgstr "no hay suficiente memoria disponible"

#: erramiga.d:42
msgid "process table full"
msgstr "tabla de procesos llena"

#: erramiga.d:52
msgid "bad template"
msgstr "plantilla incorrecta"

#: erramiga.d:54
msgid "bad number"
msgstr "número incorrecto"

#: erramiga.d:56
msgid "required argument missing"
msgstr "argumentos obligatorios ausentes"

#: erramiga.d:58
msgid "value after keyword missing"
msgstr "falta el valor después de la palabra clave"

#: erramiga.d:60
msgid "wrong number of arguments"
msgstr "~: número incorrecto de argumentos"

# Duda: Uuufff! Por favor, que alguien le eche un ojo a esto, ...
#
# Bueno, he encontrado un mensaje parecido a este en el glibc donde pone
# "desemparejados". Me suena bien. cll
#
#: erramiga.d:62
msgid "unmatched quotes"
msgstr "comillas desemparejadas"

#: erramiga.d:64
msgid "argument line invalid or too long"
msgstr "línea de argumentos inválida o demasiado larga"

#: erramiga.d:66
msgid "file is not executable"
msgstr "el fichero no es un ejecutable"

#: erramiga.d:68
msgid "invalid resident library"
msgstr "librería residente inválida"

#: erramiga.d:77
msgid "object is in use"
msgstr "el objeto está siendo usado"

#: erramiga.d:79
msgid "object already exists"
msgstr "el objeto ya existe"

#: erramiga.d:81
msgid "directory not found"
msgstr "directorio no encontrado"

#: erramiga.d:83
msgid "object not found"
msgstr "objeto no encontrado"

#: erramiga.d:85
msgid "invalid window description"
msgstr "descripción de ventana inválida"

#: erramiga.d:87
msgid "object too large"
msgstr "el objeto es demasiado grande"

#: erramiga.d:90
msgid "packet request type unknown"
msgstr "tipo de paquete de petición desconocido"

#: erramiga.d:92
msgid "object name invalid"
msgstr "nombre de objeto inválido"

#: erramiga.d:94
msgid "invalid object lock"
msgstr "bloqueo de objeto inválido"

#: erramiga.d:96
msgid "object is not of required type"
msgstr "el objeto no es del tipo requerido"

#: erramiga.d:98
msgid "disk not validated"
msgstr "disco no validado"

#: erramiga.d:100
msgid "disk is write-protected"
msgstr "el disco es de solo lectura"

#: erramiga.d:102
msgid "rename across devices attempted"
msgstr "se intentó un renombramiento entre unidades"

#: erramiga.d:104
msgid "directory not empty"
msgstr "directorio no vacío"

#: erramiga.d:106
msgid "too many levels"
msgstr "demasiados niveles"

#: erramiga.d:108
msgid "device (or volume) is not mounted"
msgstr "el dispositivo (o volumen) no está montado"

#: erramiga.d:110
msgid "seek failure"
msgstr "error durante un acceso directo (seek)"

#: erramiga.d:112
msgid "comment is too long"
msgstr "el comentario es demasiado largo"

#: erramiga.d:114
msgid "disk is full"
msgstr "el disco está lleno"

#: erramiga.d:116
msgid "object is protected from deletion"
msgstr "el objeto está protegido contra el borrado"

#: erramiga.d:118
msgid "file is write protected"
msgstr "el archivo está protegido contra escritura"

#: erramiga.d:120
msgid "file is read protected"
msgstr "el fichero está protegido contra escritura"

#: erramiga.d:122
msgid "not a valid DOS disk"
msgstr "no es un disquete DOS válido"

#: erramiga.d:124
msgid "no disk in drive"
msgstr "no hay ningún disquete en la unidad"

#: erramiga.d:131
msgid "no more entries in directory"
msgstr "no hay más entradas en el directorio"

#: erramiga.d:133
msgid "object is soft link"
msgstr "el objeto es un enlace blando"

#: erramiga.d:135
msgid "object is linked"
msgstr "el objeto está enlazado"

#: erramiga.d:137
msgid "bad loadfile hunk"
msgstr "trozo incorrecto del fichero de carga"

#: erramiga.d:139
msgid "function not implemented"
msgstr "función no implementada"

#: erramiga.d:144
msgid "record not locked"
msgstr "registro no bloqueado"

#: erramiga.d:146
msgid "record lock collision"
msgstr "colisión de bloqueo de registro"

#: erramiga.d:148
msgid "record lock timeout"
msgstr "tiempo de espera excedido del bloqueo del registro"

#: erramiga.d:150
msgid "record unlock error"
msgstr "error de desbloqueo de registro"

#: erramiga.d:157
msgid "buffer overflow"
msgstr "desbordamiento del buffer"

#: erramiga.d:159
msgid "break"
msgstr "interrupción"

#: erramiga.d:161
msgid "file not executable"
msgstr "fichero no ejecutable"

# Duda: ¿Ok por `vale'? Hmmm, no sé, no sé, ...
# Depende del caso, ¿qué te parece "correcto"? sv
#
# No, no me gusta demasiado, ..., me parece que es demasiado en plan
# "computadora". Prefiero "vale" antes que "correcto". cll
#
#: erramiga.d:169
msgid "Ok, No error"
msgstr "Vale, sin errores"

# Sugerencia: Error de DJDOS. sv
#: errdjgpp.d:10
msgid "DJDOS error "
msgstr "Error de DJDOS "

#: errdjgpp.d:39 errunix.d:610
msgid "Function not implemented"
msgstr "Función no implementada"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
# "No existe ese archivo o directorio" - lsg
#
# Pues si, me gusta más la traducción de Leo, que la de Enrique, salvo
# que, tal y como tu mismo apuntas, Leo, se debe decir "fichero" y no
# "archivo" - cll
#
#: errdjgpp.d:41 errunix.d:53
msgid "No such file or directory"
msgstr "No existe ese fichero o directorio"

#: errdjgpp.d:43 errunix.d:161
msgid "Not a directory"
msgstr "No es un directorio"

#: errdjgpp.d:45 errunix.d:185
msgid "Too many open files"
msgstr "Demasiados ficheros abiertos"

#: errdjgpp.d:47 errunix.d:119
msgid "Permission denied"
msgstr "Permiso denegado"

#: errdjgpp.d:49 errunix.d:95
msgid "Bad file number"
msgstr "Número de fichero incorrecto"

#: errdjgpp.d:51
msgid "Memory control blocks destroyed"
msgstr "Bloques de control de memoria destruídos"

#: errdjgpp.d:53 errunix.d:113
msgid "Not enough memory"
msgstr "No hay memoria suficiente"

#: errdjgpp.d:55
msgid "Invalid memory address"
msgstr "Dirección de memoria inválida"

#: errdjgpp.d:57
msgid "Invalid environment"
msgstr "Entorno inválido"

#: errdjgpp.d:60
msgid "Invalid access code"
msgstr "Código de acceso inválido"

#: errdjgpp.d:63 errunix.d:155
msgid "No such device"
msgstr "No existe tal dispositivo"

#: errdjgpp.d:65
msgid "Attempt to remove the current directory"
msgstr "Intento de borrar el directorio actual"

#: errdjgpp.d:67
msgid "Can't move to other than the same device"
msgstr "No se puede cambiar de dispositivo"

#: errdjgpp.d:69
msgid "No more files"
msgstr "No más ficheros"

# ¿Por qué no inválido? La palabra existe.
# Un día os tengo que enviar un trozo de "1984" de Orwell,
# que habla de "neolengua", el único idioma del mundo que tiene
# cada vez menos palabras, en vez de más... sv
#
# ¡¡¡Por supuestísimo!!! Tienes toda la razón del mundo. De hecho, si
# echas un ojo al resto de los mensajes verás que yo siempre he
# traducido "invalid" por "inválido" salvo en tres ocasiones: en dos
# preferí la expresión "no es correcto" y en la otra lo dejé como "no es
# válido" en vez de "no válido" que, además, suena horrible.
#
# A propósito del trozo de "1984", venga, ya estoy esperando :) - cll
#
#: errdjgpp.d:71 errunix.d:173
msgid "Invalid argument"
msgstr "Argumento inválido"

#: errdjgpp.d:73 errunix.d:83
msgid "Arg list too long"
msgstr "Lista de argumentos demasiado larga"

#: errdjgpp.d:75 errunix.d:89
msgid "Exec format error"
msgstr "Formato de programa no ejecutable"

#: errdjgpp.d:77 errunix.d:149
msgid "Cross-device link"
msgstr "Enlace cruzado entre dispositivos"

#: errdjgpp.d:81 errunix.d:243
msgid "Argument out of domain"
msgstr "Argumento fuera del dominio"

#
# "El resultado es demasiado grande" - lsg
#
# Si, ya he cambiado `largo' por `grande' en todos los mensajes. Un
# fallo realmente infantil :( - cll
#
#: errdjgpp.d:83 errunix.d:249
msgid "Result too large"
msgstr "El resultado es demasiado grande"

#: errdjgpp.d:85 errunix.d:143
msgid "File exists"
msgstr "El fichero ya existe"

#: errunix.d:47
msgid "Operation not permitted"
msgstr "Operación no permitida"

#: errunix.d:59
msgid "No such process"
msgstr "No existe tal proceso"

#: errunix.d:65
msgid "Interrupted system call"
msgstr "Llamada al sistema interrumpida"

# Sugerencia: E/S. sv
#
# Vaya, tu sugerencia es tan informática que me impresiona que se me
# haya escapado. cll
#
#: errunix.d:71
msgid "I/O error"
msgstr "Error de E/S"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:77
msgid "No such device or address"
msgstr "Dispositivo no configurado"

# Sugerencia: No hay ningún proceso hijo. sv
#
# Bueno, Enrique tradujo este mensaje como "Ningún proceso hijo" en libc
# asi que, si te parece bien, lo pondré como él puesto que lo suyo es
# una traducción ya aceptada y que además, resulta de mezclar lo que yo
# he puesto y de tu sugerencia. cll
#
#: errunix.d:101
msgid "No child processes"
msgstr "Ningún proceso hijo"

#: errunix.d:107
msgid "No more processes"
msgstr "No hay más procesos"

#: errunix.d:125
msgid "Bad address"
msgstr "Dirección incorrecta"

# Pongo esto un poco más en español.
# Antes decía "Dispositivo de bloque requerido".
# Por cierto, en otros sitios hemos puesto "dispositivo de bloques".
# ¿cómo es? sv
#: errunix.d:131
msgid "Block device required"
msgstr "Se requiere un dispositivo de bloque"

#: errunix.d:137
msgid "Device busy"
msgstr "Dispositivo ocupado"

#: errunix.d:167
msgid "Is a directory"
msgstr "Es un directorio"

#: errunix.d:179
msgid "File table overflow"
msgstr "Desbordamiento de la tabla de ficheros"

#: errunix.d:191
msgid "Inappropriate ioctl for device"
msgstr "El dispositivo no acepta la llamada `ioctl'"

#: errunix.d:197
msgid "Text file busy"
msgstr "Fichero de texto en uso"

#: errunix.d:203
msgid "File too large"
msgstr "Fichero demasiado grande"

#: errunix.d:209
msgid "No space left on device"
msgstr "No queda espacio en el dispositivo"

#: errunix.d:215
msgid "Illegal seek"
msgstr "Desplazamiento inválido"

#: errunix.d:221
msgid "Read-only file system"
msgstr "Sistema de ficheros de sólo lectura"

#: errunix.d:227
msgid "Too many links"
msgstr "Demasiados enlaces"

#: errunix.d:233
msgid "Broken pipe, child process terminated"
msgstr ""

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:256
msgid "Operation would block"
msgstr "La operación se bloquearía"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:262
msgid "Operation now in progress"
msgstr "Operación en curso"

# Already sería "ya". aún sería still.
# Sugerencia: La operación ya se está realizando. sv
#
# Más aún, echando un ojo a la traducción de Enrique Melero en el glibc,
# me he encontrado con el mismo mensaje y el dice: "La operación ya se
# está llevando a cabo". Me gusta bastante. cll
#
#: errunix.d:268
msgid "Operation already in progress"
msgstr "La operación ya se está llevando a cabo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:275
msgid "Too many levels of symbolic links"
msgstr "Demasiados niveles de enlaces simbólicos"

#: errunix.d:281
msgid "File name too long"
msgstr "Nombre de fichero demasiado largo"

#: errunix.d:287
msgid "Directory not empty"
msgstr "El directorio no está vacío"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:294
msgid "Stale NFS file handle"
msgstr "Fichero NFS bloqueado"

# Duda: Aquí he seguido el consejo de Enrique Melero.
#
# En la versión 1.5 he decidido cambiar el término `camino' por
# `trayectoria', tal y como recomiendan los traductores del libro Lisp,
# (3ra edición) de Winston y Horn en el "Vocabulario bilingüe de
# términos técnicos", en la página 650.
#
#: errunix.d:300
msgid "Too many levels of remote in path"
msgstr "Demasiados niveles de profundidad en la trayectoria"

#: errunix.d:307
msgid "Socket operation on non-socket"
msgstr "Operación de `sockets' sobre un \"no-socket\""

#: errunix.d:313
msgid "Destination address required"
msgstr "Se necesita la dirección del destino"

#: errunix.d:319
msgid "Message too long"
msgstr "Mensaje demasiado largo"

#: errunix.d:325
msgid "Protocol wrong type for socket"
msgstr "Tipo de protocolo incorrecto para el `socket'"

#: errunix.d:331
msgid "Option not supported by protocol"
msgstr "Opción no soportada por el protocolo"

#: errunix.d:337
msgid "Protocol not supported"
msgstr "Protocolo no soportado"

#: errunix.d:343
msgid "Socket type not supported"
msgstr "Tipo de `socket' no soportado"

# Pongo `socket' en vez de socket. sv
#: errunix.d:349
msgid "Operation not supported on socket"
msgstr "Acción no permitida en un `socket'"

#: errunix.d:355
msgid "Protocol family not supported"
msgstr "Familia de protocolos no soportada"

#: errunix.d:361
msgid "Address family not supported by protocol family"
msgstr "Familia de direcciones no soportada por el protocolo"

#: errunix.d:367
msgid "Address already in use"
msgstr "Dirección en uso"

# Sugerencia: No se puede asignar. sv
#
# ¡Vale!, "No puede asignarse ..." es demasiado, ..., ¿impersonal? cll
#: errunix.d:373
msgid "Can't assign requested address"
msgstr "No se puede asignar la dirección requerida"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#: errunix.d:379
msgid "Network is down"
msgstr "La red no está operativa"

#: errunix.d:385
msgid "Network is unreachable"
msgstr "No es posible conectarse con la red"

#: errunix.d:391
msgid "Network dropped connection on reset"
msgstr "Se ha perdido la conexión con la red debido a una reinicialización"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#: errunix.d:397
msgid "Software caused connection abort"
msgstr "El software ha provocado la interrupción de la conexión"

#: errunix.d:403
msgid "Connection reset by peer"
msgstr "Conexión reinicializada por el otro extremo"

#
# Duda: ¿Y buffer? ¿Como traduzco buffer?
#
# Yo he visto a menudo 'memoria tampón', que es el término usado por los
# franceses. - lsg
#
# Tienes toda la razón, ... Sin embargo, en este caso, la traducción
# francesa es:
#
# "Pas d'espace disponible pour un buffer"
#
# Además, como en spanglish.txt pone:
#
# "buffer - memoria intermedia, tampón, buffer"
#
# pues he utilizado `buffer' tal cual, ... - cll
#
#: errunix.d:409
msgid "No buffer space available"
msgstr "No queda espacio en el buffer"

# Lo de socket, si te parece. sv
#
# Te digo lo mismo que te dije antes. Cuando hay finalizado con la
# traducción me pondré a cambiar todas estas cosas con macros. cll
#
#: errunix.d:415
msgid "Socket is already connected"
msgstr "El `socket' ya está conectado"

#: errunix.d:421
msgid "Socket is not connected"
msgstr "El `socket' no está conectado"

# Añado comitas a `socket'. Es una especie de convenio que seguimos
# cuando no nos queda más remedio que poner la palabra inglesa.
# Así al menos reconocemos que es una palabra extraña. sv
#: errunix.d:427
msgid "Can't send after socket shutdown"
msgstr "No se puede enviar después de la ruptura del `socket'"

#: errunix.d:433
msgid "Too many references: can't splice"
msgstr ""

# Duda: ¿ Se excedió el tiempo para la conexión ?
#: errunix.d:439
msgid "Connection timed out"
msgstr "Se excedió el tiempo para la conexión"

#: errunix.d:445
msgid "Connection refused"
msgstr "Conexión rechazada"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#: errunix.d:450
#, fuzzy
msgid "Remote peer released connection"
msgstr "El software ha provocado la interrupción de la conexión"

# Estas dos darán que hablar, pero otro día las discutiremos... sv
#
# Al decir tú eso, he leído la traducción de este término en libc
# (traducido por Enrique Melero) y, madre mía, me he quedado
# "flipao". Aquello fue una discusión encarnizada, ...
#
# Para mas inri, yo no estoy de acuerdo con ninguno de los dos :) Verás,
# un host puede estar "caído" (que así es como se suele decir aunque es,
# evidentemente, incorrecto) y por ello no tiene por qué no estar
# operativo (en libc lo habeis traducido como "el `host' no está
# operativo"). De hecho, puede estar operando pero, por algún problema
# de la red o de tu propia transmisión, resultar inalcanzable, ... En
# fin, por este motivo prefiero "El `host' no está disponible"
#
# Por otra parte, no estoy muy de acuerdo con Enrique, ..., a mí lo de
# poner host no me gusta. Ciertamente, un `host' no tiene por qué ser un
# servidor, necesariamente, pero es el caso más común. En cualquier
# caso, todo el mundo comprende perfectamente que el `host' es un
# servidor. cll
#
#: errunix.d:455
msgid "Host is down"
msgstr "El servidor no está disponible"

# Aquí, pues idem de idem, ... :) cll
#
#: errunix.d:461
msgid "Host is unreachable"
msgstr "No se puede conectar con el servidor"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#: errunix.d:466
#, fuzzy
msgid "Networking error"
msgstr "La red no está operativa"

#: errunix.d:472
msgid "Too many processes"
msgstr "Demasiados procesos"

#: errunix.d:478
msgid "Too many users"
msgstr "Demasiados usuarios"

#: errunix.d:484
msgid "Disk quota exceeded"
msgstr "Cuota de disco excedida"

#: errunix.d:491
msgid "Not a stream device"
msgstr "No es un dispositivo de flujo"

#: errunix.d:497
msgid "Timer expired"
msgstr "El temporizador expiró"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:503
msgid "Out of stream resources"
msgstr "Alcanzado el límite de recursos de `streams'"

#: errunix.d:509
msgid "No message of desired type"
msgstr "No hay mensajes del tipo deseado"

#: errunix.d:515
msgid "Not a data message"
msgstr "No es un mensaje de datos"

#: errunix.d:522
msgid "Identifier removed"
msgstr "Identificador desechado"

# Duda: Eso del `inter-bloqueo' ¿estará bien?
#
#: errunix.d:529
msgid "Resource deadlock would occur"
msgstr "Podría ocurrir un interbloqueo entre recursos"

# Duda: Aunque Bruno Haible me ha asegurado que la etiqueta
# sys_errlist[ENOLCK] del glibc.po en español contiene la traduccion que
# yo debiera usar, me he decidido por las indicaciones de Santiago Vila
# en su respuesta a mi mail y he puesto, simplemente: "No quedan
# registros de bloqueo disponibles"
#
#: errunix.d:535
msgid "No record locks available"
msgstr "No quedan registros de bloqueo disponibles"

#: errunix.d:542
msgid "Machine is not on the network"
msgstr "La máquina no está en la red"

#: errunix.d:548 errunix.d:554
msgid "Object is remote"
msgstr "El objeto es remoto"

#: errunix.d:560
msgid "Link has been severed"
msgstr "El enlace ha sido destruído"

#: errunix.d:566
msgid "Advertise error"
msgstr "Error de anuncio"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:572
msgid "Srmount error"
msgstr "Error de `srmount'"

#: errunix.d:578
msgid "Communication error on send"
msgstr "Error de comunicaciones en el envío"

#: errunix.d:584
msgid "Protocol error"
msgstr "Error de protocolo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:590
msgid "Multihop attempted"
msgstr "Se ha intentado un multihop"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:603
msgid "Remote address changed"
msgstr "La dirección remota ha cambiado"

#: errunix.d:617
msgid "Not supported under MS-DOS"
msgstr "No soportado en MS-DOS"

#: errunix.d:636
msgid "UNIX error "
msgstr "Error de Unix "

# Cambio librería por el término oficial. sv
#
# Uuuffffff, ..., aquí sí que podríamos discutir hasta la muerte. Pero
# bueno, se queda como tú lo has puesto. cll
#
#: errunix.d:638
msgid "UNIX library error "
msgstr "Error de biblioteca Unix "

#: errwin32.d:3877
msgid "Win32 error "
msgstr "Error de Win32 "

#: errwin32.d:3923
msgid "Winsock error "
msgstr "Error de `winsock'"

#: misc.d:40
msgid "This file was produced by another lisp version, must be recompiled."
msgstr "Este fichero fue producido por otra versión de lisp. Debe recompilarse."

#: misc.d:235
msgid "~: type of attribute ~ is unsupported"
msgstr "~: el tipo de atributo ~ no está soportado"

#: predtype.d:1560 predtype.d:1731
msgid "~: unidentifiable type!!!"
msgstr "~: ¡¡¡tipo irreconocible!!!"

#: predtype.d:1738
msgid "~: type ~ does not correspond to a class"
msgstr "~: el tipo ~ no se corresponde con una clase"

#: predtype.d:1780
msgid "~: ~ does not name a class"
msgstr "~: ~ no es el nombre de una clase"

#: predtype.d:2078
msgid "~: bad type specification ~"
msgstr "~: especificación de tipo incorrecta ~"

#: predtype.d:2086
msgid "~: ~ cannot be coerced to type ~"
msgstr "~: ~ no puede convertirse al tipo ~"

#: symbol.d:46
msgid "~: the property list of ~ has an odd length"
msgstr "~: la lista de propiedades de ~ tiene longitud impar"

#: symbol.d:96
msgid "SETF SYMBOL-FUNCTION: ~ is not a function"
msgstr "SETF SYMBOL-FUNCTION: ~ no es una función"

#: symbol.d:118
msgid "~: ~ is not a system function"
msgstr "~: ~ no es una función del sistema"

#: symbol.d:168 symbol.d:205
msgid "~: the property list ~ has an odd length"
msgstr "~: la lista de propiedades ~ tiene longitud impar"

#: intlog.d:567 symbol.d:370
msgid "~: index ~ is negative"
msgstr "~: el índice ~ es negativo"

#: symbol.d:382
msgid "~: invalid argument ~"
msgstr "~: el argumento ~ es inválido"

#: symbol.d:395
msgid "The value of *GENSYM-COUNTER* was not a nonnegative integer. Old value ~. New value ~."
msgstr "El valor de *GENSYM-COUNTER* no era un entero no negativo. Valor anterior ~. Nuevo valor ~."

#: lisparit.d:335
msgid "argument to ~ should be a number: ~"
msgstr "el argumento de ~ debe ser un número: ~"

#: lisparit.d:350
msgid "argument to ~ should be a real number: ~"
msgstr "el argumento de ~ debe ser un número real: ~"

#: lisparit.d:365
msgid "argument to ~ should be a floating point number: ~"
msgstr "el argumento de ~ debe ser un número en coma flotante: ~"

#: lisparit.d:380
msgid "argument to ~ should be a rational number: ~"
msgstr "el argumento de ~ debe ser un número racional: ~"

#: lisparit.d:395
msgid "argument to ~ should be an integer: ~"
msgstr "el argumento de ~ debe ser un entero: ~"

#: lisparit.d:410
msgid "~: argument should be a positive fixnum, not ~"
msgstr "~: el argumento debe ser un número positivo del tipo FIXNUM, no ~"

#: lisparit.d:1673
msgid "~: argument should be a random-state, not ~"
msgstr "~: el argumento debe ser un estado aleatorio, no ~"

#: lisparit.d:1688
msgid "~: the value of ~ should be a random-state, not ~"
msgstr "~: el valor de ~ debe ser un RANDOM-STATE, no ~"

#: lisparit.d:1707
msgid "~: argument should be positive and an integer or float, not ~"
msgstr "~: el argumento debe ser un número positivo del tipo INTEGER o FLOAT, no ~"

#: lisparit.d:1789
msgid "~ : argument should be a fixnum >=0, not ~"
msgstr "~ : El argumento debe ser del tipo FIXNUM >=0 y no ~"

#: aridecl.d:330
msgid "division by zero"
msgstr "división entre cero"

#: aridecl.d:339
msgid "floating point overflow"
msgstr "desbordamiento de coma flotante"

# Duda: Lo del desbordamiento inferior de coma flotante ha sido
# traducción super libre mía ;) Este mensaje ocurre cuando el resultado
# (expresado en coma flotante) ocurre mucho más cerca del cero de lo que
# permite la representación de números en coma flotante. Por ejemplo:
# 2.3e-30 * 2.3e-30 sería 5.29e-60 que excedió el límite inferior.
#
#: aridecl.d:348
msgid "floating point underflow"
msgstr "desbordamiento inferior de coma flotante"

#: intelem.d:205 intelem.d:290
msgid "not a 32-bit integer: ~"
msgstr "no es un entero de 32 bits: ~"

#: intelem.d:374 intelem.d:509
msgid "not a 64-bit integer: ~"
msgstr "no es un entero de 64 bits: ~"

#: intelem.d:1408
msgid "bignum overflow"
msgstr "desbordamiento de números grandes"

#: intlog.d:450
msgid "~: ~ is not a valid boolean operation"
msgstr "~: ~ no es una operación lógica válida"

#: intlog.d:690
msgid "~: too large shift amount ~"
msgstr "~: el tamaño del desplazamiento es muy grande ~"

# Duda: En Lisp existe un tipo predeterminado: `fixnum'. Por ese motivo,
# dejo sin traducir este término.
#
#: intbyte.d:15
msgid "The arguments to BYTE must be fixnums >=0: ~, ~"
msgstr "Los argumentos de BYTE deben ser números enteros del tipo FIXNUM >=0: ~, ~"

#: intbyte.d:39
msgid "~ is not a BYTE specifier"
msgstr "~ no es un especificador de BYTE"

#: intmal.d:7
msgid "overflow during multiplication of large numbers"
msgstr "desbordamiento durante la multiplicación de números grandes"

#: intdiv.d:347
msgid "quotient ~ / ~ is not an integer"
msgstr "el cociente ~ / ~ no es un entero"

#: intsqrt.d:388
msgid "~ applied to negative number ~"
msgstr "~ aplicado al número negativo ~"

# Duda: long-float es un tipo, así que lo dejo como `LONG-FLOAT'. Aunque
# Bruno Haible y Marcus Daniels lo han puesto como `long float' se
# refieren al tipo `long-float'
# Sugerencia: `long float'. sv
#
# No estoy de acuerdo con la sugerencia. No se trata de que `long' sea
# un adjetivo de `float', sino que en CLisp existe el tipo "long-float"
# (Common Lisp The Language, 2nd edition, Guy L. Steele, pag. 39). De
# hecho, en muchos otros sitios de CLisp se pone "long-float". Más aún,
# la traducción francesa de este mensaje es: "LONG-FLOAT trop long".
#
# De hecho, en mi opinion, Bruno Haible y Marcus Daniels se equivocaron
# aquí y debían haber puesto el guión. cll
#
#: lfloat.d:7
msgid "long float too long"
msgstr "LONG-FLOAT demasiado largo"

#: flo_konv.d:448
msgid "floating point NaN occurred"
msgstr "aparición de NaN en coma flotante"

# Duda: ¿alguien sabe qué es eso de ARexx?
#
#: rexx.d:33
msgid "Communication with ARexx isn't possible."
msgstr "La comunicación con ARexx no es posible."

#
# Siguiendo con las recomendaciones de Santiago y de "spanglish",
# `command' será `orden' - cll
#
#: rexx.d:111
msgid "~ must be a string for commands or a vector of strings for a function"
msgstr "~ debe ser una cadena para órdenes o un vector de cadenas para una función"

#: rexx.d:120
msgid "~: an ARexx function must have 0 to ~ arguments: ~"
msgstr "~: Una función ARexx debe tener entre 0 y ~ argumentos: ~"

#: rexx.d:134
msgid "~: must be a string for ARexx: ~"
msgstr "~: debe ser una cadena para ARexx: ~"

#: rexx.d:155
msgid "Only NIL, T and strings are accepted for ~ : ~"
msgstr "~ sólo acepta NIL, T o cadenas de caracteres: ~"

#: rexx.d:454
msgid "~: Not a Fixnum: ~"
msgstr "~: No es del tipo Fixnum: ~"

#: rexx.d:464
msgid "~: Not an incoming Rexx message: ~"
msgstr "~: No es un nuevo mensaje Rexx: ~"

#: affi.d:82
msgid "~: Unsupported call mechanism: ~"
msgstr "~: mecanismo de llamado no soportado: ~"

#: affi.d:92
msgid "~: Bad function prototype: ~"
msgstr "~: Prototipo de función incorrecto: ~"

#: affi.d:102
msgid "~: Wrong number of arguments for prototype ~"
msgstr "~: número incorrecto de argumentos para el prototipo ~"

#: affi.d:115
msgid "~: Bad argument for prototype ~: ~"
msgstr "~: Argumento incorrecto para el prototipo ~: ~"

#: affi.d:125
msgid "~: Bad argument: ~"
msgstr "~: El argumento ~ es inválido"

#: affi.d:144
msgid "~: ~ is not a valid address"
msgstr "~: ~ no es una dirección válida"

#: foreign.d:26
msgid "~ comes from a previous Lisp session and is invalid"
msgstr "~ proviene de una sesion anterior de Lisp y es inválido"

#: foreign.d:95
msgid "A foreign variable ~ already exists"
msgstr "La variable extranjera ~ ya existe"

# Duda: he traducido `foreign' por `ajeno/a'.
#
# Lo he pensado mejor y `extranjera' me gusta mucho más, ..., ¿qué os
# parece? cll
#
#: foreign.d:134
msgid "A foreign function ~ already exists"
msgstr "La función extranjera ~ ya existe"

#: foreign.d:175
msgid "illegal foreign data type ~"
msgstr "el tipo de datos extranjero ~ es inválido"

#: foreign.d:188
msgid "~ cannot be converted to the foreign type ~"
msgstr "~ no puede ser compartido al tipo extranjero ~"

#: foreign.d:200
msgid "64 bit integers are not supported on this platform and with this C compiler: ~"
msgstr "los enteros de 64 bits no están soportados en esta arquitectura, para este compilador de C:"

#: foreign.d:339 foreign.d:488
msgid "~ cannot be converted to a foreign function with another calling convention."
msgstr "~ no puede ser convertido a una función extranjera con otra convención de llamada."

#: foreign.d:532
msgid "No more room for foreign language interface"
msgstr "No queda espacio para el interfaz con otros lenguajes"

#: foreign.d:540
msgid ":MALLOC-FREE is not available under AMIGAOS."
msgstr ":MALLOC-FREE no está disponible en AMIGAOS."

#: foreign.d:1084 foreign.d:1143 foreign.d:1286 foreign.d:1322
msgid "element type has size 0: ~"
msgstr "el tipo del elemento tiene tamaño 0: ~"

#: foreign.d:2062
msgid "~: argument is not a foreign variable: ~"
msgstr "~: el argumento no es una variable extranjera: ~"

#: foreign.d:2071
msgid "~: foreign variable with unknown type, missing DEF-C-VAR: ~"
msgstr "~: variable externa de tipo desconocido, se ha omitido DEF-C-VAR: ~"

#: foreign.d:2084
msgid "A foreign variable ~ does not exist"
msgstr "La variable extranjera ~ no existe"

#: foreign.d:2096
msgid "~: foreign variable ~ does not have the required size or alignment"
msgstr "~: la variable externa ~ no tiene el tamaño o alineamiento requerido"

#: foreign.d:2110
msgid "~: type specifications for foreign variable ~ conflict: ~ and ~"
msgstr "~: conflicto de especificación de tipo de la variable extranjera ~: ~ y ~"

#: foreign.d:2153
msgid "~: foreign variable ~ may not be modified"
msgstr "~: no se puede modificar la variable externa ~"

#: foreign.d:2206
msgid "~: foreign variable ~ of type ~ is not an array"
msgstr "~: la variable externa ~ del tipo ~ no es una matriz"

#: foreign.d:2290
msgid "~: foreign variable ~ of type ~ is not a pointer"
msgstr "~: la variable externa ~ del tipo ~ no es un puntero"

#: foreign.d:2390
msgid "~: foreign variable ~ of type ~ is not a struct or union"
msgstr "~: la variable externa ~ del tipo ~ no es, ni una estructura, ni una unión"

#: foreign.d:2399
msgid "~: foreign variable ~ of type ~ has no component with name ~"
msgstr "~: la variable externa ~ del tipo ~ no tiene ningún componente con el nombre ~"

#: foreign.d:2461 foreign.d:3511
msgid "~: foreign variable ~ does not have the required alignment"
msgstr "~: la variable externa ~ no tiene el alineamiento requerido"

#: foreign.d:2476
msgid "~: argument is not a foreign function: ~"
msgstr "~: el argumento no es una función extranjera: ~"

#: foreign.d:2486
msgid "~: foreign function with unknown calling convention, missing DEF-CALL-OUT: ~"
msgstr "~: función externa con convención de llamada desconocida, se ha omitido DEF-CALL-OUT: ~"

#: foreign.d:2503 foreign.d:3534
msgid "~: illegal foreign function type ~"
msgstr "~: tipo de función externa inválido ~"

#: foreign.d:2511
msgid "~: A foreign function ~ does not exist"
msgstr "~: La función extranjera ~ no existe"

#: foreign.d:2518
msgid "~: calling conventions for foreign function ~ conflict"
msgstr "~: conflicto en la convención de llamada de la función externa ~"

#: foreign.d:2788
msgid "~: Too few arguments (~ instead of at least ~) to ~"
msgstr "~: Muy pocos argumentos (~ en vez de, al menos, ~) para ~"

#: foreign.d:2799
msgid "~: :OUT argument is not a pointer: ~"
msgstr "~: el argumento :OUT no es un puntero: ~"

#: foreign.d:2842
msgid "~: Too many arguments (~ instead of ~) to ~"
msgstr "~: Demasiados argumentos (~ en vez de ~) para ~"

#: foreign.d:3401
msgid "~: Cannot open library ~"
msgstr "~: No se puede abrir la biblioteca ~"

#: foreign.d:3487
msgid "~: ~ is not a library"
msgstr "~: ~ no es una biblioteca"

#: amigaaux.d:186
msgid "This version of CLISP runs only in low address memory.\n"
msgstr ""

#: init.lsp:347
msgid "~S is a special form and may not be redefined."
msgstr "~S es una forma especial y por ello, no puede ser redefinida"

#: clos.lsp:205 init.lsp:353
msgid "The old definition will be lost"
msgstr "Se perderá la definición anterior."

#: init.lsp:354
msgid "Redefining the COMMON LISP ~A ~S"
msgstr "La ~A de COMMON LISP ~S será redefinida"

# Junto las ¡! sv
# Sugerencia "¡Se estaba trazando!" (es como más "en español") sv
#
# Sí, tu sugerencia me gusta. Como se nota que tienes experiencia, ...,
# ¿eh? cll
#
#: init.lsp:371
msgid "DEFUN/DEFMACRO: redefining ~S; it was traced!"
msgstr "DEFUN/DEFMACRO: redefiniendo ~S; ¡se estaba rastreando!"

#: init.lsp:391
msgid "~S is impossible in compiled code"
msgstr "~S es imposible en código compilado"

#: init.lsp:478
msgid "~S is an invalid function environment"
msgstr "~S es un entorno de función inválido"

#: init.lsp:525
msgid "~S is an invalid variable environment"
msgstr "~S es un entorno de variable inválido"

#: init.lsp:590
msgid "~S: ~S is illegal since ~S is a local macro"
msgstr "~S: ~S es inválido, puesto que ~S es una macro local"

#: init.lsp:594
msgid "~S: invalid function environment ~S"
msgstr "~S: ~S es un entorno de función inválido"

#: init.lsp:600
msgid "~S: ~S is invalid since ~S is not a symbol"
msgstr "~S: ~S es incorrecto, puesto que ~S no es un símbolo"

#: init.lsp:774
msgid "code after MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de MACROLET contiene una lista punteada que termina con ~S"

#: init.lsp:790
msgid "illegal syntax in MACROLET: ~S"
msgstr "sintaxis inválida en MACROLET: ~S"

#: init.lsp:799
msgid "code after SYMBOL-MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de SYMBOL-MACROLET contiene una lista punteada que termina con ~S"

#: compiler.lsp:7116 init.lsp:808
msgid "~S: symbol ~S must not be declared SPECIAL and a macro at the same time"
msgstr "~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo"

#: compiler.lsp:7111 init.lsp:823
#, fuzzy
msgid "~S: symbol ~S is declared special and must not be declared a macro"
msgstr "~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo"

#: init.lsp:830
msgid "illegal syntax in SYMBOL-MACROLET: ~S"
msgstr "sintaxis inválida en SYMBOL-MACROLET: ~S"

#: init.lsp:868
msgid "bad function environment occurred in ~S: ~S"
msgstr "se encontró un entorno de función incorrecto en ~S: ~S"

#: init.lsp:877
msgid "~S: invalid form ~S"
msgstr "~S: forma inválida ~S"

#: init.lsp:888
msgid "code contains a dotted list, ending with ~S"
msgstr "el código contiene una lista punteada que termina con ~S"

#: init.lsp:931
msgid "~S: ~S should be a lambda expression"
msgstr "~S: ~S debe ser una expresión lambda"

#: init.lsp:972
msgid "lambda list must not end with the atom ~S"
msgstr "la lista lambda no debe terminar con el átomo ~S"

#: init.lsp:1004 init.lsp:1021
msgid "~S: variable list ends with the atom ~S"
msgstr "~S: la lista de variables termina con el átomo ~S"

#: init.lsp:1134
msgid "FLET/LABELS: code contains a dotted list, ending with ~S"
msgstr "FLET/LABELS: el código contiene una lista punteada que termina con ~S"

#: init.lsp:1143
msgid "illegal syntax in FLET/LABELS: ~S"
msgstr "sintaxis inválida en FLET/LABELS: ~S"

#: init.lsp:1278
msgid "Loading file "
msgstr "Cargando el fichero \""

#: init.lsp:1280
msgid " ..."
msgstr " ..."

#: init.lsp:1306
msgid "Loading of file "
msgstr "La carga del fichero "

# Nota: `is finished' debería traducirse por `está finalizado' o `está
#       finalizada'. Sin embargo, esta parte se compondrá con otras
#       donde la traducción `ha finalizado' sigue siendo igualmente válida y,
#       además, nos evitamos la utilización de una forma eminentemente
#       masculina o fememina.
#
#: init.lsp:1308
msgid " is finished."
msgstr " ha finalizado."

#: init.lsp:1315
msgid "A file with name ~A does not exist"
msgstr "No existe ningún fichero con el nombre ~A"

#: init.lsp:1329
msgid "~S: missing function name and/or parameter list"
msgstr "~S: no se ha indicado el nombre de la función y/o la lista de parámetros"

#: init.lsp:1337
msgid "~S: ~S is not a symbol."
msgstr "~S: ~S no es un símbolo."

#: init.lsp:1342
msgid "~S: special form ~S cannot be redefined."
msgstr "~S: la forma especial ~S no puede ser redefinida."

#: init.lsp:1387 macros1.lsp:148
msgid "exit clause in ~S must be a list"
msgstr "la cláusula exit en ~S debe ser una lista"

#: init.lsp:1538
msgid "~S: cannot define a function from that: ~S"
msgstr "~: no es posible definir una función a partir de ~S"

#: clos.lsp:2947 clos.lsp:3004 init.lsp:1543
msgid "~S: the name of a function must be a symbol, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

#: init.lsp:1548
msgid "~S: function ~S is missing a lambda list"
msgstr "~S: la función ~S debe tener una lista lambda"

#: conditio.lsp:1457 init.lsp:1778 reploop.lsp:308
msgid "If you continue (by typing 'continue'): "
msgstr "Si continúa (tecleando `continue'): "

# Duda: Aquí, igual que en el caso de la traducción francesa, he
# preferido preservar el término `backquote' y ---porque así se ha
# decidido en Spanish GNU Translation Team---, el término está con
# comillas simples.
#
# He tomado esta decisión porque el `backquote' (que es la tilde
# invertida `) es un término muy familiar para todos los programadores
# de Lisp que, con toda seguridad, conocerán.
#
#: backquot.lsp:39
msgid "~S: comma is illegal outside of backquote"
msgstr "~S: la coma es inválida fuera del `backquote'"

#: backquot.lsp:44
msgid "~S: more commas out than backquotes in, is illegal"
msgstr "~S: no se pueden emplear más comas fuera que apóstrofes invertidos dentro"

#: backquot.lsp:205
msgid "The syntax ,@form is valid only in lists"
msgstr "La sintaxis ,@forma es válida únicamente en las listas"

#: backquot.lsp:210
msgid "The syntax ,.form is valid only in lists"
msgstr "La sintaxis ,.forma es válida únicamente en las listas"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# A partir de la versión 1997-05-03, este mensaje ha cambiado y se
# refiere a elementos que serán ignorados. Como no puede anticiparse
# cual será el género del objeto que se ignora, he preferido poner lo de
# os/as. ¿Qué os parece?
#
#: defmacro.lsp:44
msgid "Both will be ignored."
msgstr "Ambos/as serán ignorados/as."

#: defmacro.lsp:45
msgid "Invalid keyword-value-pair: ~S ~S"
msgstr "Par argumento clave y valor inválido: ~S ~S"

#: defmacro.lsp:54
msgid "The macro ~S may not be called with ~S arguments"
msgstr "La macro ~S no puede ser invocada con ~S argumentos"

#: defmacro.lsp:125 defmacro.lsp:150 defmacro.lsp:295
msgid "The rest of the lambda list will be ignored."
msgstr "El resto de la lista lambda será ignorado."

#: defmacro.lsp:126
msgid "The lambda list of macro ~S contains a dot after &AUX."
msgstr "La lista lambda de la macro ~S contiene un punto después de &AUX"

#: defmacro.lsp:132
msgid "in macro ~S: ~S may not be used as &AUX variable."
msgstr "en la macro ~S: ~S no debe usarse como una variable &AUX."

#: defmacro.lsp:151
msgid "The lambda list of macro ~S contains a dot after &KEY."
msgstr "La lista lambda de la macro ~S contiene un punto después de &KEY"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
#: defmacro.lsp:160 defmacro.lsp:178 defmacro.lsp:374 defmacro.lsp:390 defmacro.lsp:395
msgid "It will be ignored."
msgstr "Será ignorado."

#: defmacro.lsp:161
msgid "The lambda list of macro ~S contains a badly placed ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S mal situado."

#: defmacro.lsp:179
msgid "The lambda list of macro ~S contains the invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene el elemento inválido ~S"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# No tengo ni idea de qué significa ese "0*"
#: defmacro.lsp:209
msgid "~0*It will be ignored."
msgstr "Será ignorado."

#: defmacro.lsp:210
msgid "The lambda list of macro ~S contains an invalid keyword specification ~S"
msgstr "La lista lambda de la macro ~S contiene una especificación de argumento clave inválida: ~S"

#: defmacro.lsp:281
msgid "The lambda list of macro ~S is missing a variable after &REST/&BODY."
msgstr "La lista lambda de la macro ~S necesita una variable después de &REST/&BODY."

#: defmacro.lsp:286
msgid "The lambda list of macro ~S contains an illegal variable after &REST/&BODY: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable inválida después de &REST/&BODY: ~S"

#: defmacro.lsp:296
msgid "The lambda list of macro ~S contains a misplaced dot."
msgstr "La lista lambda de la macro ~S contiene un punto mal situado."

# Ojo. sv
#
# :) Vale :) cll
#
#: defmacro.lsp:301
msgid "They will be ignored."
msgstr "Serán ignorados."

#: defmacro.lsp:302
msgid "The lambda list of macro ~S contains superfluous elements: ~S"
msgstr "La lista lambda de la macro ~S contiene elementos innecesarios: ~S"

#: defmacro.lsp:355
msgid "The lambda list of macro ~S contains an illegal &REST variable: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable &REST inválida: ~S"

#: defmacro.lsp:369
msgid "The lambda list of macro ~S contains an invalid &WHOLE: ~S"
msgstr "La lista lambda de la macro ~S contiene un &WHOLE inválido: ~S"

#: defmacro.lsp:375
msgid "The lambda list of macro ~S contains a superfluous ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S innecesario."

#: defmacro.lsp:391
msgid "The lambda list of macro ~S contains ~S before &KEY."
msgstr "La lista lambda de la macro ~S contiene ~S antes de &KEY."

#: defmacro.lsp:396
msgid "The lambda list of macro ~S contains ~S which is illegal here."
msgstr "La lista lambda de la macro ~S contiene ~S, lo cual es incorrecto aquí."

#: defmacro.lsp:415
msgid "The lambda list of macro ~S contains an invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene un elemento inválido: ~S"

#: defmacro.lsp:429
msgid "The lambda list of macro ~S contains an invalid supplied-variable ~S"
msgstr "La lista lambda de la macro ~S contiene una \"variable-proporcionada\" inválida ~S"

#: defmacro.lsp:491
msgid "In the lambda list of macro ~S, &ENVIRONMENT must be followed by a non-NIL symbol: ~S"
msgstr "En la lista lambda de la macro ~S, &ENVIRONMENT debe estar seguido de un símbolo no nulo: ~S"

#: defmacro.lsp:513
msgid "Cannot define a macro from that: ~S"
msgstr "No se puede definir una macro a partir de: ~S"

#: defmacro.lsp:518
msgid "The name of a macro must be a symbol, not ~S"
msgstr "El nombre de una macro debe ser un símbolo, no ~S"

#: defmacro.lsp:523
msgid "Macro ~S is missing a lambda list."
msgstr "La macro ~S necesita una lista lambda."

#: macros1.lsp:11 macros1.lsp:34
msgid "~S: non-symbol ~S can't be a variable"
msgstr "~S: sólo los símbolos pueden ser variables, y no ~S"

#: macros1.lsp:16 macros1.lsp:39
msgid "~S: the constant ~S must not be redefined to be a variable"
msgstr "~S: la constante ~S no debe redefinirse como una variable"

#: macros1.lsp:53
msgid "~S: non-symbol ~S can't be a defined constant"
msgstr "~S: ~S no es un símbolo, y por lo tanto no puede definirse como una constante"

#: macros1.lsp:86
msgid "~S redefines the constant ~S. Its old value was ~S."
msgstr "~S redefine la constante ~S. Su valor anterior era ~S."

#: macros1.lsp:153
msgid "Invalid syntax in ~S form: ~S."
msgstr "Sintaxis inválida en la forma ~S: ~S."

#: macros1.lsp:269 places.lsp:697
msgid "~S called with an odd number of arguments: ~S"
msgstr "~S ha sido invocado con un número impar de argumentos: ~S"

#: macros1.lsp:321
msgid "~S: missing key list"
msgstr "~S: falta la lista de claves"

#: macros1.lsp:328
msgid "~S: the ~S clause must be the last one"
msgstr "~S: la clausula ~S debe ser la última"

#: macros1.lsp:381 macros1.lsp:454
msgid "Not a list of COND clauses: ~S"
msgstr "No es una lista de cláusulas COND: ~S"

#: macros1.lsp:386 macros1.lsp:459
msgid "The atom ~S must not be used as a COND clause."
msgstr "El átomo ~S no debe usarse como una cláusula COND."

#: macros1.lsp:422
msgid "COND code contains a dotted list, ending with ~S"
msgstr "El código de COND contiene una lista punteada que termina con ~S"

#: compiler.lsp:7167 macros1.lsp:428
msgid "COND clause without test: ~S"
msgstr "Cláusula COND sin prueba condicional: ~S"

#: macros2.lsp:40
msgid "Language ~S is not defined"
msgstr "El lenguaje ~S no está definido"

#: macros2.lsp:50
msgid "Language ~S inherits from ~S"
msgstr "El lenguaje ~S hereda de ~S"

#: macros2.lsp:100
msgid "~S: Language ~S is not defined"
msgstr "~S: El lenguaje ~S no está definido"

#: macros2.lsp:123
msgid "~S ~S: no value for default language ~S"
msgstr "~S ~S: no hay ningún valor para el lenguaje por defecto ~S"

#: macros2.lsp:138
msgid "Invalid clause in ~S: ~S"
msgstr "Cláusula inválida en ~S: ~S"

#: macros2.lsp:157
msgid "~A~%The value is: ~S"
msgstr "~A~%El valor es: ~S"

#: macros2.lsp:161
msgid "The value of ~S should be ~:[of type ~S~;~:*~A~]."
msgstr "El valor de ~S debe ser ~:[del tipo ~S~;~:*~A~]."

#: macros2.lsp:165
msgid "You may input a new value."
msgstr "Puede introducir un nuevo valor."

#: macros2.lsp:168
msgid "~%New ~S: "
msgstr "~%Nuevo ~S: "

#: macros2.lsp:189
msgid "Retry"
msgstr "Reintentar"

#: macros2.lsp:192
msgid "You may input new values."
msgstr "Puede introducir nuevos valores."

#: macros2.lsp:196
msgid "~S must evaluate to a non-NIL value."
msgstr "~S no puede evaluarse como NIL."

#: macros2.lsp:232
msgid "The value of ~S must be of one of the types ~{~S~^, ~}"
msgstr "El valor de ~S debe ser de uno de los tipos ~{~S~^, ~}"

#: macros2.lsp:237
msgid "The value of ~S must be one of ~{~S~^, ~}"
msgstr "El valor de ~S debe ser uno de los siguientes ~{~S~^, ~}"

#: conditio.lsp:1285 macros2.lsp:253
msgid "~S used as a key in ~S, it would be better to use parentheses."
msgstr "~S es usado como una clave en ~S, sería mejor utilizar paréntesis."

#: macros2.lsp:338
msgid "type name should be a symbol, not ~S"
msgstr "el nombre del tipo debe ser un símbolo, no ~S"

#: macros2.lsp:343
msgid "~S is a built-in type and may not be redefined."
msgstr "~S es un tipo predefinido y no puede ser redefinido."

#: macros2.lsp:376
msgid "The deftype expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de DEFTYPE para ~S no puede invocarse con ~S argumentos."

#: macros2.lsp:384
msgid "~S: the name of a symbol macro must be a symbol, not ~S"
msgstr "~S: el nombre de un símbolo de macro debe ser un símbolo, no ~S"

#: macros2.lsp:399
msgid "~S: the symbol ~S names a global variable"
msgstr "~S: el símbolo ~S nombra una variable global"

#: defs1.lsp:98
msgid "missing symbol types (~S/~S/~S) in ~S"
msgstr ""

#: defs1.lsp:105
#, fuzzy
msgid "~S: flag must be one of the symbols ~S, ~S, ~S, not ~S"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: defs1.lsp:418
msgid "~S: ~S does not name a logical host"
msgstr "~S: ~S no es el nombre de un anfitrión \"lógico\""

#: defs1.lsp:456
msgid "No translations for logical host ~S found"
msgstr ""

#: defs1.lsp:542
msgid "~S: argument ~S should be a nonnegative number"
msgstr "~S: el argumento ~S debe ser un número no negativo"

#: defs1.lsp:704
msgid "incorrect date: ~S.~S.~S, ~Sh~Sm~Ss, time zone ~S"
msgstr "fecha incorrecta: ~S/~S/~S, ~Sh~Sm~Ss, zona horaria ~S"

#: defs1.lsp:773
msgid "special form"
msgstr "forma especial"

#: defs1.lsp:776
msgid "function"
msgstr "función"

#: defs1.lsp:778
msgid "macro"
msgstr "macro"

#: places.lsp:24
msgid "The function (~S ~S) is hidden by a SETF expander."
msgstr "Una función de expansión de SETF oculta a la función (~S ~S)"

#: places.lsp:85
msgid "The argument ~S to ~S should be a keyword."
msgstr "El argumento ~S de ~S debe ser un argumento clave."

# Lo mismo de antes. A lo mejor se puede poner "modificable setf". sv
#: places.lsp:140
msgid "Argument ~S is not a SETF place."
msgstr "El argumento ~S no es un lugar `setf' modificable"

#: places.lsp:153
msgid "SETF place ~S produces more than one store variable."
msgstr "El lugar `setf' ~ genera más de una variable de almacenamiento."

#: places.lsp:177 places.lsp:185
msgid "~S: first argument ~S is illegal, not a symbol"
msgstr "~S: el primer argumento ~S es inválido, no es un símbolo"

#: places.lsp:221
msgid "The name of the access function must be a symbol, not ~S"
msgstr "El nombre de la función de acceso debe ser un símbolo, no ~S"

# Duda: En esta y otras partes de este archivo .po aparece la expresión
# `expander' (¡expansor es horrible!). Me dio muchisimos quebraderos de
# cabeza, pero muchos y francamente, estaba absolutamente atascado
# cuando lo pregunté en las listas de Spanish GNU y CLisp.
#
# Curiosamente, la única persona que respondió no tiene ni idea de
# español (Bruno Haible):
#
# "expander" or "expansion function", I would say.
#
# ¡Pues leches, eso mismo! Función de expansión me suena
# perfectísimamente, ...
#
#: places.lsp:254
msgid "The SETF expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de SETF para ~S no puede invocarse con ~S argumentos."

#: places.lsp:291
msgid "Too many arguments to DEFSETF: ~S"
msgstr "Demasiados argumentos para DEFSETF: ~S"

#: places.lsp:295
msgid "The doc string to DEFSETF must be a string: ~S"
msgstr "La cadena de documentación de DEFSETF debe ser una cadena: ~S"

#: places.lsp:305
msgid "Missing store variable in DEFSETF."
msgstr "No se encuentra ninguna variable de almacenamiento en DEFSETF."

#: places.lsp:346
msgid "Illegal syntax in DEFSETF for ~S"
msgstr "Sintaxis inválida en DEFSETF: ~S"

#: places.lsp:359
msgid "(SETF (NTH ...) ...) : index ~S is too large for ~S"
msgstr "(SETF (NTH ...) ...) : el índice ~S es demasiado grande para ~S"

#: places.lsp:459
#, fuzzy
msgid "PSETF called with an odd number of arguments: ~S"
msgstr "~S ha sido invocado con un número impar de argumentos: ~S"

#: places.lsp:505
msgid "REMF: property list with an odd length"
msgstr "REMF: lista de propiedades de longitud impar"

#: places.lsp:555
msgid "In the definition of ~S: &REST variable ~S should be a symbol."
msgstr "En la definición de ~S: la variable &REST ~S debe ser un símbolo."

#: places.lsp:561
msgid "Only one variable is allowed after &REST, not ~S"
msgstr "Sólo se permite una variable después de &REST, no ~S"

#: places.lsp:566
msgid "Illegal in a DEFINE-MODIFY-MACRO lambda list: ~S"
msgstr "Lista lambda inválida en DEFINE-MODIFY-MACRO: ~S"

#: places.lsp:574
msgid "lambda list may only contain symbols and lists, not ~S"
msgstr "la lista lambda sólo puede contener símbolos y listas, no ~S"

# En cristiano creo que sería "Lugar SETF incorrecto". sv
#
# Sí, tienes razón. Creo que cuando traduje este mensaje llevaba
# demasiadas horas delante del ordenador, ... tienes razón, ... cll
#
#: places.lsp:691
msgid "Illegal SETF place: ~S"
msgstr "Lugar `setf' inválido: ~S"

#: places.lsp:710
msgid "SHIFTF called with too few arguments: ~S"
msgstr "SHIFTF ha sido llamado con muy pocos argumentos: ~S"

#: places.lsp:750
msgid "(SETF (GETF ...) ...) : property list with an odd length"
msgstr "(SETF (GETF ...) ...) : lista de propiedades de longitud impar"

#: places.lsp:785
msgid "first argument ~S is illegal, not a symbol"
msgstr "el primer argumento ~S es inválido, no es un símbolo"

#: places.lsp:896
msgid "SETF APPLY is only defined for functions of the form #'symbol."
msgstr "SETF APPLY sólo está definido para funciones de la forma #'símbolo."

# Duda: en Common Lisp existe lo que se denominan los `setf places'. En
# realidad, es una manera bastante correcta de referirse a posiciones de
# memoria (cuyos nombres pueden ser variables, funciones, etc.) que son
# modificables con la primitiva SETF de Lisp. Por ello, traducirlo como
# `modificable' es eminentemente correcto, pero en realidad me da miedo
# porque a los programadores experimentados les mosqueará lo de
# `modificable' a secas. Les resultará mucho más familiar algo como
# `setf modificables', aunque en español esto suene bastante
# regular. cll
#
# En cualquier caso, cuando uno se empeña en emplear la palabra inglesa,
# siempre queda la posibilidad de conservar la sintaxis española,
# por ejemplo: "... no es un lugar modificable `setf'" sv
#
#: places.lsp:902
msgid "APPLY on ~S is not a SETF place."
msgstr "APPLY de ~S no es un lugar `setf' modificable"

#: places.lsp:957
msgid "SETF FUNCALL is only defined for functions of the form #'symbol."
msgstr "SETF FUNCALL sólo está definido para funciones de la forma #'símbolo."

#: floatpri.lsp:341
msgid "argument is not a float: ~S"
msgstr "el argumento no es un número en coma flotante: ~S"

#: type.lsp:30
msgid "~S: invalid type specification ~S"
msgstr "~S: la especificación de tipo ~S es inválida"

#: compiler.lsp:8308 type.lsp:57
msgid "~S: argument to SATISFIES must be a symbol: ~S"
msgstr "~S: el argumento de SATISFIES debe ser un símbolo: ~S"

#: type.lsp:327 type.lsp:336 type.lsp:346 type.lsp:356
msgid "~S: argument to ~S must be *, ~S or a list of ~S: ~S"
msgstr "~S: el argumento de ~S debe ser *, ~S o una lista de ~S: ~S"

#: type.lsp:443
msgid "~S: argument to MOD must be an integer: ~S"
msgstr "~S: el argumento de MOD debe ser un entero: ~S"

#: type.lsp:451
msgid "~S: argument to SIGNED-BYTE must be an integer or * : ~S"
msgstr "~S: el argumento de SIGNED-BYTE debe ser un entero o * : ~S"

#: type.lsp:461
msgid "~S: argument to UNSIGNED-BYTE must be an integer or * : ~S"
msgstr "~S: el argumento de UNSIGNED-BYTE debe ser un entero o * : ~S"

#: type.lsp:635
msgid "Invalid type specifier ~S"
msgstr "Especificador de tipo inválido: ~S"

#: defstruc.lsp:63 foreign1.lsp:423
msgid "~S: this is not a symbol: ~S"
msgstr "~S: esto no es un símbolo: ~S"

#: defstruc.lsp:425
msgid "~S: invalid syntax for name and options: ~S"
msgstr "~S: la sintáxis del nombre y las opciones es inválida: ~S"

#: defstruc.lsp:449
msgid "~S ~S: argument list should be a list: ~S"
msgstr "~S ~S: la lista de argumentos debe ser una lista: ~S"

#: defstruc.lsp:472
msgid "~S ~S: At most one :INCLUDE argument may be specified: ~S"
msgstr "~S ~S: Sólo puede especificarse un argumento :INCLUDE como mucho: ~S"

#: defstruc.lsp:480
msgid ""
"~S: Use of ~S implicitly applies FUNCTION.~@\n"
"                                     Therefore using ~S instead of ~S."
msgstr ""
"~S: El uso de ~S aplica, implícitamente, FUNCTION.~@\n"
"                                     Por lo tanto, se utilizará ~S en vez de ~S."

#: conditio.lsp:102 defstruc.lsp:493
msgid "~S ~S: unknown option ~S"
msgstr "~S ~S: opción ~S desconocida"

#: clos.lsp:3082 conditio.lsp:106 defstruc.lsp:497
msgid "~S ~S: invalid syntax in ~S option: ~S"
msgstr "~S ~S: la sintaxis de la opción ~S es inválida: ~S"

#: clos.lsp:3017 conditio.lsp:110 defstruc.lsp:501
msgid "~S ~S: not a ~S option: ~S"
msgstr "~S ~S: no se trata de una opción ~S: ~S"

# Duda: (y además gorda) Podría parecer que el siguiente mensaje debiera
# traducirse por:
#
# ~S ~S: No hay ningún :PREDICATE sobre estructuras sin nombre.
#
# Sin embargo, el manual "Common Lisp, The Language - 2nd Edition", en
# la página 477 advierte que, en realidad, la opción :PREDICATE no debe
# usarse con estructuras sin nombre:
#
# `A predicate can be defined only if the structure is "named"'
#
# Por lo tanto, he preferido traducir este mensaje de otra manera, tal y
# como veis:
#
#: defstruc.lsp:525
msgid "~S ~S: There is no :PREDICATE on unnamed structures."
msgstr "~S ~S: No puede definirse un :PREDICATE sobre estructuras sin nombre."

#: defstruc.lsp:551
msgid "~S ~S: invalid :TYPE option ~S"
msgstr "~S ~S: opción :TYPE inválida ~S"

#: defstruc.lsp:557
msgid "~S ~S: The :INITIAL-OFFSET must be a nonnegative integer, not ~S"
msgstr "~S ~S: El :INITIAL-OFFSET debe ser un entero no negativo, y no ~S"

#: defstruc.lsp:563
msgid "~S ~S: :INITIAL-OFFSET must not be specified without :TYPE : ~S"
msgstr "~S ~S: El :INITIAL-OFFSET no debe especificarse sin :TYPE : ~S"

#: defstruc.lsp:581
msgid "~S ~S: included structure ~S has not been defined."
msgstr "~S ~S: la estructura incluida ~S no ha sido definida."

#: defstruc.lsp:593
msgid "~S ~S: included structure ~S must be of the same type ~S."
msgstr "~S ~S: la estructura incluida ~S debe ser del tipo ~S."

#: defstruc.lsp:618
msgid "~S ~S: included structure ~S has no component with name ~S."
msgstr "~S ~S: la estructura incluida ~S no tiene ninguna componente con el nombre ~S."

#: defstruc.lsp:647
msgid "~S ~S: The READ-ONLY slot ~S of the included structure ~S must remain READ-ONLY in ~S."
msgstr "~S ~S: La ranura READ-ONLY ~S de la estructura incluida ~S debe permanecer READ-ONLY en ~S."

#: defstruc.lsp:657
msgid "~S ~S: The type ~S of slot ~S should be a subtype of the type defined for the included strucure ~S, namely ~S."
msgstr "~S ~S: El tipo ~S de la ranura ~S debe ser un subtipo del que ha sido definido para la estructura incluida ~S, a saber, ~S."

#: defstruc.lsp:663 defstruc.lsp:761
msgid "~S ~S: ~S is not a slot option."
msgstr "~S ~S: ~S no es una opción de ranura."

#: defstruc.lsp:695
msgid "~S ~S: structure of type ~S can't hold the name."
msgstr "~S ~S: una estructura del tipo ~S no puede contener el nombre."

#: defstruc.lsp:747
msgid "~S ~S: There may be only one slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura con el nombre ~S."

#: format.lsp:70
msgid "The control string terminates within a directive."
msgstr "La cadena de control termina en una directiva."

#: format.lsp:137
msgid "~A must introduce a number."
msgstr "~A debe introducir un número."

#: format.lsp:147
msgid "The control string terminates in the middle of a parameter."
msgstr "La cadena de control termina en medio de un parámetro."

#: format.lsp:227
msgid "Non-existent directive"
msgstr "Directiva no existente"

#: format.lsp:235
msgid "Closing '/' is missing"
msgstr ""

#: format.lsp:248
#, fuzzy
msgid "There is no package with name ~S"
msgstr "No hay ningún paquete con el nombre ~"

#: format.lsp:263
msgid "The closing directive '~A' does not have a corresponding opening one."
msgstr "No existe una directiva de apertura para la de cierre `~A'."

#: format.lsp:268
msgid "The closing directive '~A' does not match the corresponding opening one. It should read '~A'."
msgstr "La directiva de cierre `~A' no se corresponde con la de apertura. Debe leerse `~A'."

#: format.lsp:277 format.lsp:1641 format.lsp:2445
msgid "The ~~; directive is not allowed at this point."
msgstr "La directiva ~~; no está permitida aquí."

#: format.lsp:287
msgid "The ~~newline directive cannot take both modifiers."
msgstr "La directiva ~~newline no puede tomar ambos modificadores."

# Ojo: Estos "ing" no son siempre gerundios.
# Tal vez sea simplemente "...; se esperaba '~A'." sv
#
# Bueno, ..., cuando el mensaje ha salido es que se ha producido un
# error. En tal caso, no se puede estar `esper*ando*', sino que se
# esperaba, ... Si, creo que tienes toda la razón. cll
#
#: format.lsp:308
msgid "An opening directive is never closed; expecting '~A'."
msgstr "No se ha cerrado una directiva; se esperaba `~A'."

#: format.lsp:333
msgid "~%Current point in control string:"
msgstr "~%Posición en curso en la cadena de control:"

# Duda: `fill pointer' (puntero de llenado, o de relleno) es un
# recurso que existe en Common Lisp (y por lo tanto, en CLisp) para
# determinar qué parte de un vector está en uso (la que hay desde el
# principio hasta la posición apuntada por el `fill pointer'). Se trata
# de un término que cualquier programador en Lisp debe conocer porque
# esta palabra clave se utiliza en ocasiones, incluso, como palabra
# reservada para indicar una determinada opción en algunas funciones.
#
# Por ese motivo, he decidido dejarla tal cual, sin traducir. Cuando
# pregunté a Bruno Haible sobre esto me respondió:
#
# Imagine a device attached to a bottle or tank, which shows how much full
# the bottle is, in percent. How would you call this device?
#
# ... y francamente, ¡no se me ocurre como!
#
# Bueno, con el tiempo he decidido que (tal y como señala Bruno Haible)
# lo mejor sería: "puntero de relleno".
#
#: format.lsp:383
msgid "The destination string ~S should have a fill pointer."
msgstr "La cadena de destino ~S debe tener un puntero de relleno."

#: format.lsp:390
msgid "The destination argument ~S is invalid (not NIL or T or a stream or a string)."
msgstr "El argumento destino no es NIL, ni tampoco T, un flujo o una cadena: ~S"

#: format.lsp:419
msgid "~S: The control-string must be a string, not ~S"
msgstr "~S: La cadena de control debe ser una cadena, y no ~S"

#: format.lsp:430
msgid "There are not enough arguments left for this directive."
msgstr "No hay argumentos suficientes para esta directiva."

#: format.lsp:528
msgid "The ~~:@R directive requires an integer in the range 1 - 4999, not ~S"
msgstr "La directiva ~~:@R necesita un entero en el rango 1 - 4999, no ~S"

#: format.lsp:547
msgid "The ~~@R directive requires an integer in the range 1 - 3999, not ~S"
msgstr "La directiva ~~@R necesita un entero en el rango 1 - 3999, no ~S"

#: format.lsp:611
msgid "The argument for the ~~R directive is too large."
msgstr "El argumento de la directiva ~~R es demasiado grande."

#: format.lsp:1331
msgid "The ~~R and ~~:R directives require an integer argument, not ~S"
msgstr "Las directivas ~~R y ~~:R necesitan un argumento entero, no ~S"

#: format.lsp:1353
msgid "The ~~C directive requires a character argument, not ~S"
msgstr "La directiva ~~C necesita un carácter como argumento, no ~S"

#: format.lsp:1579
msgid "The control string argument for the ~~? directive is invalid: ~S"
msgstr "La cadena de control de la directiva ~~? es inválida: ~S"

#: format.lsp:1584
msgid "The argument list argument for the ~~? directive is invalid: ~S"
msgstr "El argumento de la lista de argumentos de la directiva ~~? es inválido: ~S"

#: format.lsp:1646
msgid "The ~~[ parameter must be an integer, not ~S"
msgstr "El parámetro para ~~[ debe ser un entero, no ~S"

#: format.lsp:1665
msgid "The ~~[ directive cannot take both modifiers."
msgstr "La directiva ~~[ no puede tomar ambos modificadores."

#: format.lsp:1691
msgid "The ~~{ directive requires a list argument, not ~S"
msgstr "La directiva ~~{ requiere una lista de argumentos, no ~S"

#: format.lsp:2179
msgid "Too many arguments for this directive"
msgstr "Demasiados argumentos para esta directiva"

#: format.lsp:2718
msgid "The control-string must be a string, not ~S"
msgstr "La cadena de control debe ser una cadena, no ~S"

#: trace.lsp:85 trace.lsp:253
msgid "~S: function name should be a symbol, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

#: trace.lsp:95
msgid "~S: undefined function ~S"
msgstr "~S: la función ~S no está definida"

#: trace.lsp:101
msgid "~S: cannot trace special form ~S"
msgstr "~S: no es posible rastrear la forma especial ~S"

#: trace.lsp:112
msgid "~&;; Tracing ~:[function~;macro~] ~S."
msgstr "~&;; Rastreando la ~:[función~;macro~] ~S."

#: trace.lsp:266
msgid "~S: ~S was traced and has been redefined!"
msgstr "~S: ¡~S estaba siendo rastreada y ha sido redefinida!"

# Este es el formato de las fechas, ... Lo he cogido de la traducción
# alemana y de la francesa, donde es al contrario que la inglesa.
#
#: compiler.lsp:215
msgid "~1{~5@*~D/~4@*~D/~3@*~D ~2@*~2,'0D.~1@*~2,'0D.~0@*~2,'0D~:}"
msgstr "~1{~3@*~D/~4@*~D/~5@*~D ~2@*~2,'0D:~1@*~2,'0D:~0@*~2,'0D~:}"

# Duda: En Lisp, todo el mundo sabe lo que es un `closure'. Bueno, me parece
#       que la mejor traducción es `cierre'.
#
# He visto que los traductores del libro Lisp (3ra edición), de Winston
# y Horn, dicen al final de la página 234 y principio de la 235: "Los
# procedimientos objeto, producidos a partir de una combinación de #' y
# lambda se denominan cerraduras léxicas. El término es usado porque la
# palabra cerradura sugiere que se están involucrando cercas, en tanto
# que la palabra léxica sugiere que las cercas son colocadas de acuerdo
# con las reglas del alcance léxico (o visibilidad) (...) Como no existe
# una forma impresa conveniente para la información de las cercas, la
# forma impresa de una cerradura léxica, sin ser clara, aparecería como:
# #<CERRADURA LÉXICA ...>." Pues bien, propongo que cuando se hagan
# referencias al léxico se diga "cerradura léxica" y, en otro caso,
# "cerradura".
#
# Estos términos me parecen mejores que "cierre léxico" o "cierre" - cll
#
#: compiler.lsp:356
msgid "Bad length of closure vector: ~S"
msgstr "Longitud incorrecta del vector de cerradura: ~S"

# Aquí también junto las exclamaciones. sv
#: compiler.lsp:1750
msgid "Compiler bug!! Occurred in ~A~@[ at ~A~]."
msgstr "¡¡Error del compilador!! Ocurrió en ~A~@[ en ~A~]."

# Soy alérgico al verbo "ignorar". Ignorar en español significa no saber.
# Y eso en inglés se dice "not to know".
# Posibilidades: Descartar, no tener en cuenta. sv
#
# :) Bueno, ... :) Lo cierto es que en el diccionario pone:
#
# "No saber una cosa o muchas cosas, o, de lo contrario, no tener
# noticia de ellas."
#
# O sea, que algo se ignora si no se tienen noticias de ello, ... Creo
# que la traducción está, por lo tanto, correcta. Ahora bien, "no tener
# en cuenta" o "descartar" también me parece muy correcto así que, ¿por
# qué no iba a cambiarlo? :) cll
#
#: compiler.lsp:2427
msgid "Bad declaration syntax: ~S~%Will be ignored."
msgstr "Sintaxis de la declaración incorrecta:~S~%No se tendrá en cuenta."

#: compiler.lsp:2447
msgid "Non-symbol ~S may not be declared SPECIAL."
msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#: compiler.lsp:2454
msgid "Non-symbol ~S may not be declared IGNORE."
msgstr "El \"no símbolo\" ~S no debe declararse IGNORE."

#: compiler.lsp:2461
msgid "Non-symbol ~S may not be declared IGNORABLE."
msgstr "El \"no-símbolo\" ~S no debe declararse IGNORABLE."

#: compiler.lsp:2468
#, fuzzy
msgid "Non-symbol ~S may not be declared READ-ONLY."
msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#: compiler.lsp:2473
msgid "Unknown declaration ~S.~%The whole declaration will be ignored."
msgstr "Declaración desconocida ~S.~%La declaración completa será ignorada."

#: compiler.lsp:2805
msgid " in line ~D"
msgstr " en la línea ~D"

#: compiler.lsp:2806
msgid " in lines ~D..~D"
msgstr " en las líneas ~D..~D"

#
# Duda: He querido traducir la palabra `warning' por `aviso' que es como
# debería decirse en español, ¿no?. ¿Hay algún término adoptado en
# es@li.org, para esta palabra?.
#
# Sí, atención. sv
#
# Si, si, ya lo he hecho, ... En todas partes he puesto "WARNING" por
# "ATENCIÓN". No es exactamente lo mismo, pero me parece una sugerencia
# genial, de hecho me gusta muchísimo más que aquello de "AVISO:". De
# esta manera, parecía que te estaban hablando los "super-tacañones" :) - cll
#
# Sin embargo, Santiago, este caso es bastante peculiar. Verás, si dejo
# "ATENCIÓN" aquí, entonces, durante la compilación de un proyecto con
# varios ficheros en Lisp, podría salir, por ejemplo, un mensaje como el
# siguiente (tomado de un ejemplo real, que conste, ...):
#
# --------------
# ATENCIÓN en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
# Y yo pregunto, en este caso ¿no es mejor poner "ADVERTENCIA"? La
# verdad es que "ADVERTENCIA" me suena mucho mejor que "ATENCIÓN" y que
# "AVISO". En este caso, lo que se tendría es:
#
# --------------
# ADVERTENCIA en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
#
#: compiler.lsp:2818
msgid "~%WARNING~@[ in function ~S~]~A :~%"
msgstr "~%ADVERTENCIA~@[ en la función ~S~]~A :~%"

#: compiler.lsp:2850
msgid "~%ERROR~@[ in function ~S~]~A :~%~?"
msgstr "~% ERROR~@[ en la función ~S~]~A : ~%~?"

#: compiler.lsp:2991
msgid "Code contains dotted list ~S"
msgstr "El código contiene la lista punteada ~S"

# En ocasiones como esta hemos puesto a veces:
# "insuficiente número de argumentos" sv
#
# ¡Pues no me gusta nada!, todavía si dijeses "número insuficiente de
# argumentos". No se, ..., la verdad es que a mí me gusta mucho más "muy
# pocos argumentos" o, si quieres, "pocos argumentos" pero eso de la
# "insuficiencia", ... (me trae otros recuerdos). cll
#
#: compiler.lsp:2995
msgid "Form too short, too few arguments: ~S"
msgstr "Forma demasiado corta, muy pocos argumentos: ~S"

#: compiler.lsp:3000
msgid "Form too long, too many arguments: ~S"
msgstr "Forma demasiado larga, demasiados argumentos: ~S"

#: compiler.lsp:3139
msgid "Invalid form: ~S"
msgstr "La forma ~S es inválida"

# Añado lo que faltaba. sv
#
# Hmmm, ¿se me olvidó algo?. Atención, jóvenes traductores: recordad que
# hay un momento en el que es necesario parar de trabajar, ..., la
# cabeza puede llegar a dar muchas vueltas :) cll
#
#: compiler.lsp:3192
msgid "Not the name of a function: ~S"
msgstr "No es el nombre de una función: ~S"

#: compiler.lsp:3267 compiler.lsp:3347
msgid ""
"~S is neither declared nor bound,~@\n"
"                        it will be treated as if it were declared SPECIAL."
msgstr ""
"~S no está ni declarado ni ligado,~@\n"
"                        será tratado como si hubiese sido declarado SPECIAL."

#: compiler.lsp:3364
msgid ""
"The constant ~S may not be assigned to.~@\n"
"                                                  The assignment will be ignored."
msgstr ""
"La constante ~S no puede asignarse. ~@\n"
"                                                  La asignación será ignorada."

#: compiler.lsp:3506
msgid "argument list to function ~S is dotted: ~S"
msgstr "el argumento de la función ~S es una lista punteada: ~S"

#: compiler.lsp:3512
msgid ""
"~S called with ~S~:[~; or more~] arguments, but it requires ~\n"
"                        ~:[~:[from ~S to ~S~;~S~]~;at least ~*~S~] arguments."
msgstr ""
"~S fue invocado con ~S~:[~; o más~] argumentos, pero requiere ~\n"
"                        ~:[~:[de ~S a ~S~;~S~]~;al menos ~*~S~] argumentos."

#: compiler.lsp:3525
msgid "keyword arguments to function ~S should occur pairwise: ~S"
msgstr "los argumentos clave de la función ~S deben aparecer por pares: ~S"

#
# Afortunadamente, la convención ~#[, para imprimir los términos de una
# lista (en inglés, como dice el estándar) sirve perfectamente para el
# español
#
#: compiler.lsp:3536
msgid ""
"keyword ~S is not allowed for function ~S.~\n"
"                              ~%The only allowed keyword~:[s are ~{~S~#[~; and ~S~:;, ~]~}~; is ~{~S~}~]."
msgstr ""
"la palabra clave ~S no está permitida en la función ~S.~\n"
"                              ~%La~:[s~;~] única~:*~:[s~;~] palabra~:*~:[s~;~] clave permitida~:*~:[s son ~{~S~#[~; y ~S~:;, ~]~}~; es ~{~S~}~]."

#: compiler.lsp:3548
#, fuzzy
msgid "argument ~S to function ~S is not a symbol"
msgstr "el argumento ~S para la función ~S no es un argumento clave"

#: compiler.lsp:4205
msgid ""
"~S called with ~S arguments, but it requires ~\n"
"                                   ~:[~:[from ~S to ~S~;~S~]~;at least ~*~S~] arguments."
msgstr ""
"~S ha sido invocado con ~S argumentos, pero requiere ~\n"
"                                   ~:[~:[de ~S a ~S~;~S~]~;al menos ~*~S~] argumentos."

#: compiler.lsp:4385
msgid "Illegal syntax in LET/LET*: ~S"
msgstr "Sintaxis inválida en LET/LET*: ~S"

#: compiler.lsp:4422
msgid "Lambda list marker ~S not allowed here."
msgstr "El marcador de la lista lambda ~S no está permitido aquí."

#: compiler.lsp:4428
msgid "Missing &REST parameter in lambda list ~S"
msgstr "La lista lambda ~S necesita un parámetro &REST"

#: compiler.lsp:4434
msgid "Lambda list element ~S is superfluous."
msgstr "El elemento ~S de la lista lambda es innecesario."

#: compiler.lsp:4609
msgid "Lambda lists with dots are only allowed in macros, not here: ~S"
msgstr "Sólo se permiten las listas lambda con puntos en la macros, no aquí: ~S"

#: compiler.lsp:4625
msgid "Illegal lambda list element ~S"
msgstr "Elemento inválido en lista lambda ~S"

#: compiler.lsp:4721
msgid "Binding variable ~S can cause side effects despite of IGNORE declaration~%since it is declared SPECIAL."
msgstr "Asociar la variable ~S puede causar otros efectos, a pesar de la declaración~%IGNORE puesto que está declarada como SPECIAL."

#: compiler.lsp:4725
msgid "variable ~S is used despite of IGNORE declaration."
msgstr "La variable ~S está siendo usada a pesar de la declaración IGNORE."

#: compiler.lsp:4736
msgid "variable ~S is not used.~%Misspelled or missing IGNORE declaration?"
msgstr "La variable ~S no está siendo usada.~%¿Está mal escrita o es que falta la declaración IGNORE?"

#: compiler.lsp:4742
#, fuzzy
msgid "The variable ~S is assigned to, despite of READ-ONLY declaration."
msgstr "La variable ~S está siendo usada a pesar de la declaración IGNORE."

#: compiler.lsp:4788 compiler.lsp:4924
msgid "Constant ~S cannot be bound."
msgstr "La constante ~S no puede ligarse."

#: compiler.lsp:5672
msgid "Misplaced declaration: ~S"
msgstr "Declaración situada incorrectamente: ~S"

#: compiler.lsp:5884
msgid "Odd number of arguments to SETQ: ~S"
msgstr "Número impar de argumentos de SETQ: ~S"

#: compiler.lsp:5921 compiler.lsp:5958 compiler.lsp:6056
msgid "Cannot assign to non-symbol ~S."
msgstr "No se puede asignar a un \"no-símbolo\" ~S."

#: compiler.lsp:5933
msgid "Odd number of arguments to PSETQ: ~S"
msgstr "Número impar de argumentos de PSETQ: ~S"

#: compiler.lsp:6194
msgid "Only symbols may be used as variables, not ~S"
msgstr "Sólo pueden usarse los símbolos como variables, no ~S"

#: compiler.lsp:6299
msgid "Illegal syntax in COMPILER-LET: ~S"
msgstr "Sintaxis inválida en COMPILER-LET: ~S"

#: compiler.lsp:6307
msgid "Block name must be a symbol, not ~S"
msgstr "El nombre de un bloque debe ser un símbolo, no ~S"

#: compiler.lsp:6356
msgid "RETURN-FROM block ~S is impossible from here."
msgstr "No es posible hacer RETURN-FROM del bloque ~S desde aquí."

#: compiler.lsp:6427
msgid "Only numbers and symbols are valid tags, not ~S"
msgstr "Sólo son etiquetas de salto válidas los números y los símbolos, no ~S"

#: compiler.lsp:6498
msgid "Tag must be a symbol or a number, not ~S"
msgstr "Una etiqueta de salto debe ser un símbolo o un número, no ~S"

#: compiler.lsp:6503
msgid "GO to tag ~S is impossible from here."
msgstr "No es posible ir (GO) a la etiqueta de salto ~S desde aquí."

#: compiler.lsp:6578
msgid "~S is not a function. It is a locally defined macro."
msgstr "~S no es una función. Se trata de una macro definida localmente."

#: compiler.lsp:6614
msgid "Only symbols and lambda expressions are function names, not ~S"
msgstr "Sólo los símbolos y las expresiones lambda son nombres de funciones válidos, no ~S"

#: compiler.lsp:6665
msgid "Illegal function definition syntax in ~S: ~S"
msgstr "La sintaxis para la definición de la función en ~S es inválida: ~S"

#: compiler.lsp:7105
msgid "Illegal syntax in SYMBOL-MACROLET: ~S"
msgstr "Sintaxis inválida en SYMBOL-MACROLET: ~S"

# Duda: He traducido `EVAL-WHEN situation' por `instante de EVAL-WHEN',
# puesto que el primer argumento de EVAL-WHEN es el *instante* en el que
# debe evaluarse la expresión que viene a continuación y, que de hecho,
# puede ser ---como dice el mensaje--- EVAL, LOAD o COMPILE.
#
#: compiler.lsp:7146
msgid "EVAL-WHEN situation must be EVAL or LOAD or COMPILE, but not ~S"
msgstr "El instante de EVAL-WHEN debe ser EVAL, LOAD o COMPILE, pero no ~S"

#: compiler.lsp:7189
msgid "CASE clause without objects: ~S"
msgstr "Cláusula CASE sin objetos: ~S"

#: compiler.lsp:7199
msgid "~S: the ~S clause must be the last one: ~S"
msgstr "~S: la clausula ~S debe ser la última: ~S"

#: compiler.lsp:7209
msgid "Duplicate ~S label ~S : ~S"
msgstr "~S : La etiqueta ~S se repite: ~S"

#: compiler.lsp:7471
msgid "Too many arguments to ~S"
msgstr "Demasiados argumentos para ~S"

#: compiler.lsp:7486
msgid "Too few arguments to ~S"
msgstr "Muy pocos argumentos para ~S"

#: compiler.lsp:8377
#, fuzzy
msgid "The ~S destination is invalid (not NIL or T or a stream or a string with fill-pointer): ~S"
msgstr "El argumento destino no es NIL, ni tampoco T, un flujo o una cadena: ~S"

# eso de función "a compilar" siempre
# me pareció un vicio moderno.
# Sugerencia: El nombre de la función que hay que compilar ... sv
#
# Perfecto, ... cll
#
#: compiler.lsp:11861
msgid "Name of function to be compiled must be a symbol, not ~S"
msgstr "El nombre de una función que hay que compilar debe ser un símbolo, no ~S"

#: compiler.lsp:11872
msgid "~S: redefining ~S; it was traced!"
msgstr "~S: redefiniendo ~S; ¡estaba siendo rastreada!"

#: compiler.lsp:11880 compiler.lsp:11913
msgid "~S is already compiled."
msgstr "~S ya está compilada."

#: compiler.lsp:11901 compiler.lsp:12492
msgid "Undefined function ~S"
msgstr "La función ~S no está definida"

# Sugerencia: No es blabla ni bla bla. sv
# El ni se ponía la segunda pero no la primera vez, ¿no?
#
# ¡No, hombre, no! Creo que estas equivocado, ..., en el diccionario
# Larousse de Inglés-Español pone:
#
# "nor conj. Ni: he is neither big nor small, no es ni grande ni
# pequeño; neither you nor I, ni tú ni yo || ..."
#
# O sea, que es " ... ni ... ni ..." cll
#
#: compiler.lsp:11922
msgid "Not a lambda expression nor a function: ~S"
msgstr "Ni es una expresión lambda ni es una función: ~S"

#: compiler.lsp:12153
msgid "~&Listing of compilation of file ~A~%on ~@? by ~A, version ~A"
msgstr "~&Listado de la compilación del fichero ~A~%el ~@? por ~A, versión ~A"

#: compiler.lsp:12196
msgid "~%Compiling file ~A ..."
msgstr "~%Compilando el fichero ~A ..."

#: compiler.lsp:12246
msgid "~&~%Compilation of file ~A is finished."
msgstr "~&~%La compilación del fichero ~A ha finalizado."

#
# Duda: ¡atención a la utilización de la directiva ~P!
#
# La siguiente traducción funcionará si, para el caso del español (como
# para el alemán), se pasa el parámetro (eql *error-count* 1), en
# segundo lugar.
#
# Ya no hace falta. Tal y como está hecho no es necesario pasar ningún
# parámetro extra. Así funciona correctamente.
#
# Aquí dudo porque atención no es tan "pluralizable" como aviso. sv
#
# Claro, de hecho, a mí también me pasa lo mismo. He preferido cambiar
# la traducción de "aviso" por "advertencia", en este mensaje y en aquél
# en el que se sacan los mensajes del compilador. ¿No os suena muchísimo
# mejor esta segunda alternativa? - cll
#
#: compiler.lsp:12249
msgid "~%~D error~:P, ~D warning~:P"
msgstr "~%~D error~:*~[es~;~:;es~], ~D advertencia~:P"

#: compiler.lsp:12254
msgid "~%There were errors in the following functions:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Ha habido errores en las siguientes funciones:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12261
msgid "~%The following functions were used but not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes funciones han sido utilizadas pero no definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12267
msgid "~%The following special variables were not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes variables especiales no han sido definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12271
msgid "~%The following special variables were defined too late:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes variables especiales fueron definidas demasiado tarde:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12275
msgid "~%The following functions were used but are deprecated:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes funciones han sido utilizadas pero no aprobadas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12336
msgid "~%~%Disassembly of function ~S"
msgstr "Desensamblado de la función ~S"

#: compiler.lsp:12347
msgid "~%~S required arguments"
msgstr "~%~S argumentos obligatorios"

#: compiler.lsp:12350
msgid "~%~S optional arguments"
msgstr "~%~S argumentos opcionales"

#: compiler.lsp:12353
msgid "~%~:[No rest parameter~;Rest parameter~]"
msgstr "~%~:[Sin parámetro resto~;Parámetro resto~]"

#: compiler.lsp:12358
msgid "~%~S keyword parameter~:P: ~{~S~^, ~}."
msgstr "~%~S parámetro~:P clave: ~{~S~^, ~}."

#: compiler.lsp:12362
msgid "~%Other keywords are allowed."
msgstr "~%Se permiten otros parámetros clave."

#: compiler.lsp:12364
msgid "~%No keyword parameters"
msgstr "~%Sin parámetros clave"

#: compiler.lsp:12381
msgid "Disassembly of function "
msgstr "Desensamblado de la función "

#: compiler.lsp:12399
msgid " required arguments"
msgstr " argumentos obligatorios"

#: compiler.lsp:12404
msgid " optional arguments"
msgstr " argumentos opcionales"

#: compiler.lsp:12409
msgid "Rest parameter"
msgstr "Parámetro resto"

#: compiler.lsp:12412
msgid "No rest parameter"
msgstr "Sin parámetro de resto"

#
# ¡¡Atención a la utilización de la directiva ~P!!
#
# Bueno, en este caso es perfecta :) No hay ningún problema de ningún
# tipo
#
#: compiler.lsp:12419
msgid " keyword parameter~P: "
msgstr "parámetro~P clave: "

#: compiler.lsp:12429
msgid "Other keywords are allowed."
msgstr "Se permiten otras palabras clave."

#: compiler.lsp:12434
msgid "No keyword parameters"
msgstr "Sin parámetros clave"

#: compiler.lsp:12515
msgid "Cannot disassemble ~S"
msgstr "No se puede desensamblar ~S"

#: defs2.lsp:63
msgid "~S: ~S is not a function"
msgstr "~S: ~S no es una función"

#: defs2.lsp:77
msgid "~S: package name ~S should be a string or a symbol"
msgstr "~S: el nombre del paquete ~S debe ser una cadena de caracteres o un símbolo"

#: defs2.lsp:84
msgid "~S ~A: symbol name ~S should be a string or a symbol"
msgstr "~S ~A: el nombre del símbolo ~S debe ser una cadena de caracteres o un símbolo"

#: defs2.lsp:104
msgid "~S ~A: the symbol ~A must not be specified more than once"
msgstr "~S ~A: el símbolo ~A no debe especificarse más de una vez"

#: defs2.lsp:116 defs2.lsp:124
msgid "~S ~A: the ~S option must not be given more than once"
msgstr "~S ~A: no se debe poner la opción ~S más de una vez"

#: defs2.lsp:182
msgid "~S ~A: unknown option ~S"
msgstr "~S ~A: la opción ~S es desconocida"

#: defs2.lsp:186
msgid "~S ~A: invalid syntax in ~S option: ~S"
msgstr "~S ~A: la sintaxis de la opción ~S es inválida: ~S"

#: defs2.lsp:190
msgid "~S ~A: not a ~S option: ~S"
msgstr "~S ~A: no se trata de una opción ~S: ~S"

#: defs2.lsp:246
msgid "This symbol will be created."
msgstr "Este símbolo será creado."

#: defs2.lsp:247
msgid "~S ~A: There is no symbol ~A::~A ."
msgstr "~S ~A: El símbolo ~A::~A no existe."

#: defs2.lsp:321
msgid "The object to be destructured should be a list with ~:[at least ~*~S~;~:[from ~S to ~S~;~S~]~] elements, not ~4@*~S."
msgstr "Los objetos a desmontar deben ser una lista ~:[con al menos ~*~S~;de ~:[~S a ~S~;~S~]~] elementos, y no ~4@*~S."

#: defs2.lsp:390
msgid "~S: macro name should be a symbol, not ~S"
msgstr "~S: el nombre de una macro debe ser un símbolo, no ~S"

#: defs2.lsp:425
msgid "~S: input stream ~S ends within read macro beginning to ~S"
msgstr "~S: el flujo de entrada ~S ha terminado durante el procesamiento de una macro de lectura que empezaba en ~S"

#: defs2.lsp:431
#, fuzzy
msgid "~S from ~S: character read should be a character: ~S"
msgstr "~S en ~S: el carácter leído debe ser un STRING-CHAR: ~S"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: defs2.lsp:452
msgid "~S from ~S: After ~S is ~S an undefined dispatch macro character"
msgstr "~S en ~S: Después de ~S está ~S, un macro carácter sencundario indefinido"

#: defs2.lsp:518 defs2.lsp:533
msgid "~S: ~S of ~S is ambiguous. Please use ~S or ~S."
msgstr ""

#: loop.lsp:48
msgid "~S: syntax error after ~A in ~S"
msgstr "~S: error de sintaxis después de ~A en ~S"

#: loop.lsp:259
#, fuzzy
msgid "~S: missing variable."
msgstr "~S: variable ausente"

#: loop.lsp:270
msgid "~S: After ~S, ~S is interpreted as a type specification"
msgstr "~S: Después de ~S, ~S es interpretado como una especificación de tipo"

#: loop.lsp:574
msgid "~S: ~A clauses should occur before the loop's main body"
msgstr "~S: las claúsulas ~A deben aparecer antes del cuerpo principal del bucle"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lsp:736
msgid "~S: After ~S a plural loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un plural, y no ~A"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lsp:743
msgid "~S: After ~S a singular loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un singular, y no ~A"

#: loop.lsp:912
msgid "~S: questionable iteration direction after ~A"
msgstr "~S: dirección incierta de la iteración después de ~A"

#: loop.lsp:924
msgid "~S: specifying ~A requires FROM or DOWNFROM"
msgstr "~S: especificar ~A requiere FROM o DOWNFROM"

#: loop.lsp:1000
msgid "~S: illegal syntax near ~S in ~S"
msgstr "~S: sintaxis inválida cerca de ~S en ~S"

#: loop.lsp:1007
msgid "~S: ambiguous result of loop ~S"
msgstr "~S: el resultado del bucle ~S es ambiguo"

#: loop.lsp:1168
msgid "~S is possible only from within ~S"
msgstr "~S sólo es posible desde ~S"

#: loop.lsp:1172
msgid "Use of ~S in FINALLY clauses is deprecated because it can lead to infinite loops."
msgstr "La utilización de ~S en las cláusulas FINALLY está desaconsejada puesto que puede provocar bucles infinitos"

#: loop.lsp:1176
msgid "~S is not possible here"
msgstr "~S es imposible aquí"

#: clos.lsp:167 clos.lsp:188
msgid "~S: argument ~S is not a symbol"
msgstr "~S: el argumento ~S no es un símbolo"

#: clos.lsp:174
msgid "~S: ~S does not name a class"
msgstr "~S: ~S no nombra una clase"

#: clos.lsp:194
msgid "~S: ~S is not a class"
msgstr "~S: ~S no es una clase"

#: clos.lsp:201
msgid "~S: cannot redefine built-in class ~S"
msgstr "~S: no se puede redefinir la clase predefinida ~S"

#: clos.lsp:206
msgid "~S: Redefining the COMMON LISP class ~S"
msgstr "~S: Redefiniendo la clase de COMMON LISP ~S"

#: clos.lsp:361
msgid "instance ~S of class ~S has no slots (wrong metaclass)"
msgstr "la instancia ~S de la clase ~S no tiene ranuras (metaclase errónea)"

#: clos.lsp:382 clos.lsp:427
msgid "~S: not a list of slots: ~S"
msgstr "~S: no es una lista de ranuras: ~S"

#: clos.lsp:390
msgid "~S: invalid slot and variable specification ~S"
msgstr "~S: especificación inválida de ranura y variable: ~S"

#: clos.lsp:396 clos.lsp:438
msgid "~S: variable ~S should be a symbol"
msgstr "~S: la variable ~S debe ser un símbolo"

#: clos.lsp:402
msgid "~S: slot name ~S should be a symbol"
msgstr "~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos.lsp:433
msgid "~S: invalid slot and accessor specification ~S"
msgstr "~S: especificación inválida de ranura y función de acceso: ~S"

#: clos.lsp:443
msgid "~S: accessor name ~S should be a symbol"
msgstr "~S: el nombre de la función de acceso ~S debe ser un símbolo"

#: clos.lsp:534
msgid "~S: class name ~S should be a symbol"
msgstr "~S: el nombre de la clase ~S debe ser un símbolo"

#: clos.lsp:541
msgid "~S ~S: expecting list of superclasses instead of ~S"
msgstr "~S ~S: se esperaba una lista de superclases en vez de ~S"

#: clos.lsp:547
msgid "~S ~S: superclass name ~S should be a symbol"
msgstr "~S ~S: el nombre de la superclase ~S debe ser un símbolo"

#: clos.lsp:559
msgid "~S ~S: expecting list of slot specifications instead of ~S"
msgstr "~S ~S: se esperaba una lista de especificación de ranuras en vez de ~S"

#: clos.lsp:569
msgid "~S ~S: slot name ~S should be a symbol"
msgstr "~S ~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos.lsp:574
msgid "~S ~S: There may be only one direct slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura directa con el nombre ~S."

#: clos.lsp:589
msgid "~S ~S: slot options for slot ~S don't come in pairs"
msgstr "~S ~S: las opciones de ranura para ~S no aparecen por pares"

#: clos.lsp:600
msgid "~S ~S, slot option for slot ~S: ~S is not a function name"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una función"

#: clos.lsp:610 clos.lsp:632
msgid "~S ~S, slot option for slot ~S: ~S is not a symbol"
msgstr "~S ~S, opción de ranura para ~S: ~S no es un símbolo"

#: clos.lsp:620 clos.lsp:640 clos.lsp:649 clos.lsp:657
msgid "~S ~S, slot option ~S for slot ~S may only be given once"
msgstr "~S ~S, la opción de ranura ~S para ~S solo debe indicarse una vez"

#: clos.lsp:626
msgid "~S ~S, slot option for slot ~S must have the value ~S or ~S, not ~S"
msgstr "~S ~S, la opción de ranura para ~S debe tener el valor ~S o ~S, y no ~S"

#: clos.lsp:662
msgid "~S ~S, slot option for slot ~S: ~S is not a string"
msgstr "~S ~S, opción de ranura para ~S: ~S no es una cadena de caracteres"

#: clos.lsp:669
msgid "~S ~S, slot option for slot ~S: ~S is not a valid slot option"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una opción de ranura válida"

#: clos.lsp:720
msgid "~S ~S, option ~S may only be given once"
msgstr "~S ~S, la opción ~S sólo se puede indicar una vez"

#: clos.lsp:729 clos.lsp:756
msgid "~S ~S, option ~S: ~S is not a symbol"
msgstr "~S ~S, opción ~S: ~S no es un símbolo"

#: clos.lsp:740
msgid "~S ~S: option ~S should be written ~S"
msgstr "~S ~S: la opción ~S debe escribirse como ~S"

#: clos.lsp:745
msgid "~S ~S, option ~S: arguments don't come in pairs"
msgstr "~S ~S, opción ~S: los argumentos no aparecen en pares"

#: clos.lsp:761
msgid "~S ~S, option ~S: ~S may only be given once"
msgstr "~S ~S, opción ~S: ~S sólo se puede poner una vez"

#: clos.lsp:781
msgid "~S ~S, option ~S: ~S is not a string"
msgstr "~S ~S, opción ~S: ~S no es una cadena de caracteres"

#: clos.lsp:790
msgid "~S ~S: invalid option ~S"
msgstr "~S ~S: la opción ~S es inválida"

#: clos.lsp:897
msgid "~S: Class ~S is being redefined, instances are obsolete"
msgstr "~S: La clase ~S ha sido redefinida, las instancias son obsoletas"

#: clos.lsp:984
msgid "~S ~S: superclass ~S should belong to class STANDARD-CLASS"
msgstr "~S ~S: la superclase ~S debe pertenecer a la clase STANDARD-CLASS"

#: clos.lsp:1154
msgid "~S ~S: inconsistent precedence graph, cycle ~S"
msgstr "~S ~S: grafo de precedencia inconsistente, ciclo ~S"

#: clos.lsp:1193
msgid "(class-precedence-list ~S) and (class-precedence-list ~S) are inconsistent"
msgstr "(class-precedence-list ~S) y (class-precedence-list ~S) son inconsistentes"

#: clos.lsp:1350
msgid "~S: superclass ~S should belong to class BUILT-IN-CLASS"
msgstr "~S: la superclase ~S debe pertenecer a la clase BUILT-IN-CLASS"

#: clos.lsp:1392
msgid "~S: metaclass STRUCTURE-CLASS forbids more than one direct superclass"
msgstr "~S: la metaclase STRUCTURE-CLASS prohibe más de una superclase directa"

#: clos.lsp:1398
msgid "~S: superclass ~S should belong to class STRUCTURE-CLASS"
msgstr "~S: la superclase ~S debe pertenecer a la clase STRUCTURE-CLASS"

#: clos.lsp:1438
msgid "~S: metaclass STRUCTURE-CLASS does not support shared slots"
msgstr "~S: la metaclase STRUCTURE-CLASS no mantiene ranuras compartidas"

#: clos.lsp:1711
msgid "~S ~S: missing lambda list"
msgstr "~S ~S: falta la lista lambda"

#: clos.lsp:1723
msgid "STANDARD method combination doesn't allow the method qualifiers to be ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos.lsp:1876 clos.lsp:1881
msgid "~S ~S: ~S is invalid within ~S methods"
msgstr "~S ~S: ~S es inválido dentro de los métodos ~S"

#: clos.lsp:2119
msgid "Too few arguments to ~S: ~S"
msgstr "Muy pocos argumentos para ~S: ~S"

#: clos.lsp:2248
msgid "The generic function ~S is being modified, but has already been called."
msgstr "La función genérica ~S está siendo modificada, pero ya ha sido invocada."

#: clos.lsp:2807
msgid "~S in ~S: the new arguments ~S have a different effective method than the old arguments ~S"
msgstr "~S en ~S: los argumentos nuevos ~S tienen un método en vigor diferente que los argumentos antiguos ~S"

#: clos.lsp:2832
msgid "~S has ~S, but ~S has ~S required parameters"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros obligatorios"

#: clos.lsp:2837
msgid "~S has ~S, but ~S has ~S optional parameters"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros opcionales"

#: clos.lsp:2842 clos.lsp:2847
msgid "~S has &REST or &KEY, but ~S hasn't."
msgstr "~S tiene parámetros &REST o &KEY, pero ~S no."

#: clos.lsp:2859
msgid "~S doesn't accept the keywords ~S of ~S"
msgstr "~S no acepta las palabras clave ~S de ~S"

#: clos.lsp:2889
msgid "Replacing method ~S in ~S"
msgstr "Reemplazando el método ~S de ~S"

#: clos.lsp:2907
msgid "Removing method ~S in ~S"
msgstr "Borrando el método ~S de ~S"

#: clos.lsp:2935
msgid "~S has no method with qualifiers ~:S and specializers ~S"
msgstr "~S no tiene ningún método con cualificadores ~:S y especializadores ~S"

#: clos.lsp:2964 clos.lsp:3271
msgid "~S doesn't name a generic function"
msgstr "~S no es una función genérica"

#: clos.lsp:3026
msgid "~S ~S: Only ~S declarations are permitted: ~S"
msgstr "~S ~S: Sólo la declaraciones ~S están permitidas: ~S"

#: clos.lsp:3035
msgid "~S ~S: ~S may only be specified once."
msgstr "~S ~S: ~S sólo puede especificarse una vez."

#: clos.lsp:3043
msgid "~S ~S: A string must be specified after ~S : ~S"
msgstr "~S ~S: Debe especificarse una cadena de caracteres después de ~S: ~S"

#: clos.lsp:3048
msgid "~S ~S: Only one ~S string is allowed"
msgstr "~S ~S: Sólo se permite una cadena de caracteres ~S"

#: clos.lsp:3056
msgid "~S ~S: The only valid method combination is ~S : ~S"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos.lsp:3064
msgid "~S ~S: The only valid generic function class name is ~S : ~S"
msgstr "~S ~S: El único nombre válido de una clase de función genérica es ~S : ~S"

#: clos.lsp:3072
msgid "~S ~S: The only valid method class name is ~S : ~S"
msgstr "~S ~S: El único nombre válido de una clase de métodos es ~S : ~S"

#: clos.lsp:3091
msgid "~S ~S: ~S is not one of the required parameters: ~S"
msgstr "~S ~S: ~S no es uno de los parámetros obligatorios: ~S"

#: clos.lsp:3103
msgid "~S ~S: some variable occurs twice in ~S"
msgstr "~S ~S: alguna variable ha aparecido dos veces en ~S"

#: clos.lsp:3108
msgid "~S ~S: ~S is missing some required parameter"
msgstr "~S ~S: ~S necesita algunos parámetros obligatorios"

#: clos.lsp:3137
msgid "~S ~S: No initializations are allowed in a generic function lambda-list: ~S"
msgstr "~S ~S: No están permitidas las inicializaciones en la lista lambda de una función genérica: ~S"

#: clos.lsp:3143
msgid "~S ~S: variable name ~S should be a symbol"
msgstr "~S ~S: el nombre de la variable ~S debe ser un símbolo"

#: clos.lsp:3148
msgid "~S ~S: duplicate variable name ~S"
msgstr "~S ~S: el nombre de la variable ~S está duplicado"

#: clos.lsp:3199
msgid "~S ~S: invalid lambda list portion: ~S"
msgstr "~S ~S: parte de la lista lambda es inválida: ~S"

#: clos.lsp:3252
msgid "Removing all methods of ~S"
msgstr "Borrando todos los métodos de ~S"

#: clos.lsp:3260
msgid "Modifying the parameter profile of ~S"
msgstr "Modificando el perfil de parámetro de ~S"

#: clos.lsp:3316
msgid "~S: ~S is not a generic function specification"
msgstr "~S: ~S no es una especificación de función genérica"

#: clos.lsp:3379
msgid "~S: The name of a class must be a symbol, not ~S"
msgstr "~S: El nombre de una clase debe ser un símbolo, no ~S"

#: clos.lsp:3384
msgid "~S: The name of the built-in class ~S cannot be modified"
msgstr "~S: No es posible modificar el nombre de la clase predefinida ~S"

#: clos.lsp:3427 clos.lsp:3431
msgid "~S: When calling ~S with arguments ~S, no method is applicable."
msgstr "~S: No se puede aplicar ningún método al invocar ~S con los argumentos ~S."

#: clos.lsp:3449 clos.lsp:3453
msgid "~S: When calling ~S with arguments ~S, no primary method is applicable."
msgstr "~S: No se puede aplicar ningún método primario al invocar ~S con los argumentos ~S"

#: clos.lsp:3463
msgid "~S: When calling ~S with arguments ~S, there is no next method after ~S, and ~S was called."
msgstr "~S: Mientras se invoca ~S con los argumentos ~S, no hay ningún método después de ~S, y ~S fue llamado."

#: clos.lsp:3514
msgid "~S: The class ~S has no slot named ~S"
msgstr "~S: La clase ~S no tiene ninguna ranura llamada ~S"

#: clos.lsp:3524
msgid "~S: The slot ~S of ~S has no value"
msgstr "~S: La ranura ~S de ~S no tiene ningún valor"

#: clos.lsp:4032
msgid "~S method for ~S returned ~S"
msgstr ""

#: conditio.lsp:80
msgid "~S: the name of a condition must be a symbol, not ~S"
msgstr "~S: el nombre de una condición debe ser un símbolo, y no ~S"

# En este mensaje, el término `parent-type' se refiere al segundo
# argumento de la macro `define-condition' que, según el estándar, se
# utiliza como lista de super-tipos del que se obtiene una nueva
# condición.
#
# Por ese motivo, he añadido la expresión "super-tipos" - cll
#
#: conditio.lsp:85
msgid "~S: the parent-type list must be a list of symbols, not ~S"
msgstr "~S: la lista de \"super-tipos\" debe ser una lista de símbolos, y no ~S"

#: conditio.lsp:90
msgid "~S: the slot description list must be a list, not ~S"
msgstr "~S: la lista de descripción de la ranura debe ser una lista, y no ~S"

#: conditio.lsp:138
msgid "~S: type ~S is not a subtype of ~S"
msgstr "~S: el tipo ~S no es un subtipo de ~S"

#: conditio.lsp:154
msgid "~S ~S: superfluous arguments ~S"
msgstr "~S ~S: los argumentos ~S son superfluos"

#: conditio.lsp:171
msgid "~S: the condition argument must be a string, a symbol or a condition, not ~S"
msgstr "~S: el argumento de la condición debe ser una cadena de caracteres, un símbolo o una condición, y no ~S"

#: conditio.lsp:564
msgid "~S: illegal syntax of clause ~S"
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: conditio.lsp:570
msgid "~S: misplaced ~S clause: ~S"
msgstr "~S: la clausula ~S está mal colocada: ~S"

#: conditio.lsp:576
msgid "~S: too many variables ~S in clause ~S"
msgstr "~S: demasiadas variables ~S en la clausula ~S"

# Duda: ¿y cómo traduzco `restart'?
#
# He decidido dejar `restart' sin traducir, ... :(
#
#: conditio.lsp:789
msgid "~S: ~S is not a valid restart name here. Use ~S instead."
msgstr "~S: ~S no es válido como nombre de `restart' aquí. En su lugar, use ~S."

#: conditio.lsp:810
msgid "~S: invalid restart name ~S"
msgstr "~S: ~S es un nombre inválido de `restart'"

#: conditio.lsp:817
msgid "~S: No restart named ~S is visible."
msgstr "~S: No hay ningún `restart' visible llamado ~S"

#: conditio.lsp:875 conditio.lsp:934
msgid "~S: not a list: ~S"
msgstr "~S: no es una lista: ~S"

#: conditio.lsp:884 conditio.lsp:943
msgid "~S: invalid restart specification ~S"
msgstr "~S: ~S no es una especificación válida de `restart'"

#: conditio.lsp:895 conditio.lsp:981
msgid "~S: unnamed restarts require ~S to be specified: ~S"
msgstr "~S: es necesario especificar ~S en los `restart' sin nombre: ~S"

#: conditio.lsp:966
msgid "~S: missing lambda list in restart specification ~S"
msgstr "~S: falta la lista lambda en la especificación del `restart' ~S"

#: conditio.lsp:989
msgid "~S: restart cannot be invoked interactively because it is missing a ~S option: ~S"
msgstr "~S: el `restart' no puede invocarse interactivamente porque falta la opción ~S: ~S"

#: conditio.lsp:1188
msgid "~%New ~S [value ~D of ~D]: "
msgstr ""

#: conditio.lsp:1407 conditio.lsp:1523
msgid "Return from ~S loop"
msgstr "Retorno del bucle ~S"

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: conditio.lsp:1491 conditio.lsp:1514
msgid "WARNING:"
msgstr "ATENCIÓN:"

#
# En este caso he tenido que traducir `warning' por `advertencia', en
# vez de `atención'. ¿No querreis que diga algo así como "Esto es más
# serio que un toque de atención"? Así parecería que el compilador le va
# a meter una paliza al pobre programador, ... :) - cll
#
#: conditio.lsp:1503
msgid "~S: This is more serious than a warning: ~A"
msgstr "~S: Esto es más serio que una advertencia: ~A"

#: xcharin.lsp:36
#, fuzzy
msgid "~: argument ~S is not a character"
msgstr "~: el argumento ~ no es un carácter"

#: xcharin.lsp:57
#, fuzzy
msgid "~S: the font argument should be an integer, not ~S"
msgstr "~: el argumento de la fuente debe ser un número y no ~"

#: xcharin.lsp:66
#, fuzzy
msgid "~S: the bits argument should be an integer, not ~S"
msgstr "~: el argumento de los bits debe ser un entero y no ~"

# Ya, ya se que eso de "los nombres de bit" puede sonar muy raro, pero
# es que realmente es así en Common Lisp.  Consúltese el Cltl2, 13.5
# Character Control-Bit Functions, página 385
#
#: xcharin.lsp:88
#, fuzzy
msgid "~S: the only bit names are ~S, ~S, ~S, ~S, not ~S"
msgstr "~: los únicos nombres de bit son :CONTROL, :META, :SUPER y :HYPER, y no ~"

#: screen.lsp:227
msgid "Got bad response from ~S: ~S"
msgstr "Se obtuvo una respuesta incorrecta de ~S: ~S"

#: amigasock.lsp:30
#, fuzzy
msgid "~S: ~S is not a SOCKET-SERVER"
msgstr "~: ~ no es un SOCKET-SERVER"

#: runprog.lsp:162
msgid "~S: File ~S already exists"
msgstr "~S: El fichero ~S ya existe"

# Con un poco de suerte, aquí se podría poner directamente " (s/n) ".
# En fileutils ya se puede. sv
#
# Bueno, pues sí, ..., sí podría hacerse. Ahora bien, para eso es
# necesario modificar el código fuente del clisp (lo cual no es nada
# complicado gracias a la localizacion de codigo fuente del modo .PO
# desde Emacs :). De momento, lo dejo tal cual (aunque queda pachín,
# pachán, ... :( ) y luego lo modificaré, ..., ¿vale?. cll
#
#: query.lsp:12
msgid " (y/n) "
msgstr " (si(y)/no(n)) "

#: query.lsp:23
msgid "Please answer with y or n : "
msgstr "Por favor, responda con y(si) o n(no) : "

#: query.lsp:33
msgid " (yes/no) "
msgstr " (si(yes)/no(no)) "

#: query.lsp:43
msgid "Please answer with yes or no : "
msgstr "Por favor, responda con yes(si) o no(no) : "

# paquete (?) sv
#
# Bueno, podría parecer muy conveniente. Sin embargo, verás, ..., lo de
# *package* está puesto a nivel de programa. Es decir, Bruno Haible y
# compañía lo tienen puesto así desde su propio programa. Por lo tanto,
# si lo cambio en un par de mensajes seguirá apareciendo en muchos otros
# sitios. Prefiero ser consistente y dejarlo así. cll
#
# Además, no está traducido ni en alemán ni en inglés. cll
#
#: reploop.lsp:53
msgid "[*package* invalid]"
msgstr "[*package* inválido]"

#: reploop.lsp:162
#, fuzzy
msgid "Values: "
msgstr "valores: "

# Me suele gustar más "utilice" (porque me parece más "fino"). sv
#
# De acuerdo, ..., cambiado `use' por `utilice'. A mí también me gusta más. cll
#
# Y además, (recomendación tuya, Santiago), `command' por `orden', en
# vez de `comando' - cll
#
#: reploop.lsp:170
#, fuzzy
msgid ""
"\n"
"Help = this list\n"
"Use the usual editing capabilities.\n"
"(quit) or (exit) leaves CLISP."
msgstr ""
"\n"
"Help = esta lista\n"
"Utilice las órdenes de edición habituales"

#
# Cambiado `comando' por `orden', que parece ser muchísimo mejor - cll
#
#: reploop.lsp:179
msgid ""
"\n"
"Help   = this command list\n"
"Abort  = abort to the next recent input loop\n"
"Unwind = abort to the next recent input loop\n"
"Mode-1 = inspect all the stack elements\n"
"Mode-2 = inspect all the frames\n"
"Mode-3 = inspect only lexical frames\n"
"Mode-4 = inspect only EVAL and APPLY frames (default)\n"
"Mode-5 = inspect only APPLY frames\n"
"Where  = inspect this frame\n"
"Up     = go up one frame, inspect it\n"
"Top    = go to top frame, inspect it\n"
"Down   = go down one frame, inspect it\n"
"Bottom = go to bottom (most recent) frame, inspect it\n"
"Backtrace-1 = list all stack elements\n"
"Backtrace-2 = list all frames\n"
"Backtrace-3 = list all lexical frames\n"
"Backtrace-4 = list all EVAL and APPLY frames\n"
"Backtrace-5 = list all APPLY frames\n"
"Backtrace   = list stack in current mode\n"
"Break+ = set breakpoint in EVAL frame\n"
"Break- = disable breakpoint in EVAL frame\n"
"Redo   = re-evaluate form in EVAL frame\n"
"Return = leave EVAL frame, prescribing the return values"
msgstr ""
"\n"
"Help   = esta lista de órdenes\n"
"Abort  = volver al bucle de entrada más reciente\n"
"Unwind = volver al bucle de entrada más reciente\n"
"Mode-1 = inspeccionar todos los elementos de la pila\n"
"Mode-2 = inspeccionar todos los marcos\n"
"Mode-3 = inspeccionar únicamente los marcos léxicos\n"
"Mode-4 = inspeccionar sólo los marcos de los tipos EVAL y APPLY (por\n"
"         defecto)\n"
"Mode-5 = inspeccionar sólo los marcos de tipo APPLY\n"
"Where  = inspeccionar el marco actual\n"
"Up     = ascender un marco, e inspeccionarlo\n"
"Top    = ir al primer marco, e inspeccionarlo\n"
"Down   = descender un marco e inspeccionarlo\n"
"Bottom = ir al último marco (el más reciente) e inspeccionarlo\n"
"Backtrace-1 = mostrar todos los elementos de la pila\n"
"Backtrace-2 = mostrar todos los marcos\n"
"Backtrace-3 = mostrar todos los marcos léxicos\n"
"Backtrace-4 = mostrar todos los marcos de los tipos EVAL y APPLY\n"
"Backtrace-5 = mostrar todos los marcos del tipo APPLY\n"
"Backtrace   = mostrar la pila en el modo actual\n"
"Break+ = establecer un punto de ruptura en un marco de tipo EVAL\n"
"Break- = desactivar un punto de ruptura en un marco de tipo EVAL\n"
"Redo   = re-evaluar la forma en un marco EVAL\n"
"Return = abandonar un marco EVAL con los valores de vuelta indicados"

#: reploop.lsp:234
msgid ""
"\n"
"Continue = continue evaluation"
msgstr ""
"\n"
"Continue = continuar la evaluación"

#: reploop.lsp:301
msgid "You can continue (by typing 'continue')."
msgstr "Puede continuar (tecleando `continue')."

# Duda: Los `restarts' son un mecanismo muy, muy eficiente en Common
# Lisp para la recuperación de errores.
#
# Es posible programar una sección de código de modo que cuando sucede
# algún error se invoquen determinados `restarts' (elegidos y, más aún,
# programados por el propio programador). CLisp, entonces, presenta un
# menú con todos los `restarts' disponibles; el usuario debe elegir
# entre los posibles `restarts' para continuar la evaluación o
# cualquiera de las acciones de depuración que proporciona el entorno.
#
# Pero ¿cómo traducir `restart'? ¿re-entrada, ...? Hmmm, ..., no me
# suena nada bien. Por ese motivo, he preferido sustituir la palabra por
# una expresión: `También es posible continuar en los siguientes
# puntos:", y cuando no sea posible aplicar una expresión de este tipo,
# dejaré `restart' sin traducir hasta que se me ocurra algo más
# original.
#
# ¡¡Necesito ayuda!! :)
#
#: reploop.lsp:320
msgid "The following restarts are available too:"
msgstr "También es posible continuar en los siguientes puntos:"

#: reploop.lsp:321
msgid "The following restarts are available:"
msgstr "Es posible continuar en los siguientes puntos:"

# ¿form no era formulario? (o a lo mejor es algo de lisp que no sé). sv
#
# En Visual Basic (y los lenguajes orientados a eventos), form es formulario.
# Sin embargo, en Lisp form es forma. Se refiere a las sentencias Lisp. cll
#
#: reploop.lsp:413
msgid ""
"\n"
"Step     = step into form: evaluate this form in single step mode\n"
"Next     = step over form: evaluate this form at once\n"
"Over     = step over this level: evaluate at once up to the next return\n"
"Continue = switch off single step mode, continue evaluation\n"
"Step-until, Next-until, Over-until, Continue-until:\n"
"           same as above, specify a condition when to stop"
msgstr ""
"\n"
"Step     = entrar en una forma: evaluar esta forma en el modo paso a paso\n"
"Next     = saltarse una forma: evaluar esta forma en un solo paso\n"
"Over     = saltarse este nivel: evaluar hasta el siguiente retorno\n"
"Continue = desactivar el modo paso a paso y continuar la evaluación\n"
"Step-until, Next-until, Over-until, Continue-until:\n"
"           lo mismo que antes, especifique una condición de parada"

# Duda: Francamente, no sé porqué motivo esto no fué traducido al
# FRANCÉS o al INGLÉS (compruébese en el código, ...) porque en
# realidad, queda pero que muy bien poner `paso' cuando se hace la
# depuración paso a paso, ...
#
# Este mensaje, de hecho, aparece cuando se hace algo del tipo:
#
# > (step (+ 2 3))
# step 1 --> (+ 2 3)
# Step 1>
#
# ..., donde, traduciendo el primer `step' al español, queda algo muy
# propio:
#
# > (step (+ 2 3))
# paso 1 --> (+ 2 3)
# Step 1>
#
# A mi me gusta así, ..., ¡¡A SACO!!
#
#: reploop.lsp:434 reploop.lsp:479
msgid "step "
msgstr "paso "

#: reploop.lsp:438
msgid "no values"
msgstr "sin valores"

#: reploop.lsp:439
msgid "value: "
msgstr "valor: "

#: reploop.lsp:443
msgid " values: "
msgstr " valores: "

#: reploop.lsp:507
msgid "condition when to stop: "
msgstr "condición de parada: "

# Nota: La utilización de dribbling viene de la función dribble de Lisp.
#       Dicha función graba una sesión Lisp en el archivo que se indique en la
#       llamada a la función.
#
# La traducción no juega, de esa manera, con las palabras.
#
#: dribble.lsp:19
msgid "Already dribbling to ~S"
msgstr "Ya se está grabando la sesión en ~S"

#: dribble.lsp:105
msgid "Currently not dribbling."
msgstr "En este momento, no se está grabando la sesión."

#: describe.lsp:44
msgid "constant"
msgstr "constante"

#: describe.lsp:46
msgid "symbol-macro"
msgstr ""

#: describe.lsp:47
msgid "variable"
msgstr "variable"

#: describe.lsp:54
msgid "type"
msgstr "tipo"

#: describe.lsp:60
msgid "class"
msgstr "clase"

# Duda: Lo que he dicho unos pocos mensajes más arriba --> Slot por
# slot, ...
#
# Pues no, ... A partir de la versión 1.4, `slot' es "ranura", tal y
# como se propone en la lista de spanglish.
#
#: describe.lsp:134
#, fuzzy
msgid "~%Slots:"
msgstr "~%Ranuras:"

#: describe.lsp:141
msgid "unbound"
msgstr "sin asociar"

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#: describe.lsp:144
#, fuzzy
msgid "~%No slots."
msgstr "~%Sin ranuras."

#: describe.lsp:151
msgid "a foreign pointer"
msgstr "una puntero externo"

#: describe.lsp:154
msgid "a foreign address"
msgstr "una dirección externa"

#: describe.lsp:157
msgid "a foreign variable of foreign type ~S."
msgstr "una variable externa del tipo extranjero ~S."

#: describe.lsp:161
msgid "a foreign function taking foreign types ~:S and returning foreign type ~S."
msgstr ""

#: describe.lsp:165
msgid "a byte specifier, denoting the ~S bits starting at bit position ~S of an integer."
msgstr "un especificador de byte que denota los ~S bits que comienzan en el bit ~S de un entero"

#: describe.lsp:168
msgid "a special form handler."
msgstr "un manipulador de forma especial."

#: describe.lsp:170
msgid "a load-time evaluation promise."
msgstr "una promesa de evaluación en tiempo de carga."

#: describe.lsp:172
#, fuzzy
msgid "a symbol macro handler."
msgstr "un manipulador de forma especial."

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: describe.lsp:174
#, fuzzy
msgid "an encoding."
msgstr "un cons."

#: describe.lsp:179
msgid "a GC-invisible pointer to ~S."
msgstr ""

#: describe.lsp:182
msgid "a GC-invisible pointer to a now defunct object."
msgstr ""

#: describe.lsp:184
msgid "a label used for resolving #~D# references during READ."
msgstr "una etiqueta para resolver #~D# referencias en READ."

#: describe.lsp:188
msgid "a pointer into the stack. It points to:"
msgstr "Un puntero a la pila. Apunta a:"

#: describe.lsp:191
msgid "a special-purpose object."
msgstr "un objeto de propósito especial."

#: describe.lsp:193
msgid "a machine address."
msgstr "una dirección de máquina."

#: describe.lsp:195
msgid "an instance of the CLOS class ~S."
msgstr "una instancia de la clase CLOS ~S."

#: describe.lsp:199
msgid "a structure of type ~S."
msgstr "una estructura del tipo ~S."

#: describe.lsp:203
msgid "~%As such, it is also a structure of type ~{~S~^, ~}."
msgstr "Como tal, también es una estructura del tipo ~{~S~^, ~}."

#: describe.lsp:217
msgid "a list of length ~S."
msgstr "una lista de longitud ~S."

#: describe.lsp:220
msgid "a dotted list of length ~S."
msgstr "una lista punteada de longitud ~S."

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: describe.lsp:222
msgid "a cons."
msgstr "un cons."

#: describe.lsp:225
msgid "a cyclic list."
msgstr "una lista cíclica."

#: describe.lsp:227
msgid "the empty list, "
msgstr "la lista vacía, "

#: describe.lsp:230
#, fuzzy
msgid "the symbol ~S, "
msgstr "el símbolo ~S"

#: describe.lsp:234
msgid "lies in ~S"
msgstr "está en el ~S"

# Duda: He traducido al estilo del mensaje en francés: "n'appartient à
# aucun paquetage"
#
#: describe.lsp:237
msgid "is uninterned"
msgstr "no aparece en ningún paquete"

# Nota: Caso brillante de la generación de mensajes diferentes gracias a las
#       directivas condicionales del Clisp (y del Common Lisp en general).
#
#: describe.lsp:251
#, fuzzy
msgid ", is accessible in the package~:[~;s~] ~{~A~^, ~}"
msgstr " y es accesible desde ~:[el paquete~;los paquetes~] ~{~A~^, ~}"

#: describe.lsp:256
#, fuzzy
msgid ", is a keyword"
msgstr ", una palabra clave"

#: describe.lsp:259
msgid ", a constant"
msgstr ", una constante"

#: describe.lsp:261
msgid ", a variable declared SPECIAL"
msgstr ", una variable declarada SPECIAL"

#: describe.lsp:262
msgid ", a variable"
msgstr ", una variable"

#: describe.lsp:264
#, fuzzy
msgid " (macro: ~s)"
msgstr " (macro)"

#: describe.lsp:267
#, fuzzy
msgid ", value: ~s"
msgstr " valores: "

#: describe.lsp:270
msgid ", names "
msgstr ", nombra "

#: describe.lsp:272
#, fuzzy
msgid "a special operator"
msgstr "una forma especial"

# Sugerencia: definición de macro. sv
#
# Hmmm, ..., lo de macro definición es bastante típico en informática
# (ya sabes, ...) Sin embargo, en Lisp se suele decir definición de
# macro, tal y como tú propones, ..., pues vale, ¡sugerencia
# completamente aceptada! cll
#
#: describe.lsp:274
msgid " with macro definition"
msgstr " con definición de macro"

#: describe.lsp:276
#, fuzzy
msgid "a~:[~; deprecated~] function"
msgstr "una función ~:[interpret~;compil~]ada."

#: describe.lsp:279
msgid "a macro"
msgstr "una macro"

#: describe.lsp:284
msgid ", names a type"
msgstr ", nombra un tipo"

#: describe.lsp:288
msgid ", names a class"
msgstr ", nombra una clase"

#: describe.lsp:294
msgid ", has the propert~@P ~{~S~^, ~}"
msgstr ", tiene ~[~;la propiedad~:;las propiedades~] ~{~S~^, ~}"

#: describe.lsp:297 describe.lsp:331 describe.lsp:354 describe.lsp:373 describe.lsp:416
msgid "."
msgstr "."

#: describe.lsp:301
#, fuzzy
msgid "~%Documentation as a ~a:~%~a"
msgstr "~%documentación: ~A"

#: describe.lsp:303 describe.lsp:442
#, fuzzy
msgid "~%For more information, evaluate ~{~S~^ or ~}."
msgstr "~%Para más información, evalúe ~{~S~^ o ~}."

#: describe.lsp:307
#, fuzzy
msgid "an integer, uses ~S bit~:p, is represented as a ~(~A~)."
msgstr "un entero que usa ~S bits y se representa como un ~(~A~)."

#: describe.lsp:310
msgid "a rational, not integral number."
msgstr "un racional, no un número entero."

#: describe.lsp:312
msgid "a float with ~S bits of mantissa (~(~A~))."
msgstr "un número en coma flotante con ~S bits de mantisa (~(~A~))."

#: describe.lsp:315
msgid "a complex number "
msgstr "un número complejo "

#: describe.lsp:320
msgid "at the origin"
msgstr "en el origen"

#: describe.lsp:321
msgid "on the ~:[posi~;nega~]tive real axis"
msgstr "en el eje real ~:[posi~;nega~]tivo"

#: describe.lsp:324
msgid "on the ~:[posi~;nega~]tive imaginary axis"
msgstr "en el eje imaginario ~:[posi~;nega~]tivo"

#: describe.lsp:326
msgid "in ~:[~:[first~;fourth~]~;~:[second~;third~]~] the quadrant"
msgstr "en el ~:[~:[primer~;cuarto~]~;~:[segundo~;tercer~]~] cuadrante"

# Si es lo que me imagino, tal vez sería mejor poner "del plano complejo".
# (como matemático que soy, me suena mejor :-). sv
#
# Pues sí, es exactamente lo que te imaginas, ..., "el plano de los números
# gaussianos" era una >>horrible<< traducción, ... ¡Gracias! cll
#
#: describe.lsp:328
msgid " of the Gaussian number plane."
msgstr " del plano complejo."

#: describe.lsp:330
msgid "a character"
msgstr "un carácter"

#: describe.lsp:335
msgid "~%Unicode name: ~A"
msgstr ""

#: describe.lsp:336
msgid "~%It is not defined by the Unicode standard."
msgstr ""

#: describe.lsp:337
msgid "~%It is a ~:[non-~;~]printable character."
msgstr "~% Se trata de un carácter ~:[no ~;~]imprimible."

#: describe.lsp:340
msgid "~%Its use is non-portable."
msgstr "~%Su utilización no es portable."

#: describe.lsp:342
msgid "a~:[~:[ closed ~;n output-~]~;~:[n input-~;n input/output-~]~]stream."
msgstr "un flujo ~:[~:[cerrado~;de salida~]~;~:[de entrada~;de entrada/salida~]~]."

#: describe.lsp:348
msgid "the package named ~A"
msgstr "el paquete ~A"

#: describe.lsp:352
msgid ". It has the nicknames ~{~A~^, ~}"
msgstr ". Tiene los apodos ~{~A~^, ~}"

# Duda: Debo comprobarlo en el código fuente de CLisp pero estoy casi
# seguro que esto es mucho mejor dejarlo sin traducir, ... cll
#
#: describe.lsp:357
#, fuzzy
msgid "~%It "
msgstr "~%"

#: describe.lsp:359
msgid "imports the external symbols of the package~:[~;s~] ~{~A~^, ~} and "
msgstr "importa los símbolos externos de~:[l paquete~; los paquetes~] ~{~A~^, ~} y "

#: describe.lsp:364
#, fuzzy
msgid "exports ~:[no symbols~;the symbols~:*~{~<~%~:; ~S~>~^~}~%~]"
msgstr "~:[no exporta ningún símbolo~;exporta los símbolos~:*~{~<~%~:; ~S~>~^~}~]"

#: describe.lsp:366
#, fuzzy
msgid "exports ~[no symbols~:;~:*~:d symbols~]"
msgstr "~:[no exporta ningún símbolo~;exporta los símbolos~:*~{~<~%~:; ~S~>~^~}~]"

#: describe.lsp:369
#, fuzzy
msgid " to the package~:[~;s~] ~{~A~^, ~}"
msgstr " ~:[al paquete~;a los paquetes~]: ~{~A~^, ~}"

#: describe.lsp:372
msgid ", but no package uses these exports"
msgstr ""

#: describe.lsp:374
msgid "a deleted package."
msgstr "un paquete borrado."

#
# Nota: Muy, muy importante.
#
# En la `españolización' de CLisp, debe programarse de nuevo la
# directiva ~P, para que los plurales se formen añadiendo "es" si el
# argumento no es `eql' a 1.
#
# Asimismo, debieran revisarse otras directivas de `format' como, por
# ejemplo, ~@P, ~:R, etc.
#
# ¡¡Pues no!! Cuando le dije esto a Bruno Haible, él me dijo que el
# estándar Common Lisp - The Language, no contemplaba la realización de
# este tipo de directivas en otros idiomas, sino especificamente en
# inglés. Ni español, ni alemán, ni francés, ...
#
#: describe.lsp:376
msgid "a hash table with ~S entr~:@P."
msgstr "una tabla hash con ~S entrada~:*~[s~;~:;s~]."

# Este mensaje tiene una especial dificultad, porque de el deberían
# salir cosas del tipo: "una tabla de lectura" (con `tabla de lectura'
# al final del mensaje) o "la tabla de lectura de Common Lisp" (con
# `tabla de lectura' al principio).
#
# Afortunadamente, la situación puede salvarse sin ningún problema
# gracias a la directiva ~:* de format
#
#: describe.lsp:379
msgid "~:[a~;the Common Lisp~] readtable."
msgstr "~:[una~;la~] tabla de lectura~:*~:[~; de Common Lisp~]"

#: describe.lsp:382
msgid "a ~:[~;portable ~]pathname~:[.~;~:*, with the following components:~{~A~}~]"
msgstr "una trayectoria~:[~; portátil~]~:[.~;~:*, constituída por: ~{~A~}~]"

#: describe.lsp:397
msgid "a random-state."
msgstr "un estado aleatorio."

#: describe.lsp:401
msgid "a~:[~; simple~] ~A dimensional array"
msgstr "una matriz~:[~; simple~] de dimensión ~A"

#: describe.lsp:404
msgid " (vector)"
msgstr " (vector)"

#: describe.lsp:406
msgid " of ~(~A~)s"
msgstr " de ~(~A~)s"

#: describe.lsp:409
msgid ", adjustable"
msgstr ", ajustable"

#: describe.lsp:411
msgid ", of size ~{~S~^ x ~}"
msgstr ", de tamaño ~{~S~^ x ~}"

#: describe.lsp:414
msgid " and current length (fill-pointer) ~S"
msgstr " y longitud actual (fill-pointer) ~S"

#: describe.lsp:421
msgid "a foreign function."
msgstr "una función externa."

#: describe.lsp:427
msgid "a built-in system function."
msgstr "una función predefinida del sistema."

#: describe.lsp:435
msgid "a~:[n interpret~; compil~]ed function."
msgstr "una función ~:[interpret~;compil~]ada."

#: describe.lsp:445
#, fuzzy
msgid "~%argument list: ~:S"
msgstr "~%lista de argumentos: ~S"

#: describe.lsp:448
#, fuzzy
msgid "~%documentation: ~A"
msgstr "~%documentación: ~A"

#: describe.lsp:453
msgid "~&~%~A [see above]"
msgstr ""

#: describe.lsp:456
msgid "~&~%~A is "
msgstr ""

#: describe.lsp:520
msgid "~S: ~S is not a function."
msgstr "~S: ~S no es una función."

#: describe.lsp:549
#, fuzzy
msgid "~%Argument list: "
msgstr "~%lista de argumentos: "

#: room.lsp:17
msgid "~S: argument must be ~S, ~S or ~S, not ~S"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: room.lsp:51 room.lsp:215
msgid "Total"
msgstr "Total"

#: room.lsp:59
msgid "~%Bytes permanently allocated:   ~9D~%Bytes currently in use:        ~9D~%Bytes available until next GC: ~9D~%"
msgstr "~%Bytes permanentemente asignados:   ~9D~%Bytes actualmente en uso:        ~9D~%Bytes disponibles hasta el próximo GC: ~9D~%"

#: edit.lsp:31
msgid "No external editor installed."
msgstr "No hay ningún editor externo instalado"

#: edit.lsp:103
msgid "~S cannot be edited."
msgstr "~S no puede ser editado."

#: edit.lsp:122
msgid "~S: source code for ~S not available."
msgstr "~S: el código fuente de ~S no está disponible."

#: macros3.lsp:13
msgid ""
"The form ~S yielded ~:[no values~;~:*~{~S~^ ; ~}~] ,~@\n"
"                       that's not of type ~S."
msgstr ""
"La forma ~S ~:[no produjo ningún valor~;produjo ~:*~{~S~^ ; ~}~] ,~@\n"
"                       que no es del tipo ~S."

#: macros3.lsp:64
msgid "LETF* code contains a dotted list, ending with ~S"
msgstr "El código del LETF* contiene una lista punteada que termina con ~S"

#: macros3.lsp:83
msgid "illegal syntax in LETF* binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF*: ~S"

#: macros3.lsp:227
msgid "LETF code contains a dotted list, ending with ~S"
msgstr "El código de LETF contiene una lista punteada que termina con ~S"

#: macros3.lsp:246
msgid "illegal syntax in LETF binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF: ~S"

# Creo que si ~S es un sólo carácter, te cabe en la misma línea :-) sv
#
#: foreign1.lsp:86
msgid "Cannot map string ~S to C since it contains a character ~S"
msgstr "La cadena ~S no puede convertirse a C puesto que contiene el carácter ~S"

#: foreign1.lsp:128
msgid "Incomplete FFI type ~S is not allowed here."
msgstr "El tipo incompleto FFI ~S no está permitido aquí"

#: foreign1.lsp:134
msgid "FFI type should be a symbol, not ~S"
msgstr "Un tipo FFI debe ser un símbolo, no ~S"

# Duda: pues un poco lo de siempre. FFI significa Foreign Function
# Interface y todo el mundo sabe que es el módulo de llamadas a
# funciones escritas en otro lenguaje (lo que yo he traducido como
# llamadas extranjeras). Los programadores avanzados en Lisp (y sólo
# ellos podrían ver un mensaje como este, ...) saben muy bien lo que es
# FFI. ¿Lo dejo así?, ...
#
# Uno de nuestros revisores (César Ballardini) dijo en cierta ocasión:
# "No es necesario explicar la terminología dentro de su propio contexto."
# Es decir: Si finalmente te decides por FFI (que por lo que dices
# parece lo más razonable), pon cuidado de no explicarlo tanto, por ejemplo,
# en el mensaje anterior al anterior a este. sv
#
# Vale, pues entonces se queda como FFI ¡y listo! cll
#
#: foreign1.lsp:138
msgid "Invalid FFI type: ~S"
msgstr "Tipo FFI inválido: ~S"

#: foreign1.lsp:155 foreign1.lsp:220
msgid "Invalid ~S component: ~S"
msgstr "Componente ~S inválida: ~S"

#: foreign1.lsp:329
msgid "Invalid option in ~S: ~S"
msgstr "Opción inválida en ~S: ~S"

#: foreign1.lsp:333
msgid "Only one ~S option is allowed: ~S"
msgstr "Sólo se permite una opción ~S: ~S"

#: foreign1.lsp:350
msgid "Invalid parameter specification in ~S: ~S"
msgstr "Especificación de parámetro inválida en ~S: ~S"

#: foreign1.lsp:411
msgid "The name must be a string, not ~S"
msgstr "El nombre debe ser una cadena, no ~S"

#: foreign1.lsp:416
msgid "The name ~S is not a valid C identifier"
msgstr "El nombre ~S no es un identificador válido en C"

#: foreign1.lsp:671
msgid "illegal foreign data type ~S"
msgstr "el tipo de datos extranjero ~ es inválido"

#: foreign1.lsp:801
msgid "~S: ~S option missing in ~S"
msgstr "~S: falta la opción ~S en ~S"

#: foreign1.lsp:996
msgid "~S: :OUT argument is not a pointer: ~S"
msgstr "~S: el argumento :OUT no es un puntero: ~S"

#: foreign1.lsp:1060
msgid "~S is only allowed after ~S: ~S"
msgstr "Sólo se puede poner ~S después de ~S: ~S"

#: affi1.lsp:41
msgid "Basename ~S not a keyword or libraryname ~S not a string"
msgstr "La base ~S no es una palabra clave o el nombre de la biblioteca ~S no es una cadena de caracteres"

#: affi1.lsp:48
msgid "Library redefinition: old ~S, new ~S"
msgstr "La biblioteca llamada ~S ha sido redefinida como ~S"

#: affi1.lsp:58
msgid "Unknown library: ~S"
msgstr "Biblioteca desconocida: ~S"

#: affi1.lsp:85
msgid "Library ~S is not open"
msgstr "La biblioteca ~S no está abierta"

#: affi1.lsp:147
msgid "Unknown function of library ~S: ~S"
msgstr "No se conoce ninguna función en la biblioteca ~S con el nombre ~S"

#: affi1.lsp:173
msgid "Offset must be a fixnum: ~S"
msgstr "El desplazamiento no es del tipo FIXNUM: ~S"

#: affi1.lsp:184
msgid "~&;; redefining foreign library function ~S~%;;  from ~S to ~S~%"
msgstr "~&;; redefiniendo la función ~S de la biblioteca externa~%;;  de ~S a ~S~% "

#: affi1.lsp:203
msgid "Unknown register: ~S"
msgstr "Registro desconocido: ~S"

#: affi1.lsp:215
msgid "Invalid parameter specification ~S in function ~S"
msgstr "La especificación de parámetros ~S de la función ~S es incorrecta"

#: affi1.lsp:227
msgid "Unknown library function: ~S"
msgstr "La función de biblioteca ~S no está definida"

#: affi1.lsp:244
msgid "Bad number of arguments for ~S: ~S"
msgstr "El número de argumentos de ~S es incorrecto: ~S"

#: rexx1.lsp:146
msgid "No waiting for ~S possible."
msgstr "No se puede esperar por ~S."

#: defs3.lsp:231
#, fuzzy
msgid "~S: argument ~S should be a string or a symbol"
msgstr "~: el argumento ~ debe ser una cadena o un símbolo"

#~ msgid "stack overflow during bignum arithmetic"
#~ msgstr "desbordamiento de la pila durante la realización de operaciones aritméticas con números grandes"

#~ msgid "graphics not initialized"
#~ msgstr "los gráficos no han sido inicializados"

#~ msgid "~: cannot switch to graphics mode"
#~ msgstr "~: no es posible conmutar al modo gráfico"

#~ msgid "~%Description of~%"
#~ msgstr "~%Descripción de~%"

# Duda: ¡Atención! "This is" se debería traducir por "Este es" o "Esta
# es". Desgraciadamente, cuando se escribe este mensaje (que es el
# principio de una frase más larga) no se dispone de ninguna variable
# cuyo contenido se pueda examinar para comprobar si se debe usar el
# masculino o el femenino. Sin embargo, "Se trata de" queda al pelo.
#
# Para que lo veais, a continuación muestro dos sesiones diferentes
# donde "Se trata de" queda que ni pintado, ... (sin embargo, sustituid
# mentalmente por "Este es" o "Esta es" y vereis que el primer caso,
# necesariamente debería ser masculino y el segundo femenino):
#
# > (describe 'a)
#
# Descripción de
# A
# Se trata de el símbolo A.
# El símbolo está en el #<PACKAGE USER> y es accesible desde el paquete USER.
#
# > (describe '(a b c))
#
# Descripción de
# (A B C)
# Se trata de una lista de longitud 3.
#
#~ msgid "~%This is "
#~ msgstr "~%Se trata de "

#~ msgid "a function"
#~ msgstr "una función"

#~ msgid "~%The symbol "
#~ msgstr "~%El símbolo "

# Duda: pipe, todo el mundo sabe lo que es un pipe. Más aún, todo el mundo
#       conoce el mensaje `broken pipe'. Para no guiar a confusiones considero
#       que, excepcionalmente, se debe añadir la palabra pipe entre paréntesis,
#       con la intención de recordar al usuario lo que se quiere decir con
#       Tubería, ...
#
# Si en los cursillos de Unix se enseñara a los niños que esto | 
# es una tubería, no tendríamos que andar haciendo estas tonterías.
# Voto por eliminarlas de una vez por todas.
# "Tubería rota". sv
#
# Precisamente en estos días se discute esto mismo en la lista es@li.org
# (todavía no he enviado mi mensaje con mi opinión, pero lo haré,
# ...). La verdad es que creo que tienes razón. Sin ser exagerados y
# "eliminar de una vez por todas", creo que, en este caso, hay que
# arriesgarse y tirar p'alante, ¿no? ¡¡pues eso!! ¡¡¡"Tuberías rotas" al
# poder!!! - cll
#
#~ msgid "Broken pipe"
#~ msgstr "Tubería rota"

#~ msgid "character ~ is not a string-char, cannot be output onto ~"
#~ msgstr "el carácter ~ no es del tipo STRING-CHAR, y por ello no puede escribirse en ~"

#~ msgid "~: argument should be a string-char, not ~"
#~ msgstr "~: el argumento debe ser del tipo STRING-CHAR, no ~"

#~ msgid "~: ~ is not a string-char"
#~ msgstr "~: ~ no es un STRING-CHAR"

# Duda: uufff!!! Keypad, keypad, ..., ¿Teclado auxiliar?
#
# A continuacion reproduzco la pregunta que formule en la lista de CLisp:
#
# > 2. When does the message "Keypad-" appear?. The Keypad is the set of
# > numeric keys that are at the left of the keyboard. But I need to know
# > with which kind of messages does it join to know how to translate it.
#
# Y la respuesta de Bruno Haible:
#
# In phrases like "Please press Keypad-Enter when done".
#
# Francamente, me parece que la utilizacion de Keypad, a secas, será lo
# mejor.
#
#
#~ msgid "Keypad-"
#~ msgstr "Keypad-"

#~ msgid " with additional bits"
#~ msgstr " con bits adicionales"

#~ msgid " from font ~S"
#~ msgstr " de la fuente ~S"

#~ msgid "cursor up"
#~ msgstr "cursor arriba"

#~ msgid "cursor down"
#~ msgstr "cursor abajo"

#~ msgid "cursor left"
#~ msgstr "cursor a la izquierda"

#~ msgid "cursor right"
#~ msgstr "cursor a la derecha"

#~ msgid "cursor to start of line"
#~ msgstr "cursor al principio de línea"

#~ msgid "cursor to end of line"
#~ msgstr "cursor al final de la línea"

#~ msgid "cursor to start of text"
#~ msgstr "cursor al principio del texto"

#~ msgid "cursor to end of text"
#~ msgstr "cursor al final del texto"

#~ msgid "page up"
#~ msgstr "retroceso de página"

#~ msgid "page down"
#~ msgstr "avance de página"

#~ msgid "line up"
#~ msgstr "retroceder una línea"

#~ msgid "line down"
#~ msgstr "avanzar una línea"

#~ msgid "set mark ~D"
#~ msgstr "poner la marca ~D"

#~ msgid "cursor to mark ~D"
#~ msgstr "mover el cursor a la marca ~D"

#~ msgid "delete character at cursor"
#~ msgstr "borrar el carácter bajo el cursor"

#~ msgid "combine two lines"
#~ msgstr "juntar dos líneas"

#~ msgid "delete character at cursor, across lines"
#~ msgstr "borrar el carácter bajo el cursor, a través de varias líneas"

#~ msgid "delete character before cursor"
#~ msgstr "borrar el carácter antes del cursor"

#~ msgid "delete character before cursor, across lines"
#~ msgstr "borrar el carácter antes del cursor, a través de varias líneas"

#~ msgid "delete line"
#~ msgstr "borrar una línea"

#~ msgid "delete part of line left to the cursor"
#~ msgstr "borrar la línea hasta donde está el cursor"

#~ msgid "delete up to end of line"
#~ msgstr "borrar hasta el final de la línea"

#~ msgid "begin new line at cursor"
#~ msgstr "comenzar una nueva línea en la posición del cursor"

#~ msgid "cursor to start of block"
#~ msgstr "mover el cursor al comienzo del bloque"

#~ msgid "cursor to end of block"
#~ msgstr "mover el cursor al final del bloque"

#~ msgid "set block start"
#~ msgstr "establecer el comienzo de un bloque"

#~ msgid "set block end"
#~ msgstr "establecer el final de un bloque"

#~ msgid "remove block marks"
#~ msgstr "desechar las marcas del bloque"

#~ msgid "delete block"
#~ msgstr "borrar un bloque"

#~ msgid "move block to cursor position"
#~ msgstr "mover el bloque a la posición del cursor"

#~ msgid "copy block to cursor position"
#~ msgstr "copiar un bloque a la posición del cursor"

#~ msgid "copy block into cut-and-paste buffer"
#~ msgstr "copiar un bloque en el buffer de cortar-y-pegar"

#~ msgid "yank block into cut-and-paste buffer"
#~ msgstr "insertar un bloque en el buffer de cortar-y-pegar"

#~ msgid "insert cut-and-paste buffer contents"
#~ msgstr "inserta los contenidos del buffer cortar-y-pegar"

#~ msgid " Key bindings "
#~ msgstr " Asociaciones de teclado "

#~ msgid "                           K E Y   B I N D I N G S"
#~ msgstr "                 A S O C I A C I O N E S   D E   T E C L A D O"

#~ msgid " File to load: "
#~ msgstr " Lectura del fichero: "

#~ msgid " Save as: "
#~ msgstr " Salvar como: "

#~ msgid "evaluate block contents"
#~ msgstr "evaluar los contenidos del bloque"

#~ msgid "skip whitespace right"
#~ msgstr "ignorar los espacios en blanco a la derecha"

#~ msgid "~S from ~S: |# is legal only after #|"
#~ msgstr "~ en ~: |# es legal solo después de #|"

#~ msgid "mark next Lisp object"
#~ msgstr "marcar el siguiente objeto Lisp"

#
# Duda: `surrounding' por `circundante'
#
# ¿ Qué os parece ?
#
#~ msgid "mark surrounding top level form"
#~ msgstr "marcar la forma circundante"

#
# Duda: `surrounding' por `circundante'
#
# ¿ Qué os parece ?
#
#~ msgid "evaluate surrounding top level form"
#~ msgstr "evaluar la forma circundante"

#~ msgid "insert spaces up to next tab stop"
#~ msgstr "insertar espacios hasta la siguiente marca de tabulación"

#~ msgid "search for a string"
#~ msgstr "buscar una cadena de caracteres"

#~ msgid " Search: "
#~ msgstr " Buscar: "

#~ msgid "continue searching"
#~ msgstr "continuar la búsqueda"

#~ msgid "show window ~D"
#~ msgstr "mostrar la ventana ~D"

#~ msgid "hide window ~D"
#~ msgstr "ocultar la ventana ~D"

#~ msgid "show help window (this text)"
#~ msgstr "muestra la ventana de ayuda (este texto) "

#~ msgid "show error window"
#~ msgstr "mostrar la ventana de error"

#~ msgid "show trace window"
#~ msgstr "mostrar la ventana de rastreo"

#~ msgid "delete current window"
#~ msgstr "borrar la ventana actual"

#~ msgid "load file"
#~ msgstr "cargar el fichero \""

#~ msgid "store to file"
#~ msgstr "almacenar en el fichero"

#~ msgid "store to new file"
#~ msgstr "almacenar en un fichero nuevo"

#~ msgid "quit editor"
#~ msgstr "salir del editor"

#~ msgid "hide top window"
#~ msgstr "ocultar la ventana superior"
