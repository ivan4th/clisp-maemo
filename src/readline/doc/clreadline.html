<HEAD>
<TITLE> CLISP-READLINE manual page </TITLE>
</HEAD>
<BODY>
<H1>CLISP-READLINE manual page</H1>

<UL>
<LI> <A HREF="#Name">Name</A>
<LI> <A HREF="#Notation">Notation</A>
<LI> <A HREF="#Initialization File">Initialization File</A>
     <UL>
     <LI> <A HREF="#Key Bindings">Key Bindings</A>
     <LI> <A HREF="#Variables">Variables</A>
     <LI> <A HREF="#Conditional Constructs">Conditional Constructs</A>
     </UL>
<LI> <A HREF="#Searching">Searching</A>
<LI> <A HREF="#Editing Commands">Editing Commands</A>
     <UL>
     <LI> <A HREF="#Commands for Moving">Commands for Moving</A>
     <LI> <A HREF="#Commands for Manipulating the History">Commands for Manipulating the History</A>
     <LI> <A HREF="#Commands for Changing Text">Commands for Changing Text</A>
     <LI> <A HREF="#Killing and Yanking">Killing and Yanking</A>
     <LI> <A HREF="#Numeric Arguments">Numeric Arguments</A>
     <LI> <A HREF="#Completing">Completing</A>
     <LI> <A HREF="#Keyboard Macros">Keyboard Macros</A>
     <LI> <A HREF="#Miscellaneous">Miscellaneous</A>
     </UL>
<LI> <A HREF="#Default Key Bindings">Default Key Bindings</A>
     <UL>
     <LI> <A HREF="#Key Bindings in Emacs Mode">Emacs Mode</A>
     <LI> <A HREF="#Key Bindings in VI Mode">VI Mode bindings</A>
     </UL>
<LI> <A HREF="#See also">See also</A>
<LI> <A HREF="#Files">Files</A>
<LI> <A HREF="#Authors">Authors</A>
<LI> <A HREF="#Bug Reports">Bug Reports</A>
<LI> <A HREF="#Bugs">Bugs</A>
</UL>
<P>

<HR>

<H2><A NAME="Name">Name</A></H2>

readline - get a line from a user with editing

<H2><A NAME="Notation">Notation</A></H2>

An  emacs-style  notation  is  used  to denote keystrokes.
Control keys are denoted by <SAMP>C-</SAMP><VAR>key</VAR>,
e.g.,  <SAMP>C-n</SAMP>  means  Control-<KBD>N</KBD>.  Similarly, <i>meta</i>
keys are denoted by <SAMP>M-</SAMP><VAR>key</VAR> , so <SAMP>M-x</SAMP>
means Meta-<KBD>X</KBD>.  (On keyboards without a <i>meta</i>
 key, <SAMP>M-</SAMP><VAR>x</VAR>
 means ESC <VAR>x</VAR> ,  i.e.,  press the Escape key then the <VAR>x</VAR>
 key.  This
makes ESC the <i>meta prefix</i>.  The  combination  <SAMP>M-C-</SAMP><VAR>x</VAR>
  means ESC-Control-<VAR>x</VAR> ,  or press the Escape key then hold the Control key while pressing the <i>x</i>
 key.)
<P>

Readline commands may be given  numeric  <i>arguments</i>,  which
normally act as a repeat count.  Sometimes, however, it is
the sign of the argument that is significant.   Passing  a
negative  argument  to  a command that acts in the forward
direction (e.g., <A HREF="#kill-line"><CODE>kill-line</CODE></A>) causes that command to act  in
a  backward direction.  Commands whose behavior with arguments deviates from this are noted.
<P>

When a command is described  as  <i>killing</i> text,  the  text
deleted  is saved for possible future retrieval (<i>yanking</i>).
The killed text is  saved  in  a  <i>kill ring</i>.   Consecutive
kills  cause  the  text  to  be accumulated into one unit,
which can be yanked all at once.  Commands  which  do  not
kill text separate the chunks of text on the kill ring.

<H2><A NAME="Initialization File">Initialization File</A></H2>

Readline  is customized by putting commands in an initialization
file (the <A HREF="#~/.inputrc"><I>inputrc</I></A> file).
The name of this file  is  taken  from  the
value of the <CODE>INPUTRC</CODE> environment variable.
If that variable is unset, the default is <A HREF="#~/.inputrc"><CODE>~/.inputrc</CODE></A>.
When a program which uses the
readline library starts up, the init file is read, and the
key bindings and variables are set.  There are only a  few
basic constructs allowed in the readline init file.  Blank
lines are ignored.  Lines beginning with a <CODE>#</CODE> are comments.
Lines  beginning with a <CODE>$</CODE> indicate conditional constructs.
Other lines denote key  bindings  and  variable  settings.
Each  program  using this library may add its own commands
and bindings.
<P>

For example, placing
<BLOCKQUOTE>
<CODE>M-Control-u: universal-argument</CODE>
</BLOCKQUOTE>
or
<BLOCKQUOTE>
<CODE>C-Meta-u: universal-argument</CODE>
</BLOCKQUOTE>
into the <A HREF="#~/.inputrc"><I>inputrc</I></A> would make <SAMP>M-C-u</SAMP> execute the  readline
command <A HREF="#universal-argument"><CODE>universal-argument</CODE></A>.
<P>

The  following  symbolic  character  names  are recognized
while processing key bindings:
<CODE>RUBOUT</CODE>, <CODE>DEL</CODE>, <CODE>ESC</CODE>, <CODE>LFD</CODE>,
<CODE>NEWLINE</CODE>,  <CODE>RET</CODE>,  <CODE>RETURN</CODE>,  <CODE>SPC</CODE>,
<CODE>SPACE</CODE>, and <CODE>TAB</CODE>.
<P>

In addition to command names, readline allows  keys  to  be
bound  to  a string that is inserted when the key is pressed
(a <i>macro</i>).
<P>

<H3><A NAME="Key Bindings">Key Bindings</A></H3>

The syntax for controlling key bindings in the  <A HREF="#~/.inputrc"><I>inputrc</I></A>
file  is  simple.  All that is required is the name of the
command or the text of a macro and a key sequence to which
it  should  be  bound. The name may be specified in one of
two ways: as a symbolic key name, possibly with  <CODE>Meta-</CODE> or
<CODE>Control-</CODE> prefixes,  or as a key sequence.  When using the
form
<BLOCKQUOTE>
<VAR>keyname</VAR><CODE>:</CODE> <VAR>function-name</VAR> or <VAR>macro</VAR>
</BLOCKQUOTE>
<VAR>keyname</VAR> is  the  name
of a key spelled out in English.  For example:
<BLOCKQUOTE>
<PRE><CODE>Control-u: universal-argument
Meta-Rubout: backward-kill-word
Control-o: "&gt;&amp;output"
</CODE></PRE>
</BLOCKQUOTE>
In the above example, <SAMP>C-u</SAMP>
 is bound to the function <A HREF="#universal-argument"><CODE>universal-argument</CODE></A>,  <SAMP>M-DEL</SAMP>
  is  bound  to  the  function   <A HREF="#backward-kill-word"><CODE>backward-kill-word</CODE></A>,   and  <SAMP>C-o</SAMP>
  is  bound  to  run  the  macro
expressed on the right hand side (that is, to  insert  the
text <SAMP>>&amp;output</SAMP>
 into the line).
<P>

In  the second form,
<BLOCKQUOTE>
<CODE>"</CODE><VAR>keyseq</VAR><CODE>":</CODE><VAR>function-name</VAR>
 or <VAR>macro</VAR>
</BLOCKQUOTE>
<VAR>keyseq</VAR> differs from <VAR>keyname</VAR> above in that strings denoting an
entire  key  sequence  may  be  specified  by  placing the
sequence within double quotes.  Some GNU Emacs  style  key
escapes can be used, as in the following example.
<BLOCKQUOTE>
<PRE><CODE>"\C-u": universal-argument
"\C-x\C-r": re-read-init-file
"\e[11~": "Function Key 1"
</CODE></PRE>
</BLOCKQUOTE>
In  this  example, <SAMP>C-u</SAMP>
 is again bound to the function <A HREF="#universal-argument"><CODE>universal-argument</CODE></A>.   <SAMP>C-x C-r</SAMP>
  is  bound  to  the   function <A HREF="#re-read-init-file"><CODE>re-read-init-file</CODE></A>,  and <SAMP>ESC [ 1 1 ~</SAMP>
 is bound to insert the
text <TT>Function Key 1</TT>.  The full set of GNU Emacs style escape sequences is
<DL>
<DT><CODE>\C-</CODE> <DD>control prefix
<DT><CODE>\M-</CODE> <DD>meta prefix
<DT><CODE>\e </CODE> <DD>an escape character
<DT><CODE>\\ </CODE> <DD>backslash
<DT><CODE>\" </CODE> <DD>literal "
<DT><CODE>\' </CODE> <DD>literal '
</DL>
In addition to the GNU Emacs style escape sequences, a
second set of backslash escapes is available:
<DL>
<DT><CODE>\a</CODE> <DD>alert (bell)
<DT><CODE>\b</CODE> <DD>backspace
<DT><CODE>\d</CODE> <DD>delete
<DT><CODE>\f</CODE> <DD>form feed
<DT><CODE>\n</CODE> <DD>newline
<DT><CODE>\r</CODE> <DD>carriage return
<DT><CODE>\t</CODE> <DD>horizontal tab
<DT><CODE>\v</CODE> <DD>vertical tab
<DT><CODE>\<VAR>nnn</VAR></CODE> <DD>the character whose ASCII code is the  octal
                                     value <VAR>nnn</VAR> (one to three digits)
<DT><CODE>\x<VAR>nnn</VAR></CODE> <DD>the  character  whose ASCII code is the
                                      hexadecimal value <VAR>nnn</VAR> (one to three digits)
</DL>
When entering the text of a macro, single or double quotes
should  be  used to indicate a macro definition.  Unquoted
text is assumed to be a  function  name.   In the macro body,
the backslash escapes described above are expanded.  Backslash
will quote any other character in  the  macro  text,
including " and '.
<P>
<CODE><B>Bash</B></CODE> allows the current readline key bindings to  be  displayed
  or  modified  with  the <CODE>bind</CODE> builtin command.  The
editing mode may be switched  during  interactive  use  by
using  the  <CODE>-o</CODE>  option  to the <CODE>set</CODE> builtin command.  Other
programs using this library  provide  similar  mechanisms.
The  <A HREF="#~/.inputrc"><I>inputrc</I></A> file  may be edited and re-read if a program
does not provide any other means to incorporate new  bindings.

<H3><A NAME="Variables">Variables</A></H3>

Readline  has  variables  that can be used to further customize its
behavior.  A variable may be set in the <A HREF="#~/.inputrc"><I>inputrc</I></A>
file with a statement of the form
<BLOCKQUOTE>
<CODE>set</CODE> <VAR>variable-name</VAR> <VAR>value</VAR>
</BLOCKQUOTE>
<P>

Except where noted, readline variables can take the values
<CODE>On</CODE> or <CODE>Off</CODE>.
The variables and their default values are:
<DL>
<DT> <A NAME="bell-style"><CODE>bell-style</CODE></A> (<CODE>audible</CODE>)
<DD> Controls what happens when readline wants  to  ring
the  terminal bell.  If set to <CODE>none</CODE>, readline never
rings the bell.  If set to <CODE>visible</CODE>, readline uses a
visible  bell if one is available.  If set to <CODE>audible</CODE>,
readline attempts to ring the terminal's bell.
<DT> <A NAME="comment-begin"><CODE>comment-begin</CODE></A> (``<CODE>;</CODE>'')
<DD> The  string  that  is  inserted in vi mode when the
<A HREF="#insert-comment"><CODE>insert-comment</CODE></A> command is executed.  This command
is bound to <CODE>M-#</CODE> in emacs mode and to <CODE>#</CODE> in vi command mode.
<DT> <A NAME="completion-ignore-case"><CODE>completion-ignore-case</CODE></A> (<CODE>Off</CODE>)
<DD> If  set  to <CODE>On</CODE>, readline performs filename matching
and completion in a case-insensitive fashion.
<DT> <A NAME="blink-matching-paren"><CODE>blink-matching-paren</CODE></A> (<CODE>On</CODE>)
<DD> If set to <CODE>On</CODE>, readline will display the corresponding opening parenthesis when a closing  parenthesis
is typed.
<DT> <A NAME="completion-query-items"><CODE>completion-query-items</CODE></A> (<CODE>100</CODE>)
<DD> This  determines  when  the  user  is queried about
viewing the number of possible  completions  generated  by
the <A HREF="#possible-completions"><CODE>possible-completions</CODE></A> command.  It may
be set to any integer value greater than  or  equal
to  zero.  If the number of possible completions is
greater than or equal to the value  of  this  variable, the
user is asked whether or not he wishes to
view them; otherwise they are simply listed on  the
terminal.
<DT> <A NAME="disable-completion"><CODE>disable-completion</CODE></A> (<CODE>Off</CODE>)
<DD> If set to On, readline will  inhibit  word  completion.
Completion characters will be inserted into
the line as if they had been mapped to <CODE>self-insert</CODE>.
<DT> <A NAME="editing-mode"><CODE>editing-mode</CODE></A> (<CODE>emacs</CODE>)
<DD> Controls  whether readline begins with a set of key
bindings similar to <CODE><B>emacs</B></CODE> or <CODE><B>vi</B></CODE>.
<A HREF="#editing-mode"><CODE>editing-mode</CODE></A> can
be set to either <CODE>emacs</CODE> or <CODE>vi</CODE>.
<DT> <A NAME="enable-keypad"><CODE>enable-keypad</CODE></A> (<CODE>Off</CODE>)
<DD> When  set  to  <CODE>On</CODE>,  readline will try to enable the
application keypad when it is called.  Some systems
need this to enable the arrow keys.
<DT> <A NAME="expand-tilde"><CODE>expand-tilde</CODE></A> (<CODE>Off</CODE>)
<DD>If  set  to  <CODE>on</CODE>,  tilde expansion is performed when
readline attempts word completion.
<DT> <A NAME="horizontal-scroll-mode"><CODE>horizontal-scroll-mode</CODE></A> (<CODE>Off</CODE>)
<DD> When set to <CODE>On</CODE>, makes readline use  a  single  line
for  display, scrolling the input horizontally on a
single screen line when it becomes longer than  the
screen width rather than wrapping to a new line.
<DT> <A NAME="keymap"><CODE>keymap</CODE></A> (<CODE>emacs</CODE>)
<DD> Set  the current readline keymap.  The set of legal
keymap names is <CODE>emacs</CODE>, <CODE>emacs-standard</CODE>,  <CODE>emacs-meta</CODE>,
<CODE>emacs-ctlx</CODE>, <CODE>vi</CODE>, <CODE>vi-move</CODE>, <CODE>vi-command</CODE>,
and <CODE>vi-insert</CODE>.  <CODE>vi</CODE> is equivalent to <CODE>vi-command</CODE>;
<CODE>emacs</CODE> is equivalent
to <CODE>emacs-standard</CODE>.  The default value is <CODE>emacs</CODE>; the
value of  <A HREF="#editing-mode"><CODE>editing-mode</CODE></A>  also  affects  the  default
keymap.
<DT> <A NAME="mark-directories"><CODE>mark-directories</CODE></A> (<CODE>On</CODE>)
<DD>If  set  to  <CODE>On</CODE>,  completed directory names have a
slash appended.
<DT> <A NAME="mark-modified-lines"><CODE>mark-modified-lines</CODE></A> (<CODE>Off</CODE>)
<DD> If set to <CODE>On</CODE>, history lines that have been modified
are displayed with a preceding asterisk (<CODE>*</CODE>).
<DT> <A NAME="convert-meta"><CODE>convert-meta</CODE></A> (<CODE>On</CODE>)
<DD> If set to <CODE>On</CODE>, readline will convert characters with
the eighth bit set to  an  ASCII  key  sequence  by
stripping  the  eighth bit and prepending an escape
character (in effect,  using  escape  as  the  <i>meta prefix</i>).
<DT> <A NAME="meta-flag"><CODE>meta-flag</CODE></A> (<CODE>Off</CODE>)
<DD> If set to <CODE>On</CODE>, readline will enable eight-bit  input
(that  is,  it will not strip the high bit from the
characters it reads), regardless of what the terminal claims it can support.
<DT> <A NAME="output-meta"><CODE>output-meta</CODE></A> (<CODE>Off</CODE>)
<DD> If set to <CODE>On</CODE>, readline will display characters with
the eighth bit set directly rather than as a  meta-
prefixed escape sequence.
<DT> <A NAME="print-completions-horizontally"><CODE>print-completions-horizontally</CODE></A> (<CODE>Off</CODE>)
<DD> If set to <CODE>On</CODE>,  readline  will  display  completions
with  matches  sorted  horizontally in alphabetical
order, rather than down the screen.
<DT> <A NAME="show-all-if-ambiguous"><CODE>show-all-if-ambiguous</CODE></A> (<CODE>Off</CODE>)
<DD> This  alters the default behavior of the completion
functions.  If set to <CODE>on</CODE>,  words  which  have  more
than  one  possible completion cause the matches to
be listed immediately instead of ringing the  bell.
<DT> <A NAME="visible-stats"><CODE>visible-stats</CODE></A> (<CODE>Off</CODE>)
<DD> If set to <CODE>On</CODE>, a character denoting a file's type as
reported  by  <CODE>stat</CODE>(2)  is  appended to the filename
when listing possible completions.
</DL>

<H3><A NAME="Conditional Constructs">Conditional Constructs</A></H3>

Readline implements a facility similar in  spirit  to  the
conditional  compilation  features  of  the C preprocessor
which allows key bindings and variable settings to be performed
as  the  result  of tests.  There are four parser
directives used.

<DL>

<DT> <A NAME="$if"><CODE>$if</CODE></A>
<DD> The <A HREF="#$if"><CODE>$if</CODE></A> construct allows bindings to be made  based
on  the  editing  mode, the terminal being used, or
the application using readline.  The  text  of  the
test  extends to the end of the line; no characters
are required to isolate it.
<DL>
<DT> <A NAME="mode"><CODE>mode</CODE></A>
<DD> The <CODE>mode=</CODE> form of the <A HREF="#$if"><CODE>$if</CODE></A> directive is  used
to  test  whether readline is in <CODE>emacs</CODE> or <CODE>vi</CODE>
mode.  This may be used in conjunction  with
the <CODE>set keymap</CODE> command, for instance, to set
bindings in the  <CODE>emacs-standard</CODE>
and  <CODE>emacs-ctlx</CODE> keymaps  only  if readline is starting
out in <CODE>emacs</CODE> mode.
<DT> <A NAME="term"><CODE>term</CODE></A>
<DD> The  <CODE>term=</CODE>  form  may  be  used  to  include
terminal-specific  key  bindings, perhaps to
bind the key sequences output by the  terminal's
function keys.  The word on the right
side of the <CODE>=</CODE> is  tested  against  the  full
name  of the terminal and the portion of the
terminal name  before  the  first  <CODE>-</CODE>.   This
allows  <CODE>sun</CODE> to  match both <CODE>sun</CODE>
and <CODE>sun-cmd</CODE>,
for instance.
<DT> <A NAME="application"><CODE>application</CODE></A>
<DD> The <A HREF="#application"><CODE>application</CODE></A> construct is used to include
application-specific settings.  Each program
using the readline library sets the <i>application name</i>,
and  an initialization file can
test for a particular value.  This could  be
used to bind key sequences to functions useful
for a specific program.   For  instance,
the  following  command  adds a key sequence
that quotes the current or previous word  in
Bash:
<BLOCKQUOTE>
<PRE><CODE><B>$if</B> bash
# Quote the current or previous word
"\C-xq": "\eb\"\ef\""
<B>$endif</B>
</CODE></PRE>
</BLOCKQUOTE>
</DL>

<DT> <A NAME="$endif"><CODE>$endif</CODE></A>
<DD> This  command,  as seen in the previous example,
terminates an <A HREF="#$if"><CODE>$if</CODE></A> command.

<DT> <A NAME="$else"><CODE>$else</CODE></A>
<DD> Commands in this branch of the  <A HREF="#$if"><CODE>$if</CODE></A>  directive  are
executed if the test fails.

<DT> <A NAME="$include"><CODE>$include</CODE></A>
<DD> This directive takes a single filename as an  argument
and  reads  commands  and  bindings from that
file.  For example, the following  directive  would
read <CODE>/etc/inputrc</CODE>:

<PRE><CODE><B>$include</B> /etc/inputrc
</CODE></PRE>

</DL>

<H2><A NAME="Searching">Searching</A></H2>

Readline  provides commands for searching through the command
history for  lines  containing  a  specified  string.
There  are two search modes: <I>incremental</I> and <I>non-incremental</I>.
<P>
Incremental searches begin before the  user  has  finished
typing the search string.  As each character of the search
string is typed, readline displays the next entry from the
history  matching the string typed so far.  An incremental
search requires only as many characters as needed to  find
the  desired  history entry.  The Escape character is used
to terminate an incremental search.  Control-J  will  also
terminate the search.  Control-G will abort an incremental
search and restore the original line.  When the search  is
terminated, the history entry containing the search string
becomes the current line.  To find other matching  entries
in the history list, type Control-S or Control-R as appropriate.
This will search backward or forward in the  history
for the next line matching the search string typed so
far.  Any other key sequence bound to a  readline  command
will  terminate  the search and execute that command.  For
instance, a newline will terminate the search  and  accept
the  line,  thereby executing the command from the history
list.
<P>
Non-incremental searches read  the  entire  search  string
before starting to search for matching history lines.  The
search string may be typed by the user or be part  of  the
contents of the current line.

<H2><A NAME="Editing Commands">Editing Commands</A></H2>

The  following  is a list of the names of the commands and
the default key sequences to which they are bound.   Command
names  without  an  accompanying  key  sequence  are
unbound by default.

<H3><A NAME="Commands for Moving">Commands for Moving</A></H3>

<DL>
<DT> <A NAME="beginning-of-line"><CODE>beginning-of-line</CODE></A> (<SAMP>C-a</SAMP>)
<DD> Move to the start of the current line.
<DT> <A NAME="end-of-line"><CODE>end-of-line</CODE></A> (<SAMP>C-e</SAMP>)
<DD> Move to the end of the line.
<DT> <A NAME="forward-char"><CODE>forward-char</CODE></A> (<SAMP>C-f</SAMP>)
<DD> Move forward a character.
<DT> <A NAME="backward-char"><CODE>backward-char</CODE></A> (<SAMP>C-b</SAMP>)
<DD> Move back a character.
<DT> <A NAME="forward-word"><CODE>forward-word</CODE></A> (<SAMP>M-f</SAMP>)
<DD> Move forward to the end of the  next  word.   Words
are  composed  of  alphanumeric characters (letters
and digits).
<DT> <A NAME="backward-word"><CODE>backward-word</CODE></A> (<SAMP>M-b</SAMP>)
<DD> Move back to the start of the current or previous
word.   Words  are composed of alphanumeric characters (letters and digits).
<DT> <A NAME="clear-screen"><CODE>clear-screen</CODE></A> (<SAMP>C-l</SAMP>)
<DD> Clear the screen leaving the current  line  at  the
top  of  the screen.  With an argument, refresh the
current line without clearing the screen.
<DT> <A NAME="redraw-current-line"><CODE>redraw-current-line</CODE></A>
<DD> Refresh the current  line.
</DL>

<H3><A NAME="Commands for Manipulating the History">Commands for Manipulating the History</A></H3>

<DL>
<DT> <A NAME="accept-line"><CODE>accept-line</CODE></A> (<SAMP>Newline</SAMP>, <SAMP>Return</SAMP>)
<DD> Accept  the line regardless of where the cursor is.
If this line is non-empty, add it  to  the  history
list.  If the line is a modified history line, then
restore the history line to its original state.
<DT> <A NAME="previous-history"><CODE>previous-history</CODE></A> (<SAMP>C-p</SAMP>)
<DD> Fetch the previous command from the  history  list,
moving back in the list.
<DT> <A NAME="next-history"><CODE>next-history</CODE></A> (<SAMP>C-n</SAMP>)
<DD> Fetch  the next command from the history list, moving
forward in the list.
<DT> <A NAME="beginning-of-history"><CODE>beginning-of-history</CODE></A> (<SAMP>M-&lt;</SAMP>)
<DD> Move to the first line in the history.
<DT> <A NAME="end-of-history"><CODE>end-of-history</CODE></A> (<SAMP>M-&gt;</SAMP>)
<DD> Move to the end of the  input  history,  i.e.,  the
line currently being entered.
<DT> <A NAME="reverse-search-history"><CODE>reverse-search-history</CODE></A> (<SAMP>C-r</SAMP>)
<DD> Search  backward  starting  at the current line and
moving `up' through the history as necessary.  This
is an incremental search.
<DT> <A NAME="forward-search-history"><CODE>forward-search-history</CODE></A> (<SAMP>C-s</SAMP>)
<DD> Search  forward  starting  at  the current line and
moving `down' through  the  history  as  necessary.
This is an incremental search.
<DT> <A NAME="non-incremental-reverse-search-history"><CODE>non-incremental-reverse-search-history</CODE></A> (<SAMP>M-p</SAMP>)
<DD> Search backward through the history starting at the
current line using a non-incremental search  for  a
string supplied by the user.
<DT> <A NAME="non-incremental-forward-search-history"><CODE>non-incremental-forward-search-history</CODE></A> (<SAMP>M-n</SAMP>)
<DD> Search   forward   through   the  history  using  a
non-incremental search for a string supplied by the
user.
<DT> <A NAME="history-search-forward"><CODE>history-search-forward</CODE></A>
<DD> Search  forward  through the history for the string
of characters between the start of the current line
and the current cursor position (the <I>point</I>).   This
is a non-incremental search.
<DT> <A NAME="history-search-backward"><CODE>history-search-backward</CODE></A>
<DD> Search backward through the history for the  string
of characters between the start of the current line
and the point.  This is  a  non-incremental search.
<DT> <A NAME="yank-nth-arg"><CODE>yank-nth-arg</CODE></A> (<SAMP>M-C-y</SAMP>)
<DD> Insert  the  first argument to the previous command
(usually the second word on the previous  line)  at
point (the current cursor position).  With an argument <VAR>n</VAR>,
insert  the  <VAR>n</VAR> th  word  from  the  previous
command  (the  words  in the previous command begin
with word 0).  A negative argument inserts the  <VAR>n</VAR> th
word from the end of the previous command.
<DT> <A NAME="yank-last-arg"><CODE>yank-last-arg</CODE></A> (<SAMP>M-.</SAMP>, <SAMP>M-_</SAMP>)
<DD> Insert  the  last  argument to the previous command
(the last word  of  the  previous  history  entry).
With an argument, behave exactly like <CODE>yank-nth-arg</CODE>.
Successive calls to <A HREF="#yank-last-arg"><CODE>yank-last-arg</CODE></A> move back through
the  history  list,  inserting the last argument of
each line in turn.
</DL>

<H3><A NAME="Commands for Changing Text">Commands for Changing Text</A></H3>

<DL>
<DT> <A NAME="delete-char"><CODE>delete-char</CODE></A> (<SAMP>C-d</SAMP>)
<DD> Delete the character under the cursor.  If point is
at the beginning of the line, there are no  characters
in the line, and the last character typed was
not bound to <CODE>delete-char</CODE>, then return EOF.
<DT> <A NAME="backward-delete-char"><CODE>backward-delete-char</CODE></A> (<SAMP>Rubout</SAMP>)
<DD> Delete the character behind the cursor.  When given
a  numeric  argument,  save the deleted text on the
kill ring.
<DT> <A NAME="quoted-insert"><CODE>quoted-insert</CODE></A> (<SAMP>C-q</SAMP>, <SAMP>C-v</SAMP>)
<DD> Add the next character that you type  to  the  line
verbatim.   This  is  how to insert characters like
<SAMP>C-q</SAMP>, for example.
<DT> <A NAME="tab-insert"><CODE>tab-insert</CODE></A> (<SAMP>M-TAB</SAMP>)
<DD> Insert a tab character.
<DT> <A NAME="self-insert"><CODE>self-insert</CODE></A> (<SAMP>a</SAMP>, <SAMP>b</SAMP>, <SAMP>A</SAMP>, <SAMP>1</SAMP>, <SAMP>!</SAMP>, ...)
<DD> Insert the character typed.
<DT> <A NAME="transpose-chars"><CODE>transpose-chars</CODE></A> (<SAMP>C-t</SAMP>)
<DD> Drag the character before point  forward  over  the
character  at  point.  Point moves forward as well.
If point is at the end of the line, then  transpose
the  two  characters  before point.  Negative arguments don't work.
<DT> <A NAME="transpose-words"><CODE>transpose-words</CODE></A> (<SAMP>M-t</SAMP>)
<DD> Drag the word behind the cursor past  the  word  in
front  of  the  cursor  moving the cursor over that
word as well.
<DT> <A NAME="upcase-word"><CODE>upcase-word</CODE></A> (<SAMP>M-u</SAMP>)
<DD> Uppercase the current (or following) word.  With  a
negative argument, uppercase the previous word, but do not
move point.
<DT> <A NAME="downcase-word"><CODE>downcase-word</CODE></A> (<SAMP>M-l</SAMP>)
<DD> Lowercase the current (or following) word.  With  a
negative argument, lowercase the previous word, but do not
move point.
<DT> <A NAME="capitalize-word"><CODE>capitalize-word</CODE></A> (<SAMP>M-c</SAMP>)
<DD> Capitalize the current (or following) word.  With a
negative argument, capitalize the previous word, but do not
move point.
</DL>

<H3><A NAME="Killing and Yanking">Killing and Yanking</A></H3>

<DL>
<DT> <A NAME="kill-line"><CODE>kill-line</CODE></A> (<SAMP>C-k</SAMP>)
<DD> Kill the text from the current cursor  position  to
the end of the line.
<DT> <A NAME="backward-kill-line"><CODE>backward-kill-line</CODE></A> (<SAMP>C-x Rubout</SAMP>)
<DD> Kill backward to the beginning of the line.
<DT> <A NAME="unix-line-discard"><CODE>unix-line-discard</CODE></A> (<SAMP>C-u</SAMP>)
<DD> Kill  backward  from  point to the beginning of the
line. The killed text is saved on the kill-ring.
<DT> <A NAME="kill-whole-line"><CODE>kill-whole-line</CODE></A>
<DD> Kill all characters on the current line, no  matter
where  the cursor is.
<DT> <A NAME="kill-word"><CODE>kill-word</CODE></A> (<SAMP>M-d</SAMP>)
<DD> Kill from the cursor to  the  end  of  the  current
word,  or  if between words, to the end of the next
word.  Word boundaries are the same as  those  used
by <A HREF="#forward-word"><CODE>forward-word</CODE></A>.
<DT> <A NAME="backward-kill-word"><CODE>backward-kill-word</CODE></A> (<SAMP>M-Rubout</SAMP>)
<DD> Kill  the  word behind the cursor.  Word boundaries
are the same as those used by <A HREF="#backward-word"><CODE>backward-word</CODE></A>.
<DT> <A NAME="unix-word-rubout"><CODE>unix-word-rubout</CODE></A> (<SAMP>C-w</SAMP>)
<DD> Kill the word behind the cursor, using white  space
as  a  word boundary.  The word boundaries are different
from <A HREF="#backward-kill-word"><CODE>backward-kill-word</CODE></A>.
<DT> <A NAME="delete-horizontal-space"><CODE>delete-horizontal-space</CODE></A> (<SAMP>M-\</SAMP>)
<DD> Delete all spaces and tabs around point.
<DT> <A NAME="kill-region"><CODE>kill-region</CODE></A>
<DD> Kill the text between the  point  and  <I>mark</I>  (saved
cursor  position).  This text is referred to as the
<I>region</I>.
<DT> <A NAME="copy-region-as-kill"><CODE>copy-region-as-kill</CODE></A>
<DD> Copy the text in the region to the kill buffer.
<DT> <A NAME="copy-backward-word"><CODE>copy-backward-word</CODE></A>
<DD> Copy the word before point to the kill buffer.  The
word boundaries are the same as <A HREF="#backward-word"><CODE>backward-word</CODE></A>.
<DT> <A NAME="copy-forward-word"><CODE>copy-forward-word</CODE></A>
<DD> Copy  the  word following point to the kill buffer.
The word boundaries are the same as <A HREF="#forward-word"><CODE>forward-word</CODE></A>.
<DT> <A NAME="yank"><CODE>yank</CODE></A> (<SAMP>C-y</SAMP>)
<DD> Yank  the  top  of the kill ring into the buffer at
the cursor.
<DT> <A NAME="yank-pop"><CODE>yank-pop</CODE></A> (<SAMP>M-y</SAMP>)
<DD> Rotate the kill ring, and yank the new  top.   Only
works following <A HREF="#yank"><CODE>yank</CODE></A> or <A HREF="#yank-pop"><CODE>yank-pop</CODE></A>.
</DL>

<H3><A NAME="Numeric Arguments">Numeric Arguments</A></H3>

<DL>
<DT> <A NAME="digit-argument"><CODE>digit-argument</CODE></A> (<SAMP>M-0</SAMP>, <SAMP>M-1</SAMP>, ..., <SAMP>M--</SAMP>)
<DD> Add  this  digit to the argument already accumulating,
or start a new argument.  <SAMP>M--</SAMP>  starts  a  negative
argument.
<DT> <A NAME="universal-argument"><CODE>universal-argument</CODE></A>
<DD> This is another way to  specify  an  argument.   If
this  command  is  followed  by one or more digits,
optionally with a leading minus sign, those  digits
define the argument.  If the command is followed by
digits, executing <A HREF="#universal-argument"><CODE>universal-argument</CODE></A> again ends the
numeric  argument,  but is otherwise ignored.  As a
special case, if this command is  immediately  fol-
lowed  by  a  character  that is neither a digit or
minus sign, the argument count for the next command
is  multiplied by four.  The argument count is initially
one, so executing this  function  the  first
time  makes  the argument count four, a second time
makes the argument count sixteen, and so on.
</DL>

<H3><A NAME="Completing">Completing</A></H3>

<DL>
<DT> <A NAME="complete"><CODE>complete</CODE></A> (<SAMP>TAB</SAMP>)
<DD> Attempt  to  perform  completion on the text before
point.  The actual completion performed is application-specific.
<A HREF="clisp.html"><CODE><B>Clisp</B></CODE></A>, for instance, attempts completion
of symbol names, of function names (if  the
text  is  prefixed  by <CODE>(</CODE> or <CODE>#'</CODE>) or of filenames (if
the text is prefixed by <CODE>#"</CODE>).  <CODE><B>Bash</B></CODE>,  on  the  other
hand,  attempts  completion  treating the text as a
variable (if the text begins with <CODE>$</CODE>), username  (if
the  text  begins  with  <CODE>~</CODE>),  hostname (if the text
begins with <CODE>@</CODE>), or command (including  aliases  and
functions)  in  turn.   If none of these produces a
match,  filename  completion  is  attempted.   <CODE><B>Gdb</B></CODE>,
finally, allows completion of program functions and
variables, and only  attempts  filename  completion
under certain circumstances.
<DT> <A NAME="possible-completions"><CODE>possible-completions</CODE></A> (<SAMP>M-?</SAMP>)
<DD> List  the  possible  completions of the text before
point.
<DT> <A NAME="insert-completions"><CODE>insert-completions</CODE></A> (<SAMP>M-*</SAMP>)
<DD> Insert all completions of  the  text  before  point
that   would   have   been   generated   by  <A HREF="#possible-completions"><CODE>possible-completions</CODE></A>.
<DT> <A NAME="menu-complete"><CODE>menu-complete</CODE></A>
<DD>Similar  to  <A HREF="#complete"><CODE>complete</CODE></A>,  but replaces the word to be
completed with a single match from the list of pos-
sible completions.  Repeated execution of <A HREF="#menu-complete"><CODE>menu-complete</CODE></A>
steps through the list  of  possible  comple-
tions, inserting each match in turn.  At the end of
the list of completions, the bell is rung  and  the
original  text is restored.  An argument of <VAR>n</VAR> moves
<VAR>n</VAR> positions forward in the list of matches; a nega-
tive  argument may be used to move backward through
the list.  This command is intended to be bound  to
<CODE>TAB</CODE>, but is unbound by default.
</DL>

<H3><A NAME="Keyboard Macros">Keyboard Macros</A></H3>

<DL>
<DT> <A NAME="start-kbd-macro"><CODE>start-kbd-macro</CODE></A> (<SAMP>C-x (</SAMP>)
<DD> Begin  saving the characters typed into the current
keyboard macro.
<DT> <A NAME="end-kbd-macro"><CODE>end-kbd-macro</CODE></A> (<SAMP>C-x )</SAMP>)
<DD> Stop saving the characters typed into  the  current
keyboard macro and store the definition.
<DT> <A NAME="call-last-kbd-macro"><CODE>call-last-kbd-macro</CODE></A> (<SAMP>C-x e</SAMP>)
<DD> Re-execute the last keyboard macro defined, by making the characters in the macro appear as if  typed
at the keyboard.
</DL>

<H3><A NAME="Miscellaneous">Miscellaneous</A></H3>

<DL>
<DT> <A NAME="re-read-init-file"><CODE>re-read-init-file</CODE></A> (<SAMP>C-x C-r</SAMP>)
<DD> Read  in the contents of the <A HREF="#~/.inputrc"><I>inputrc</I></A> file, and incorporate any bindings or variable  assignments  found
there.
<DT> <A NAME="abort"><CODE>abort</CODE></A> (<SAMP>C-g</SAMP>)
<DD> Abort the current editing command and ring the terminal's   bell   (subject   to   the   setting   of
<A HREF="#bell-style"><CODE>bell-style</CODE></A>).
<DT> <A NAME="do-uppercase-version"><CODE>do-uppercase-version</CODE></A> (<SAMP>M-a</SAMP>, <SAMP>M-b</SAMP>, <SAMP>M-<VAR>x</VAR></SAMP>, ...)
<DD> If  the  metafied character <VAR>x</VAR> is lowercase, run the
command that is bound to the  corresponding  uppercase character.
<DT> <A NAME="prefix-meta"><CODE>prefix-meta</CODE></A> (<SAMP>ESC</SAMP>)
<DD> Metafy the next character typed.  <SAMP>ESC f</SAMP> is  equivalent to <SAMP>Meta-f</SAMP>.
<DT> <A NAME="undo"><CODE>undo</CODE></A> (<SAMP>C-_</SAMP>, <SAMP>C-x C-u</SAMP>)
<DD> Incremental  undo,  separately  remembered for each
line.
<DT> <A NAME="revert-line"><CODE>revert-line</CODE></A> (<SAMP>M-r</SAMP>)
<DD> Undo all changes made to this line.  This  is  like
executing  the <A HREF="#undo"><CODE>undo</CODE></A> command enough times to return the
line to its initial state.
<DT> <A NAME="tilde-expand"><CODE>tilde-expand</CODE></A> (<SAMP>M-~</SAMP>)
<DD> Perform tilde expansion on the current word.
<DT> <A NAME="set-mark"><CODE>set-mark</CODE></A> (<SAMP>C-@</SAMP>, <SAMP>M-<I>space</I></SAMP>)
<DD> Set  the  mark  to the current point.  If a numeric
argument is supplied, the mark is set to that position.
<DT> <A NAME="exchange-point-and-mark"><CODE>exchange-point-and-mark</CODE></A> (<SAMP>C-x C-x</SAMP>)
<DD> Swap  the  point with the mark.  The current cursor
position is set to the saved position, and the  old
cursor position is saved as the mark.
<DT> <A NAME="character-search"><CODE>character-search</CODE></A> (<SAMP>C-]</SAMP>)
<DD> A  character is read and point is moved to the next
occurrence of that  character.   A  negative  count
searches for previous occurrences.
<DT> <A NAME="character-search-backward"><CODE>character-search-backward</CODE></A> (<SAMP>M-C-]</SAMP>)
<DD> A  character is read and point is moved to the previous
occurrence of  that  character.   A  negative
count searches for subsequent occurrences.
<DT> <A NAME="insert-comment"><CODE>insert-comment</CODE></A> (<SAMP>M-#</SAMP>)
<DD> The value of the readline <CODE>comment-begin</CODE> variable is
inserted at the beginning of the current line,  and
the  line  is  accepted  as  if  a newline had been
typed.  This makes the current line  a  shell  comment.
<DT> <A NAME="dump-functions"><CODE>dump-functions</CODE></A>
<DD> Print all of the functions and their  key  bindings
to  the readline output stream.  If a numeric argument is supplied, the output is formatted in such a
way that it can be made part of an <A HREF="#~/.inputrc"><I>inputrc</I></A> file.
<DT> <A NAME="dump-variables"><CODE>dump-variables</CODE></A>
<DD> Print all of the settable variables and their  values
to  the  readline output stream.  If a numeric
argument is supplied, the output  is  formatted  in
such  a  way that it can be made part of an <A HREF="#~/.inputrc"><I>inputrc</I></A>
file.
<DT> <A NAME="dump-macros"><CODE>dump-macros</CODE></A>
<DD> Print all of the readline key  sequences  bound  to
macros  and  the  strings they ouput.  If a numeric
argument is supplied, the output  is  formatted  in
such  a  way that it can be made part of an <A HREF="#~/.inputrc"><I>inputrc</I></A>
file.
<DT> <A NAME="emacs-editing-mode"><CODE>emacs-editing-mode</CODE></A> (<SAMP>C-e</SAMP>)
<DD> When  in  <CODE>vi</CODE>  editing mode, this causes a switch to
<CODE>emacs</CODE> editing mode.
<DT> <A NAME="vi-editing-mode"><CODE>vi-editing-mode</CODE></A> (<SAMP>M-C-j</SAMP>)
<DD> When in <CODE>emacs</CODE> editing mode, this causes a switch to
<CODE>vi</CODE> editing mode.
</DL>

<H2><A NAME="Default Key Bindings">Default Key Bindings</A></H2>

The  following is a list of the default emacs and vi bindings.  Characters with the 8th  bit  set  are  written  as
<SAMP>M-</SAMP><VAR>character</VAR>, and are referred to as <i>metafied</i>
 characters.
The printable ASCII characters not mentioned in  the  list
of  emacs  standard  bindings are bound to the <A HREF="#self-insert"><CODE>self-insert</CODE></A>
function, which just inserts the given character into  the
input  line.   In  vi  insertion  mode, all characters not
specifically mentioned are bound to <A HREF="#self-insert"><CODE>self-insert</CODE></A>.
Characters  assigned to signal generation by <A HREF="stty(1)"><CODE>stty</CODE></A>(1)
or the terminal driver, such as <SAMP>C-Z</SAMP> or <SAMP>C-C</SAMP>,  retain  that  function.
Upper  and lower case <i>metafied</i> characters are bound to the
same function in the emacs mode meta keymap.  The  remaining
characters are unbound, which causes readline to ring
the bell (subject to the setting of the  <A HREF="#bell-style"><CODE>bell-style</CODE></A>  variable).

<H3><A NAME="Key Bindings in Emacs Mode">Emacs Mode</A></H3>

<DL>
<DT> Emacs Standard bindings
<DD> <PRE>
"C-@"             <A HREF="#set-mark"><CODE>set-mark</CODE></A>
"C-A"             <A HREF="#beginning-of-line"><CODE>beginning-of-line</CODE></A>
"C-B"             <A HREF="#backward-char"><CODE>backward-char</CODE></A>
"C-D"             <A HREF="#delete-char"><CODE>delete-char</CODE></A>
"C-E"             <A HREF="#end-of-line"><CODE>end-of-line</CODE></A>
"C-F"             <A HREF="#forward-char"><CODE>forward-char</CODE></A>
"C-G"             <A HREF="#abort"><CODE>abort</CODE></A>
"C-H"             <A HREF="#backward-delete-char"><CODE>backward-delete-char</CODE></A>
"C-I"             <A HREF="#complete"><CODE>complete</CODE></A>
"C-J"             <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-K"             <A HREF="#kill-line"><CODE>kill-line</CODE></A>
"C-L"             <A HREF="#clear-screen"><CODE>clear-screen</CODE></A>
"C-M"             <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-N"             <A HREF="#next-history"><CODE>next-history</CODE></A>
"C-P"             <A HREF="#previous-history"><CODE>previous-history</CODE></A>
"C-Q"             <A HREF="#quoted-insert"><CODE>quoted-insert</CODE></A>
"C-R"             <A HREF="#reverse-search-history"><CODE>reverse-search-history</CODE></A>
"C-S"             <A HREF="#forward-search-history"><CODE>forward-search-history</CODE></A>
"C-T"             <A HREF="#transpose-chars"><CODE>transpose-chars</CODE></A>
"C-U"             <A HREF="#unix-line-discard"><CODE>unix-line-discard</CODE></A>
"C-V"             <A HREF="#quoted-insert"><CODE>quoted-insert</CODE></A>
"C-W"             <A HREF="#unix-word-rubout"><CODE>unix-word-rubout</CODE></A>
"C-Y"             <A HREF="#yank"><CODE>yank</CODE></A>
"C-]"             <A HREF="#character-search"><CODE>character-search</CODE></A>
"C-_"             <A HREF="#undo"><CODE>undo</CODE></A>
" " to "/"        <A HREF="#self-insert"><CODE>self-insert</CODE></A>
"0" to "9"        <A HREF="#self-insert"><CODE>self-insert</CODE></A>
":" to "~"        <A HREF="#self-insert"><CODE>self-insert</CODE></A>
"C-?"             <A HREF="#backward-delete-char"><CODE>backward-delete-char</CODE></A>
</PRE>
<DT> Emacs Meta bindings
<DD> <PRE>
"<SAMP>M-C-G</SAMP>"           <A HREF="#abort"><CODE>abort</CODE></A>
"<SAMP>M-C-H</SAMP>"           <A HREF="#backward-kill-word"><CODE>backward-kill-word</CODE></A>
"<SAMP>M-C-I</SAMP>"           <A HREF="#tab-insert"><CODE>tab-insert</CODE></A>
"<SAMP>M-C-J</SAMP>"           <A HREF="#vi-editing-mode"><CODE>vi-editing-mode</CODE></A>
"<SAMP>M-C-M</SAMP>"           <A HREF="#vi-editing-mode"><CODE>vi-editing-mode</CODE></A>
"<SAMP>M-C-R</SAMP>"           <A HREF="#revert-line"><CODE>revert-line</CODE></A>
"<SAMP>M-C-Y</SAMP>"           <A HREF="#yank-nth-arg"><CODE>yank-nth-arg</CODE></A>
"<SAMP>M-C-[</SAMP>"           <A HREF="#complete"><CODE>complete</CODE></A>
"<SAMP>M-C-]</SAMP>"           <A HREF="#character-search-backward"><CODE>character-search-backward</CODE></A>
"<SAMP>M-<I>space</I></SAMP>"             <A HREF="#set-mark"><CODE>set-mark</CODE></A>
"<SAMP>M-#</SAMP>"             <A HREF="#insert-comment"><CODE>insert-comment</CODE></A>
"<SAMP>M-&amp;</SAMP>"             <A HREF="#tilde-expand"><CODE>tilde-expand</CODE></A>
"<SAMP>M-*</SAMP>"             <A HREF="#insert-completions"><CODE>insert-completions</CODE></A>
"<SAMP>M--</SAMP>"             <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-.</SAMP>"             <A HREF="#yank-last-arg"><CODE>yank-last-arg</CODE></A>
"<SAMP>M-0</SAMP>"             <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-1</SAMP>"             <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-2</SAMP>"             <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-3</SAMP>"             <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-4</SAMP>"             <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-5</SAMP>"             <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-6</SAMP>"             <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-7</SAMP>"             <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-8</SAMP>"             <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-9</SAMP>"             <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-&lt;</SAMP>"             <A HREF="#beginning-of-history"><CODE>beginning-of-history</CODE></A>
"<SAMP>M-=</SAMP>"             <A HREF="#possible-completions"><CODE>possible-completions</CODE></A>
"<SAMP>M-&gt;</SAMP>"             <A HREF="#end-of-history"><CODE>end-of-history</CODE></A>
"<SAMP>M-?</SAMP>"             <A HREF="#possible-completions"><CODE>possible-completions</CODE></A>
"<SAMP>M-B</SAMP>"             <A HREF="#backward-word"><CODE>backward-word</CODE></A>
"<SAMP>M-C</SAMP>"             <A HREF="#capitalize-word"><CODE>capitalize-word</CODE></A>
"<SAMP>M-D</SAMP>"             <A HREF="#kill-word"><CODE>kill-word</CODE></A>
"<SAMP>M-F</SAMP>"             <A HREF="#forward-word"><CODE>forward-word</CODE></A>
"<SAMP>M-L</SAMP>"             <A HREF="#downcase-word"><CODE>downcase-word</CODE></A>
"<SAMP>M-N</SAMP>"             <A HREF="#non-incremental-forward-search-history"><CODE>non-incremental-forward-search-history</CODE></A>
"<SAMP>M-O</SAMP>"             <CODE>arrow-key-prefix</CODE>
"<SAMP>M-P</SAMP>"             <A HREF="#non-incremental-reverse-search-history"><CODE>non-incremental-reverse-search-history</CODE></A>
"<SAMP>M-R</SAMP>"             <A HREF="#revert-line"><CODE>revert-line</CODE></A>
"<SAMP>M-T</SAMP>"             <A HREF="#transpose-words"><CODE>transpose-words</CODE></A>
"<SAMP>M-U</SAMP>"             <A HREF="#upcase-word"><CODE>upcase-word</CODE></A>
"<SAMP>M-Y</SAMP>"             <A HREF="#yank-pop"><CODE>yank-pop</CODE></A>
"<SAMP>M-\</SAMP>"             <A HREF="#delete-horizontal-space"><CODE>delete-horizontal-space</CODE></A>
"<SAMP>M-~</SAMP>"             <A HREF="#tilde-expand"><CODE>tilde-expand</CODE></A>
"<SAMP>M-C-?</SAMP>"           <CODE>backward-delete-word</CODE>
"<SAMP>M-_</SAMP>"             <A HREF="#yank-last-arg"><CODE>yank-last-arg</CODE></A>
</PRE>
<DT> Emacs Control-X bindings
<DD> <PRE>
"C-XC-G"          <A HREF="#abort"><CODE>abort</CODE></A>
"C-XC-R"          <A HREF="#re-read-init-file"><CODE>re-read-init-file</CODE></A>
"C-XC-U"          <A HREF="#undo"><CODE>undo</CODE></A>
"C-XC-X"          <A HREF="#exchange-point-and-mark"><CODE>exchange-point-and-mark</CODE></A>
"C-X("            <A HREF="#start-kbd-macro"><CODE>start-kbd-macro</CODE></A>
"C-X)"            <A HREF="#end-kbd-macro"><CODE>end-kbd-macro</CODE></A>
"C-Xe"            <A HREF="#call-last-kbd-macro"><CODE>call-last-kbd-macro</CODE></A>
"C-XC-?"          <A HREF="#backward-kill-line"><CODE>backward-kill-line</CODE></A>
</PRE>
</DL>

<H3><A NAME="Key Bindings in VI Mode">VI Mode bindings</A></H3>

<DL>
<DT> VI Insert Mode functions
<DD> <PRE>
"C-D"             <CODE>vi-eof-maybe</CODE>
"C-H"             <A HREF="#backward-delete-char"><CODE>backward-delete-char</CODE></A>
"C-I"             <A HREF="#complete"><CODE>complete</CODE></A>
"C-J"             <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-M"             <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-R"             <A HREF="#reverse-search-history"><CODE>reverse-search-history</CODE></A>
"C-S"             <A HREF="#forward-search-history"><CODE>forward-search-history</CODE></A>
"C-T"             <A HREF="#transpose-chars"><CODE>transpose-chars</CODE></A>
"C-U"             <A HREF="#unix-line-discard"><CODE>unix-line-discard</CODE></A>
"C-V"             <A HREF="#quoted-insert"><CODE>quoted-insert</CODE></A>
"C-W"             <A HREF="#unix-word-rubout"><CODE>unix-word-rubout</CODE></A>
"C-Y"             <A HREF="#yank"><CODE>yank</CODE></A>
"C-["             <CODE>vi-movement-mode</CODE>
"C-_"             <A HREF="#undo"><CODE>undo</CODE></A>
" " to "~"        <A HREF="#self-insert"><CODE>self-insert</CODE></A>
"C-?"             <A HREF="#backward-delete-char"><CODE>backward-delete-char</CODE></A>
</PRE>
<DT> VI Command Mode functions
<DD> <PRE>
"C-D"             <CODE>vi-eof-maybe</CODE>
"C-E"             <A HREF="#emacs-editing-mode"><CODE>emacs-editing-mode</CODE></A>
"C-G"             <A HREF="#abort"><CODE>abort</CODE></A>
"C-H"             <A HREF="#backward-char"><CODE>backward-char</CODE></A>
"C-J"             <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-K"             <A HREF="#kill-line"><CODE>kill-line</CODE></A>
"C-L"             <A HREF="#clear-screen"><CODE>clear-screen</CODE></A>
"C-M"             <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-N"             <A HREF="#next-history"><CODE>next-history</CODE></A>
"C-P"             <A HREF="#previous-history"><CODE>previous-history</CODE></A>
"C-Q"             <A HREF="#quoted-insert"><CODE>quoted-insert</CODE></A>
"C-R"             <A HREF="#reverse-search-history"><CODE>reverse-search-history</CODE></A>
"C-S"             <A HREF="#forward-search-history"><CODE>forward-search-history</CODE></A>
"C-T"             <A HREF="#transpose-chars"><CODE>transpose-chars</CODE></A>
"C-U"             <A HREF="#unix-line-discard"><CODE>unix-line-discard</CODE></A>
"C-V"             <A HREF="#quoted-insert"><CODE>quoted-insert</CODE></A>
"C-W"             <A HREF="#unix-word-rubout"><CODE>unix-word-rubout</CODE></A>
"C-Y"             <A HREF="#yank"><CODE>yank</CODE></A>
" "               <A HREF="#forward-char"><CODE>forward-char</CODE></A>
"#"               <A HREF="#insert-comment"><CODE>insert-comment</CODE></A>
"$"               <A HREF="#end-of-line"><CODE>end-of-line</CODE></A>
"%"               <CODE>vi-match</CODE>
"&amp;"               <CODE>vi-tilde-expand</CODE>
"*"               <CODE>vi-complete</CODE>
"+"               <A HREF="#next-history"><CODE>next-history</CODE></A>
","               <CODE>vi-char-search</CODE>
"-"               <A HREF="#previous-history"><CODE>previous-history</CODE></A>
"."               <CODE>vi-redo</CODE>
"/"               <CODE>vi-search</CODE>
"0"               <A HREF="#beginning-of-line"><CODE>beginning-of-line</CODE></A>
"1" to "9"        <CODE>vi-arg-digit</CODE>
";"               <CODE>vi-char-search</CODE>
"="               <CODE>vi-complete</CODE>
"?"               <CODE>vi-search</CODE>
"A"               <CODE>vi-append-eol</CODE>
"B"               <CODE>vi-prev-word</CODE>
"C"               <CODE>vi-change-to</CODE>
"D"               <CODE>vi-delete-to</CODE>
"E"               <CODE>vi-end-word</CODE>
"F"               <CODE>vi-char-search</CODE>
"G"               <CODE>vi-fetch-history</CODE>
"I"               <CODE>vi-insert-beg</CODE>
"N"               <CODE>vi-search-again</CODE>
"P"               <CODE>vi-put</CODE>
"R"               <CODE>vi-replace</CODE>
"S"               <CODE>vi-subst</CODE>
"T"               <CODE>vi-char-search</CODE>
"U"               <A HREF="#revert-line"><CODE>revert-line</CODE></A>
"W"               <CODE>vi-next-word</CODE>
"X"               <A HREF="#backward-delete-char"><CODE>backward-delete-char</CODE></A>
"Y"               <CODE>vi-yank-to</CODE>
"\"               <CODE>vi-complete</CODE>
"^"               <CODE>vi-first-print</CODE>
"_"               <CODE>vi-yank-arg</CODE>
"`"               <CODE>vi-goto-mark</CODE>
"a"               <CODE>vi-append-mode</CODE>
"b"               <CODE>vi-prev-word</CODE>
"c"               <CODE>vi-change-to</CODE>
"d"               <CODE>vi-delete-to</CODE>
"e"               <CODE>vi-end-word</CODE>
"f"               <CODE>vi-char-search</CODE>
"h"               <A HREF="#backward-char"><CODE>backward-char</CODE></A>
"i"               <CODE>vi-insertion-mode</CODE>
"j"               <A HREF="#next-history"><CODE>next-history</CODE></A>
"k"               <CODE>prev-history</CODE>
"l"               <A HREF="#forward-char"><CODE>forward-char</CODE></A>
"m"               <CODE>vi-set-mark</CODE>
"n"               <CODE>vi-search-again</CODE>
"p"               <CODE>vi-put</CODE>
"r"               <CODE>vi-change-char</CODE>
"s"               <CODE>vi-subst</CODE>
"t"               <CODE>vi-char-search</CODE>
"u"               <A HREF="#undo"><CODE>undo</CODE></A>
"w"               <CODE>vi-next-word</CODE>
"x"               <CODE>vi-delete</CODE>
"y"               <CODE>vi-yank-to</CODE>
"|"               <CODE>vi-column</CODE>
"~"               <CODE>vi-change-case</CODE>
</PRE>
</DL>

<H2><A NAME="See also">See also</A></H2>

<UL>
<LI> <EM>The Gnu Readline Library</EM>, Brian Fox
<LI> <EM>The Gnu History Library</EM>, Brian Fox
<LI> <A HREF="bash(1)"><CODE><B>bash</B></CODE></A>(1)
</UL>

<H2><A NAME="Files">Files</A></H2>

<DL>
<DT> <A NAME="~/.inputrc"><CODE>~/.inputrc</CODE></A>
<DD> Individual readline initialization file
</DL>

<H2><A NAME="Authors">Authors</A></H2>

<UL>
<LI>Brian   Fox,   Free  Software  Foundation<BR>
<TT>bfox@gnu.org</TT>
<LI>Chet Ramey, Case Western Reserve University<BR>
<TT>chet@ins.CWRU.Edu</TT>
<LI>Bruno Haible<BR>
<TT>haible@clisp.cons.org</TT>
</UL>

<H2><A NAME="Bug Reports">Bug Reports</A></H2>

If you find a bug in readline, you should report it.  Send
mail to <TT>haible@clisp.cons.org</TT>.

<H2><A NAME="Bugs">Bugs</A></H2>

It's too big and too slow.
<P>

<HR>

<ADDRESS>CLISP-READLINE manual page<BR>
Bruno Haible &lt;haible@clisp.cons.org&gt;
</ADDRESS>
<P>
Last modified: 23 January 2000.

</BODY>

