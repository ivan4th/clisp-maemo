<HEAD>
<TITLE> READLINE manual page </TITLE>
</HEAD>
<BODY>
<H1>READLINE manual page</H1>

<UL>
<LI> <A HREF="#Name">Name</A>
<LI> <A HREF="#Synopsis">Synopsis</A>
<LI> <A HREF="#Copyright">Copyright</A>
<LI> <A HREF="#Description">Description</A>
<LI> <A HREF="#Return value">Return value</A>
<LI> <A HREF="#Notation">Notation</A>
<LI> <A HREF="#Initialization File">Initialization File</A>
     <UL>
     <LI> <A HREF="#Key Bindings">Key Bindings</A>
     <LI> <A HREF="#Variables">Variables</A>
     <LI> <A HREF="#Conditional Constructs">Conditional Constructs</A>
     </UL>
<LI> <A HREF="#Editing Commands">Editing Commands</A>
     <UL>
     <LI> <A HREF="#Commands for Moving">Commands for Moving</A>
     <LI> <A HREF="#Commands for Manipulating the History">Commands for Manipulating the History</A>
     <LI> <A HREF="#Commands for Changing Text">Commands for Changing Text</A>
     <LI> <A HREF="#Killing and Yanking">Killing and Yanking</A>
     <LI> <A HREF="#Numeric Arguments">Numeric Arguments</A>
     <LI> <A HREF="#Completing">Completing</A>
     <LI> <A HREF="#Keyboard Macros">Keyboard Macros</A>
     <LI> <A HREF="#Miscellaneous"></A>
     </UL>
<LI> <A HREF="#Default Key Bindings">Default Key Bindings</A>
     <UL>
     <LI> <A HREF="#Key Bindings in Emacs Mode">Emacs Mode</A>
     <LI> <A HREF="#Key Bindings in VI Mode">VI Mode bindings</A>
     </UL>
<LI> <A HREF="#See also">See also</A>
<LI> <A HREF="#Files">Files</A>
<LI> <A HREF="#Authors">Authors</A>
<LI> <A HREF="#Bug Reports">Bug Reports</A>
<LI> <A HREF="#Bugs">Bugs</A>
</UL>
<P>

<HR>

<A NAME="Name">
<H2>Name</H2>
</A>

readline - get a line from a user with editing

<A NAME="Synopsis">
<H2>Synopsis</H2>
</A>

<PRE><CODE>
#include &lt;readline.h&gt;
#include &lt;history.h&gt;

typedef int Function ();

<A NAME="function readline">char *readline (prompt)</A>
    char *prompt;

<A NAME="function rl_add_defun">int rl_add_defun (name, function, key)</A>
    char *name;
    Function *function;
    int key;

<A NAME="function rl_bind_key">int rl_bind_key (key, function)</A>
    int key;
    Function *function;

<A NAME="function rl_unbind_key">int rl_unbind_key (key)</A>
    int key;

<A NAME="function rl_bind_key_in_map">int rl_bind_key_in_map (key, function, keymap)</A>
    int key;
    Function *function;
    Keymap keymap;

<A NAME="function rl_unbind_key_in_map">int rl_unbind_key_in_map (key, keymap)</A>
    int key;
    Keymap keymap;

<A NAME="function rl_macro_bind">int rl_macro_bind  (keyseq,  macro, keymap)</A>
    char *keyseq, *macro;
    Keymap keymap;

<A NAME="function rl_variable_bind">int rl_variable_bind (variable, value)</A>
    char *variable, *value;

<A NAME="function rl_parse_and_bind">int rl_parse_and_bind (line)</A>
    char *line;

<A NAME="function rl_translate_keyseq">int rl_translate_keyseq (keyseq, array, len)</A>
    char *keyseq, *array;
    int *len;

<A NAME="function rl_named_function">Function *rl_named_function (command)</A>
    char *command;

<A NAME="function rl_function_of_keyseq">Function *rl_function_of_keyseq (keyseq, keymap, type)</A>
    char *keyseq;
    Keymap keymap;
    int *type;

<A NAME="function rl_invoking_keyseqs">char **rl_invoking_keyseqs (function)</A>
    Function *function;

<A NAME="function rl_invoking_keyseqs_in_map">char **rl_invoking_keyseqs_in_map (function, keymap)</A>
    Function *function;
    Keymap keymap;

<A NAME="function rl_function_dumper">void rl_function_dumper (readable)</A>
    int readable;

<A NAME="function rl_funmap_names">char **rl_funmap_names ()</A>
</CODE></PRE>

<A NAME="Copyright">
<H2>Copyright</H2>
</A>

Readline is Copyright  1989, 1991  by  the  Free  Software
Foundation, Inc.

<A NAME="Description">
<H2>Description</H2>
</A>

<A HREF="#function readline"><CODE><B>readline</B></CODE></A> will read a line from the terminal and return it,
using <CODE>prompt</CODE> as a prompt.  If <CODE>prompt</CODE> is null, no prompt is
issued.  The line returned is allocated with <A HREF="malloc(3)"><CODE>malloc</CODE></A>(3), so
the caller must free it when finished.  The line  returned
has  the  final  newline  removed, so only the text of the
line remains.
<P>

<CODE>readline</CODE> offers editing capabilities  while  the  user  is
entering  the line.  By default, the line editing commands
are similar to those of emacs.  A  vi-style  line  editing
interface is also available.
<P>

In  the  following  descriptions,  <CODE>keymap</CODE>  can  be  one of
<CODE>emacs_keymap</CODE>,    <CODE>emacs_meta_keymap</CODE>,     <CODE>emacs_ctlx_keymap</CODE>,
<CODE>vi_insertion_keymap</CODE>, or <CODE>vi_movement_keymap</CODE>.
<P>

<A HREF="#function rl_add_defun"><CODE><B>rl_add_defun</B></CODE></A> makes <CODE>name</CODE> appear as a bindable readline command, and makes function be the function called when  that
command  is  invoked.   If  <CODE>key</CODE>  is not <CODE>-1</CODE>, it is bound to
function in the current keymap.
<P>

<A HREF="#function rl_bind_key"><CODE><B>rl_bind_key</B></CODE></A> causes <CODE>key</CODE> to invoke <CODE>function</CODE>.  The binding is
made in the current keymap.
<P>

<A HREF="#function rl_unbind_key"><CODE><B>rl_unbind_key</B></CODE></A>  removes  the binding for <CODE>key</CODE> in the current
keymap.
<P>

<A HREF="#function rl_bind_key_in_map"><CODE><B>rl_bind_key_in_map</B></CODE></A> makes the <CODE>key</CODE> entry  in  <CODE>keymap</CODE>  invoke
function.
<P>

<A HREF="#function rl_unbind_key_in_map"><CODE><B>rl_unbind_key_in_map</B></CODE></A> removes the binding for <CODE>key</CODE> in keymap
<CODE>keymap</CODE>.
<P>

<A HREF="#function rl_macro_bind"><CODE><B>rl_macro_bind</B></CODE></A> makes <CODE>keyseq</CODE> insert the string  <CODE>macro</CODE>.   The
binding is performed in <CODE>keymap</CODE>.
<P>

<A HREF="#function rl_variable_bind"><CODE><B>rl_variable_bind</B></CODE></A>  sets  the value of the readline variable
<CODE>variable</CODE> to <CODE>value</CODE>.
<P>

<A HREF="#function rl_parse_and_bind"><CODE><B>rl_parse_and_bind</B></CODE></A> takes as an argument a line of the  same
form as the readline startup file (see <A HREF="#Initialization File">Initialization File</A>
below) and executes the commands therein.
<P>

<A HREF="#function rl_translate_keyseq"><CODE><B>rl_translate_keyseq</B></CODE></A> converts <CODE>keyseq</CODE>  into  a  new  string,
storing  the result in <CODE>array</CODE>.  This translates control and
meta prefixes and the readline character escape  sequences
(see  <A HREF="#Key Bindings">Key Bindings</A> below).  The length of the translated
sequence is returned in <CODE>*len</CODE>.
<P>

<A HREF="#function rl_named_function"><CODE><B>rl_named_function</B></CODE></A> returns the function  that  is  executed
when the readline command <CODE>command</CODE> is invoked.
<P>

<A HREF="#function rl_function_of_keyseq"><CODE><B>rl_function_of_keyseq</B></CODE></A>  returns  the  function that is
executed when <CODE>keyseq</CODE>  is  read  and  <CODE>keymap</CODE>  is  the  current
keymap.   <CODE>type</CODE> is set to indicate whether the return value
corresponds to a function, macro, or auxiliary keymap.
<P>

<A HREF="#function rl_invoking_keyseqs"><CODE><B>rl_invoking_keyseqs</B></CODE></A> returns all of the  key  sequences  in
the current keymap that invoke <CODE>function</CODE>.
<P>

<A HREF="#function rl_invoking_keyseqs_in_map"><CODE><B>rl_invoking_keyseqs_in_map</B></CODE></A>   returns   all   of   the  key
sequences in <CODE>keymap</CODE> that invoke <CODE>function</CODE>.
<P>

<A HREF="#function rl_function_dumper"><CODE><B>rl_function_dumper</B></CODE></A> prints all of  the  readline  functions
and  their  bindings  to  the  readline output stream.  If
<CODE>readable</CODE> is non-zero, the output is formattted so that  it
can be read back in to restore the bindings.
<P>

<A HREF="#function rl_funmap_names"><CODE><B>rl_funmap_names</B></CODE></A>  returns  an  array  of all known readline
bindable function names.  The array is sorted.

<A NAME="Return value">
<H2>Return value</H2>
</A>

<CODE>readline</CODE> returns the text of the line read.  A blank  line
returns  the  empty  string.   If EOF is encountered while
reading a line, and the line is empty, <CODE>NULL</CODE>  is  returned.
If  an EOF is read with a non-empty line, it is treated as
a newline.
<P>

Unless otherwise stated, the other functions return  0  on
success and non-zero on failure.


<A NAME="Notation">
<H2>Notation</H2>
</A>

An  emacs-style  notation  is  used  to denote keystrokes.
Control keys are denoted by <SAMP>C-</SAMP><VAR>key</VAR>,
e.g.,  <SAMP>C-n</SAMP>  means  Control-<KBD>N</KBD>.  Similarly, <i>meta</i>
keys are denoted by <SAMP>M-</SAMP><VAR>key</VAR> , so <SAMP>M-x</SAMP>
means Meta-<KBD>X</KBD>.  (On keyboards without a <i>meta</i>
 key, <SAMP>M-</SAMP><VAR>x</VAR>
 means ESC <VAR>x</VAR> ,  i.e.,  press the Escape key then the <VAR>x</VAR>
 key.  This
makes ESC the <i>meta prefix</i>.  The  combination  <SAMP>M-C-</SAMP><VAR>x</VAR>
  means ESC-Control-<VAR>x</VAR> ,  or press the Escape key then hold the Control key while pressing the <i>x</i>
 key.)
<P>

Readline commands may be given  numeric  <i>arguments</i>,  which
normally act as a repeat count.  Sometimes, however, it is
the sign of the argument that is significant.   Passing  a
negative  argument  to  a command that acts in the forward
direction (e.g., <A HREF="#kill-line"><CODE>kill-line</CODE></A>) causes that command to act  in
a  backward direction.  Commands whose behavior with arguments deviates from this are noted.
<P>

When a command is described  as  <i>killing</i> text,  the  text
deleted  is saved for possible future retrieval (<i>yanking</i>).
The killed text is  saved  in  a  <i>kill-ring</i>.   Consecutive
kills  cause  the  text  to  be accumulated into one unit,
which can be yanked all at once.  Commands  which  do  not
kill text separate the chunks of text on the kill-ring.

<A NAME="Initialization File">
<H2>Initialization File</H2>
</A>

Readline  is customized by putting commands in an initialization file.
The name of this file  is  taken  from  the
value of the <CODE>INPUTRC</CODE> variable.  If that variable is unset,
the default is <A HREF="#~/.inputrc"><CODE>~/.inputrc</CODE></A>.  When a program which uses  the
readline library starts up, the init file is read, and the
key bindings and variables are set.  There are only a  few
basic constructs allowed in the readline init file.  Blank
lines are ignored.  Lines beginning with a <CODE>#</CODE> are comments.
Lines  beginning with a <CODE>$</CODE> indicate conditional constructs.
Other lines denote key  bindings  and  variable  settings.
Each  program  using this library may add its own commands
and bindings.
<P>

For example, placing
<BLOCKQUOTE>
<CODE>M-Control-u: universal-argument</CODE>
</BLOCKQUOTE>
or
<BLOCKQUOTE>
<CODE>C-Meta-u: universal-argument</CODE>
</BLOCKQUOTE>
into the <A HREF="#~/.inputrc"><CODE>~/.inputrc</CODE></A> would make <SAMP>M-C-u</SAMP> execute the  readline
command <A HREF="#universal-argument"><CODE>universal-argument</CODE></A>.
<P>

The  following  symbolic  character  names  are recognized
while processing key bindings:
<CODE>RUBOUT</CODE>, <CODE>DEL</CODE>, <CODE>ESC</CODE>, <CODE>LFD</CODE>,
<CODE>NEWLINE</CODE>,  <CODE>RET</CODE>,  <CODE>RETURN</CODE>,  <CODE>SPC</CODE>,
<CODE>SPACE</CODE>, and <CODE>TAB</CODE>.  In addition to
command names, readline allows  keys  to  be  bound  to  a
string that is inserted when the key is pressed (a <i>macro</i>).
<P>

<A NAME="Key Bindings">
<H3>Key Bindings</H3>
</A>

The syntax for controlling key bindings in the  <A HREF="#~/.inputrc"><CODE>~/.inputrc</CODE></A>
file  is  simple.  All that is required is the name of the
command or the text of a macro and a key sequence to which
it  should  be  bound. The name may be specified in one of
two ways: as a symbolic key name, possibly with  <CODE>Meta-</CODE> or
<CODE>Control-</CODE> prefixes,  or as a key sequence.  When using the
form
<BLOCKQUOTE>
<VAR>keyname</VAR><CODE>:</CODE> <VAR>function-name</VAR> or <VAR>macro</VAR>
</BLOCKQUOTE>
<VAR>keyname</VAR> is  the  name
of a key spelled out in English.  For example:
<BLOCKQUOTE>
<PRE><CODE>Control-u: universal-argument
Meta-Rubout: backward-kill-word
Control-o: "&gt;&amp;output"
</CODE></PRE>
</BLOCKQUOTE>
In the above example, <SAMP>C-u</SAMP>
 is bound to the function <A HREF="#universal-argument"><CODE>universal-argument</CODE></A>,  <SAMP>M-DEL</SAMP>
  is  bound  to  the  function   <A HREF="#backward-kill-word"><CODE>backward-kill-word</CODE></A>,   and  <SAMP>C-o</SAMP>
  is  bound  to  run  the  macro
expressed on the right hand side (that is, to  insert  the
text <SAMP>>&amp;output</SAMP>
 into the line).
<P>

In  the second form,
<BLOCKQUOTE>
<CODE>"</CODE><VAR>keyseq</VAR><CODE>":</CODE><VAR>function-name</VAR>
 or <VAR>macro</VAR>
</BLOCKQUOTE>
<VAR>keyseq</VAR> differs from <VAR>keyname</VAR> above in that strings denoting an
entire  key  sequence  may  be  specified  by  placing the
sequence within double quotes.  Some GNU Emacs  style  key
escapes can be used, as in the following example.
<BLOCKQUOTE>
<PRE><CODE>"\C-u": universal-argument
"\C-x\C-r": re-read-init-file
"\e[11~": "Function Key 1"
</CODE></PRE>
</BLOCKQUOTE>
In  this  example, <SAMP>C-u</SAMP>
 is again bound to the function <A HREF="#universal-argument"><CODE>universal-argument</CODE></A>.   <SAMP>C-x C-r</SAMP>
  is  bound  to  the   function <A HREF="#re-read-init-file"><CODE>re-read-init-file</CODE></A>,  and <SAMP>ESC [ 1 1 ~</SAMP>
 is bound to insert the
text <TT>Function Key 1</TT>.  The full set of escape sequences is
<DL>
<DT><CODE>\C-</CODE> <DD>control prefix
<DT><CODE>\M-</CODE> <DD>meta prefix
<DT><CODE>\e </CODE> <DD>an escape character
<DT><CODE>\\ </CODE> <DD>backslash
<DT><CODE>\" </CODE> <DD>literal "
<DT><CODE>\' </CODE> <DD>literal '
</DL>
When entering the text of a macro, single or double quotes
should  be  used to indicate a macro definition.  Unquoted
text is assumed to be a  function  name.   Backslash  will
quote  any character in the macro text, including " and '.
<CODE><B>Bash</B></CODE> allows the current readline key bindings to  be  displayed
  or  modified  with  the <CODE>bind</CODE> builtin command.  The
editing mode may be switched  during  interactive  use  by
using  the  <CODE>-o</CODE>  option  to the <CODE>set</CODE> builtin command.  Other
programs using this library  provide  similar  mechanisms.
The  <VAR>inputrc</VAR> file  may be edited and re-read if a program
does not provide any other means to incorporate new  bindings.

<A NAME="Variables">
<H3>Variables</H3>
</A>

Readline  has  variables  that can be used to further customize its
behavior.  A variable may be set in the <VAR>inputrc</VAR>
file with a statement of the form
<BLOCKQUOTE>
<CODE>set</CODE> <VAR>variable-name</VAR> <VAR>value</VAR>
</BLOCKQUOTE>
<P>

Except where noted, readline variables can take the values
<CODE>On</CODE> or <CODE>Off</CODE>.
The variables and their default values are:
<DL>
<DT> <A NAME="horizontal-scroll-mode"><CODE>horizontal-scroll-mode</CODE></A> (<CODE>Off</CODE>)
<DD> When set to <CODE>On</CODE>, makes readline use  a  single  line
for  display, scrolling the input horizontally on a
single screen line when it becomes longer than  the
screen width rather than wrapping to a new line.
<DT> <A NAME="editing-mode"><CODE>editing-mode</CODE></A> (<CODE>emacs</CODE>)
<DD> Controls  whether readline begins with a set of key
bindings similar to <CODE><B>emacs</B></CODE> or <CODE><B>vi</B></CODE>.
<A HREF="#editing-mode"><CODE>editing-mode</CODE></A> can
be set to either <CODE>emacs</CODE> or <CODE>vi</CODE>.
<DT> <A NAME="mark-modified-lines"><CODE>mark-modified-lines</CODE></A> (<CODE>Off</CODE>)
<DD> If set to <CODE>On</CODE>, history lines that have been modified
are displayed with a preceding asterisk (<CODE>*</CODE>).
<DT> <A NAME="bell-style"><CODE>bell-style</CODE></A> (<CODE>audible</CODE>)
<DD> Controls what happens when readline wants  to  ring
the  terminal bell.  If set to <CODE>none</CODE>, readline never
rings the bell.  If set to <CODE>visible</CODE>, readline uses a
visible  bell if one is available.  If set to <CODE>audible</CODE>,
readline attempts to ring the terminal's bell.
<DT> <A NAME="comment-begin"><CODE>comment-begin</CODE></A> (``<CODE>#</CODE>'')
<DD> The  string  that  is  inserted in vi mode when the
<CODE>vi-comment</CODE> command is executed.
<DT> <A NAME="meta-flag"><CODE>meta-flag</CODE></A> (<CODE>Off</CODE>)
<DD> If set to <CODE>On</CODE>, readline will enable eight-bit  input
(that  is,  it will not strip the high bit from the
characters it reads), regardless of what the terminal claims it can support.
<DT> <A NAME="convert-meta"><CODE>convert-meta</CODE></A> (<CODE>On</CODE>)
<DD> If set to <CODE>On</CODE>, readline will convert characters with
the eighth bit set to  an  ASCII  key  sequence  by
stripping  the  eighth bit and prepending an escape
character (in effect,  using  escape  as  the  <i>meta prefix</i>).
<DT> <A NAME="output-meta"><CODE>output-meta</CODE></A> (<CODE>Off</CODE>)
<DD> If set to <CODE>On</CODE>, readline will display characters with
the eighth bit set directly rather than as a  meta-
prefixed escape sequence.
<DT> <A NAME="completion-query-items"><CODE>completion-query-items</CODE></A> (<CODE>100</CODE>)
<DD> This  determines  when  the  user  is queried about
viewing the number of possible  completions  generated  by
the <A HREF="#possible-completions"><CODE>possible-completions</CODE></A> command.  It may
be set to any integer value greater than  or  equal
to  zero.  If the number of possible completions is
greater than or equal to the value  of  this  variable, the
user is asked whether or not he wishes to
view them; otherwise they are simply listed on  the
terminal.
<DT> <A NAME="keymap"><CODE>keymap</CODE></A> (<CODE>emacs</CODE>)
<DD> Set  the current readline keymap.  The set of legal
keymap names is <CODE>emacs</CODE>, <CODE>emacs-standard</CODE>,  <CODE>emacs-meta</CODE>,
<CODE>emacs-ctlx</CODE>, <CODE>vi</CODE>, <CODE>vi-move</CODE>, <CODE>vi-command</CODE>,
and <CODE>vi-insert</CODE>.  <CODE>vi</CODE> is equivalent to <CODE>vi-command</CODE>;
<CODE>emacs</CODE> is equivalent
to <CODE>emacs-standard</CODE>.  The default value is <CODE>emacs</CODE>; the
value of  <A HREF="#editing-mode"><CODE>editing-mode</CODE></A>  also  affects  the  default
keymap.
<DT> <A NAME="show-all-if-ambiguous"><CODE>show-all-if-ambiguous</CODE></A> (<CODE>Off</CODE>)
<DD> This  alters the default behavior of the completion
functions.  If set to <CODE>on</CODE>,  words  which  have  more
than  one  possible completion cause the matches to
be listed immediately instead of ringing the  bell.
<DT> <A NAME="expand-tilde"><CODE>expand-tilde</CODE></A> (<CODE>Off</CODE>)
<DD> If  set  to  <CODE>on</CODE>,  tilde expansion is performed when
readline attempts word completion.
</DL>

<A NAME="Conditional Constructs">
<H3>Conditional Constructs</H3>
</A>

Readline implements a facility similar in  spirit  to  the
conditional  compilation  features  of  the C preprocessor
which allows key bindings and variable settings to be performed
as  the  result  of tests.  There are three parser
directives used.

<DL>

<DT> <A NAME="$if"><CODE>$if</CODE></A>
<DD> The <A HREF="#$if"><CODE>$if</CODE></A> construct allows bindings to be made  based
on  the  editing  mode, the terminal being used, or
the application using readline.  The  text  of  the
test  extends to the end of the line; no characters
are required to isolate it.
<DL>
<DT> <A NAME="mode"><CODE>mode</CODE></A>
<DD> The <CODE>mode=</CODE> form of the <A HREF="#$if"><CODE>$if</CODE></A> directive is  used
to  test  whether readline is in <CODE>emacs</CODE> or <CODE>vi</CODE>
mode.  This may be used in conjunction  with
the <CODE>set keymap</CODE> command, for instance, to set
bindings in the  <CODE>emacs-standard</CODE>
and  <CODE>emacs-ctlx</CODE> keymaps  only  if readline is starting
out in <CODE>emacs</CODE> mode.
<DT> <A NAME="term"><CODE>term</CODE></A>
<DD> The  <CODE>term=</CODE>  form  may  be  used  to  include
terminal-specific  key  bindings, perhaps to
bind the key sequences output by the  terminal's
function keys.  The word on the right
side of the <CODE>=</CODE> is  tested  against  the  full
name  of the terminal and the portion of the
terminal name  before  the  first  <CODE>-</CODE>.   This
allows  <CODE>sun</CODE> to  match both <CODE>sun</CODE>
and <CODE>sun-cmd</CODE>,
for instance.
<DT> <A NAME="application"><CODE>application</CODE></A>
<DD> The <A HREF="#application"><CODE>application</CODE></A> construct is used to include
application-specific settings.  Each program
using the readline library sets the <i>application name</i>,
and  an initialization file can
test for a particular value.  This could  be
used to bind key sequences to functions useful
for a specific program.   For  instance,
the  following  command  adds a key sequence
that quotes the current or previous word  in
Bash:
<BLOCKQUOTE>
<PRE><CODE><B>$if</B> bash
# Quote the current or previous word
"\C-xq": "\eb\"\ef\""
<B>$endif</B>
</CODE></PRE>
</BLOCKQUOTE>
</DL>

<DT> <A NAME="$endif"><CODE>$endif</CODE></A>
<DD> This  command,  as you saw in the previous example,
terminates an <A HREF="#$if"><CODE>$if</CODE></A> command.

<DT> <A NAME="$else"><CODE>$else</CODE></A>
<DD> Commands in this branch of the  <A HREF="#$if"><CODE>$if</CODE></A>  directive  are
executed if the test fails.

</DL>

<A NAME="Editing Commands">
<H2>Editing Commands</H2>
</A>

The  following  is a list of the names of the commands and
the default key sequences to which they are bound.

<A NAME="Commands for Moving">
<H3>Commands for Moving</H3>
</A>

<DL>
<DT> <A NAME="beginning-of-line"><CODE>beginning-of-line</CODE></A> (<SAMP>C-a</SAMP>)
<DD> Move to the start of the current line.
<DT> <A NAME="end-of-line"><CODE>end-of-line</CODE></A> (<SAMP>C-e</SAMP>)
<DD> Move to the end of the line.
<DT> <A NAME="forward-char"><CODE>forward-char</CODE></A> (<SAMP>C-f</SAMP>)
<DD> Move forward a character.
<DT> <A NAME="backward-char"><CODE>backward-char</CODE></A> (<SAMP>C-b</SAMP>)
<DD> Move back a character.
<DT> <A NAME="forward-word"><CODE>forward-word</CODE></A> (<SAMP>M-f</SAMP>)
<DD> Move forward to the end of the  next  word.   Words
are  composed  of  alphanumeric characters (letters
and digits).
<DT> <A NAME="backward-word"><CODE>backward-word</CODE></A> (<SAMP>M-b</SAMP>)
<DD> Move back to the start of this,  or  the  previous,
word.   Words  are composed of alphanumeric characters (letters and digits).
<DT> <A NAME="clear-screen"><CODE>clear-screen</CODE></A> (<SAMP>C-l</SAMP>)
<DD> Clear the screen leaving the current  line  at  the
top  of  the screen.  With an argument, refresh the
current line without clearing the screen.
<DT> <A NAME="redraw-current-line"><CODE>redraw-current-line</CODE></A>
<DD> Refresh the current  line.   By  default,  this  is
unbound.
</DL>

<A NAME="Commands for Manipulating the History">
<H3>Commands for Manipulating the History</H3>
</A>

<DL>
<DT> <A NAME="accept-line"><CODE>accept-line</CODE></A> (<SAMP>Newline</SAMP>, <SAMP>Return</SAMP>)
<DD> Accept  the line regardless of where the cursor is.
If this line is non-empty, add it  to  the  history
list.  If the line is a modified history line, then
restore the history line to its original state.
<DT> <A NAME="previous-history"><CODE>previous-history</CODE></A> (<SAMP>C-p</SAMP>)
<DD> Fetch the previous command from the  history  list,
moving back in the list.
<DT> <A NAME="next-history"><CODE>next-history</CODE></A> (<SAMP>C-n</SAMP>)
<DD> Fetch  the next command from the history list, moving
forward in the list.
<DT> <A NAME="beginning-of-history"><CODE>beginning-of-history</CODE></A> (<SAMP>M-&lt;</SAMP>)
<DD> Move to the first line in the history.
<DT> <A NAME="end-of-history"><CODE>end-of-history</CODE></A> (<SAMP>M-&gt;</SAMP>)
<DD> Move to the end of the  input  history,  i.e.,  the
line currently being entered.
<DT> <A NAME="reverse-search-history"><CODE>reverse-search-history</CODE></A> (<SAMP>C-r</SAMP>)
<DD> Search  backward  starting  at the current line and
moving `up' through the history as necessary.  This
is an incremental search.
<DT> <A NAME="forward-search-history"><CODE>forward-search-history</CODE></A> (<SAMP>C-s</SAMP>)
<DD> Search  forward  starting  at  the current line and
moving `down' through  the  history  as  necessary.
This is an incremental search.
<DT> <A NAME="non-incremental-reverse-search-history"><CODE>non-incremental-reverse-search-history</CODE></A> (<SAMP>M-p</SAMP>)
<DD> Search backward through the history starting at the
current line using a non-incremental search  for  a
string supplied by the user.
<DT> <A NAME="non-incremental-forward-search-history"><CODE>non-incremental-forward-search-history</CODE></A> (<SAMP>M-n</SAMP>)
<DD> Search   forward   through   the  history  using  a
non-incremental search for a string supplied by the
user.
<DT> <A NAME="history-search-forward"><CODE>history-search-forward</CODE></A>
<DD> Search  forward  through the history for the string
of characters between the start of the current line
and  the  current point.  This is a non-incremental
search.  By default, this command is unbound.
<DT> <A NAME="history-search-backward"><CODE>history-search-backward</CODE></A>
<DD> Search backward through the history for the  string
of characters between the start of the current line
and the current point.  This is  a  non-incremental
search.  By default, this command is unbound.
<DT> <A NAME="yank-nth-arg"><CODE>yank-nth-arg</CODE></A> (<SAMP>M-C-y</SAMP>)
<DD> Insert  the  first argument to the previous command
(usually the second word on the previous  line)  at
point (the current cursor position).  With an argument <VAR>n</VAR>,
insert  the  <VAR>n</VAR> th  word  from  the  previous
command  (the  words  in the previous command begin
with word 0).  A negative argument inserts the  <VAR>n</VAR> th
word from the end of the previous command.
<DT> <A NAME="yank-last-arg"><CODE>yank-last-arg</CODE></A> (<SAMP>M-.</SAMP>, <SAMP>M-_</SAMP>)
<DD> Insert the last argument to the previous command
(the last word on  the  previous line). With an
argument, behave exactly like <A HREF="#yank-nth-arg"><CODE>yank-nth-arg</CODE></A>.
</DL>

<A NAME="Commands for Changing Text">
<H3>Commands for Changing Text</H3>
</A>

<DL>
<DT> <A NAME="delete-char"><CODE>delete-char</CODE></A> (<SAMP>C-d</SAMP>)
<DD> Delete the character under the cursor.  If point is
at the beginning of the line, there are no  characters
in the line, and the last character typed was
not <SAMP>C-d</SAMP>, then return EOF.
<DT> <A NAME="backward-delete-char"><CODE>backward-delete-char</CODE></A> (<SAMP>Rubout</SAMP>)
<DD> Delete the character behind the cursor.  When given
a  numeric  argument,  save the deleted text on the
kill-ring.
<DT> <A NAME="quoted-insert"><CODE>quoted-insert</CODE></A> (<SAMP>C-q</SAMP>, <SAMP>C-v</SAMP>)
<DD> Add the next character that you type  to  the  line
verbatim.   This  is  how to insert characters like
<SAMP>C-q</SAMP>, for example.
<DT> <A NAME="tab-insert"><CODE>tab-insert</CODE></A> (<SAMP>M-TAB</SAMP>)
<DD> Insert a tab character.
<DT> <A NAME="self-insert"><CODE>self-insert</CODE></A> (<SAMP>a</SAMP>, <SAMP>b</SAMP>, <SAMP>A</SAMP>, <SAMP>1</SAMP>, <SAMP>!</SAMP>, ...)
<DD> Insert the character typed.
<DT> <A NAME="transpose-chars"><CODE>transpose-chars</CODE></A> (<SAMP>C-t</SAMP>)
<DD> Drag the character before point  forward  over  the
character  at  point.  Point moves forward as well.
If point is at the end of the line, then  transpose
the  two  characters  before point.  Negative arguments don't work.
<DT> <A NAME="transpose-words"><CODE>transpose-words</CODE></A> (<SAMP>M-t</SAMP>)
<DD> Drag the word behind the cursor past  the  word  in
front  of  the  cursor  moving the cursor over that
word as well.
<DT> <A NAME="upcase-word"><CODE>upcase-word</CODE></A> (<SAMP>M-u</SAMP>)
<DD> Uppercase the current (or following) word.  With  a
negative argument, do the previous word, but do not
move point.
<DT> <A NAME="downcase-word"><CODE>downcase-word</CODE></A> (<SAMP>M-l</SAMP>)
<DD> Lowercase the current (or following) word.  With  a
negative argument, do the previous word, but do not
move point.
<DT> <A NAME="capitalize-word"><CODE>capitalize-word</CODE></A> (<SAMP>M-c</SAMP>)
<DD> Capitalize the current (or following) word.  With a
negative argument, do the previous word, but do not
move point.
</DL>

<A NAME="Killing and Yanking">
<H3>Killing and Yanking</H3>
</A>

<DL>
<DT> <A NAME="kill-line"><CODE>kill-line</CODE></A> (<SAMP>C-k</SAMP>)
<DD> Kill the text from the current cursor  position  to
the end of the line.
<DT> <A NAME="backward-kill-line"><CODE>backward-kill-line</CODE></A> (<SAMP>C-x Rubout</SAMP>)
<DD> Kill backward to the beginning of the line.
<DT> <A NAME="unix-line-discard"><CODE>unix-line-discard</CODE></A> (<SAMP>C-u</SAMP>)
<DD> Kill  backward  from  point to the beginning of the
line.
<DT> <A NAME="kill-whole-line"><CODE>kill-whole-line</CODE></A>
<DD> Kill all characters on the current line, no  matter
where  the cursor is.  By default, this is unbound.
<DT> <A NAME="kill-word"><CODE>kill-word</CODE></A> (<SAMP>M-d</SAMP>)
<DD> Kill from the cursor to  the  end  of  the  current
word,  or  if between words, to the end of the next
word.  Word boundaries are the same as  those  used
by <A HREF="#forward-word"><CODE>forward-word</CODE></A>.
<DT> <A NAME="backward-kill-word"><CODE>backward-kill-word</CODE></A> (<SAMP>M-Rubout</SAMP>)
<DD> Kill  the  word behind the cursor.  Word boundaries
are the same as those used by <A HREF="#backward-word"><CODE>backward-word</CODE></A>.
<DT> <A NAME="unix-word-rubout"><CODE>unix-word-rubout</CODE></A> (<SAMP>C-w</SAMP>)
<DD> Kill the word behind the cursor, using white  space
as  a  word boundary.  The word boundaries are different
from <A HREF="#backward-kill-word"><CODE>backward-kill-word</CODE></A>.
<DT> <A NAME="delete-horizontal-space"><CODE>delete-horizontal-space</CODE></A>
<DD> Delete  all  spaces  and  tabs  around  point.   By
default, this is unbound.
<DT> <A NAME="yank"><CODE>yank</CODE></A> (<SAMP>C-y</SAMP>)
<DD> Yank  the  top  of the kill ring into the buffer at
the cursor.
<DT> <A NAME="yank-pop"><CODE>yank-pop</CODE></A> (<SAMP>M-y</SAMP>)
<DD> Rotate the kill-ring, and yank the new  top.   Only
works following <A HREF="#yank"><CODE>yank</CODE></A> or <A HREF="#yank-pop"><CODE>yank-pop</CODE></A>.
</DL>

<A NAME="Numeric Arguments">
<H3>Numeric Arguments</H3>
</A>

<DL>
<DT> <A NAME="digit-argument"><CODE>digit-argument</CODE></A> (<SAMP>M-0</SAMP>, <SAMP>M-1</SAMP>, ..., <SAMP>M--</SAMP>)
<DD> Add  this  digit to the argument already accumulating,
or start a new argument.  <SAMP>M--</SAMP>  starts  a  negative
argument.
<DT> <A NAME="universal-argument"><CODE>universal-argument</CODE></A>
<DD> Each  time  this is executed, the argument count is
multiplied by four.  The  argument  count  is  initially
one,  so  executing this function the first
time makes the argument count  four.   By  default,
this is not bound to a key.
</DL>

<A NAME="Completing">
<H3>Completing</H3>
</A>

<DL>
<DT> <A NAME="complete"><CODE>complete</CODE></A> (<SAMP>TAB</SAMP>)
<DD> Attempt  to  perform  completion on the text before
point.  The actual completion performed is application-specific.
<CODE><B>Bash</B></CODE>,  for instance,
attempts  completion  treating the text as a
variable (if the text begins with <CODE>$</CODE>), username  (if
the  text  begins  with  <CODE>~</CODE>),  hostname (if the text
begins with <CODE>@</CODE>), or command (including  aliases  and
functions)  in  turn.   If none of these produces a
match,  filename  completion  is  attempted.   <CODE><B>Gdb</B></CODE>,
on the other hand, allows completion of program functions and
variables, and only  attempts  filename  completion
under certain circumstances.
<DT> <A NAME="possible-completions"><CODE>possible-completions</CODE></A> (<SAMP>M-?</SAMP>)
<DD> List  the  possible  completions of the text before
point.
<DT> <A NAME="insert-completions"><CODE>insert-completions</CODE></A>
<DD> Insert all completions of  the  text  before  point
that   would   have   been   generated   by  <A HREF="#possible-completions"><CODE>possible-completions</CODE></A>.
By default, this is not bound  to
a key.
</DL>

<A NAME="Keyboard Macros">
<H3>Keyboard Macros</H3>
</A>

<DL>
<DT> <A NAME="start-kbd-macro"><CODE>start-kbd-macro</CODE></A> (<SAMP>C-x (</SAMP>)
<DD> Begin  saving the characters typed into the current
keyboard macro.
<DT> <A NAME="end-kbd-macro"><CODE>end-kbd-macro</CODE></A> (<SAMP>C-x )</SAMP>)
<DD> Stop saving the characters typed into  the  current
keyboard macro and save the definition.
<DT> <A NAME="call-last-kbd-macro"><CODE>call-last-kbd-macro</CODE></A> (<SAMP>C-x e</SAMP>)
<DD> Re-execute the last keyboard macro defined, by making the characters in the macro appear as if  typed
at the keyboard.
</DL>

<A NAME="Miscellaneous">
<H3>Miscellaneous</H3>
</A>

<DL>
<DT> <A NAME="re-read-init-file"><CODE>re-read-init-file</CODE></A> (<SAMP>C-x C-r</SAMP>)
<DD> Read  in the contents of your init file, and incorporate any bindings or variable  assignments  found
there.
<DT> <A NAME="abort"><CODE>abort</CODE></A> (<SAMP>C-g</SAMP>)
<DD> Abort the current editing command and ring the terminal's   bell   (subject   to   the   setting   of
<A HREF="#bell-style"><CODE>bell-style</CODE></A>).
<DT> <A NAME="do-uppercase-version"><CODE>do-uppercase-version</CODE></A> (<SAMP>M-a</SAMP>, <SAMP>M-b</SAMP>, ...)
<DD> Run  the command that is bound to the corresponding
uppercase character.
<DT> <A NAME="prefix-meta"><CODE>prefix-meta</CODE></A> (<SAMP>ESC</SAMP>)
<DD> Metafy the next character typed.  <SAMP>ESC f</SAMP> is  equivalent to <SAMP>Meta-f</SAMP>.
<DT> <A NAME="undo"><CODE>undo</CODE></A> (<SAMP>C-_</SAMP>, <SAMP>C-x C-u</SAMP>)
<DD> Incremental  undo,  separately  remembered for each
line.
<DT> <A NAME="revert-line"><CODE>revert-line</CODE></A> (<SAMP>M-r</SAMP>)
<DD> Undo all changes made to this line.  This  is  like
typing  the <A HREF="#undo"><CODE>undo</CODE></A> command enough times to return the
line to its initial state.
<DT> <A NAME="tilde-expand"><CODE>tilde-expand</CODE></A> (<SAMP>M-~</SAMP>)
<DD> Perform tilde expansion on the current word.
<DT> <A NAME="dump-functions"><CODE>dump-functions</CODE></A>
<DD> Print all of the functions and their  key  bindings
to  the readline output stream.  If a numeric argument is supplied, the output is formatted in such a
way that it can be made part of an <i>inputrc</i>
 file.
<DT> <A NAME="emacs-editing-mode"><CODE>emacs-editing-mode</CODE></A> (<SAMP>C-e</SAMP>)
<DD> When  in  <CODE>vi</CODE>  editing mode, this causes a switch to
<CODE>emacs</CODE> editing mode.
<DT> <A NAME="vi-editing-mode"><CODE>vi-editing-mode</CODE></A> (<SAMP>M-C-j</SAMP>)
<DD> When in <CODE>emacs</CODE> editing mode, this causes a switch to
<CODE>vi</CODE> editing mode.
</DL>

<A NAME="Default Key Bindings">
<H2>Default Key Bindings</H2>
</A>

The  following is a list of the default emacs and vi bindings.  Characters with the 8th  bit  set  are  written  as
<SAMP>M-</SAMP><VAR>character</VAR>, and are referred to as <i>metafied</i>
 characters.
The printable ASCII characters not mentioned in  the  list
of  emacs  standard  bindings are bound to the <A HREF="#self-insert"><CODE>self-insert</CODE></A>
function, which just inserts the given character into  the
input  line.   In  vi  insertion  mode, all characters not
specifically mentioned are bound to <A HREF="#self-insert"><CODE>self-insert</CODE></A>.
Characters  assigned to signal generation by <A HREF="stty(1)"><CODE>stty</CODE></A>(1)
or the terminal driver, such as <SAMP>C-Z</SAMP> or <SAMP>C-C</SAMP>,  retain  that  function.
Upper  and lower case <i>metafied</i> characters are bound to the
same function in the emacs mode meta keymap.  The  remaining
characters are unbound, which causes readline to ring
the bell (subject to the setting of the  <A HREF="#bell-style"><CODE>bell-style</CODE></A>  variable).

<A NAME="Key Bindings in Emacs Mode">
<H3>Emacs Mode</H3>
</A>

<DL>
<DT> Emacs Standard bindings
<DD> <PRE>
"C-A"             -&gt;  <A HREF="#beginning-of-line"><CODE>beginning-of-line</CODE></A>
"C-B"             -&gt;  <A HREF="#backward-char"><CODE>backward-char</CODE></A>
"C-D"             -&gt;  <A HREF="#delete-char"><CODE>delete-char</CODE></A>
"C-E"             -&gt;  <A HREF="#end-of-line"><CODE>end-of-line</CODE></A>
"C-F"             -&gt;  <A HREF="#forward-char"><CODE>forward-char</CODE></A>
"C-G"             -&gt;  <A HREF="#abort"><CODE>abort</CODE></A>
"C-H"             -&gt;  <A HREF="#backward-delete-char"><CODE>backward-delete-char</CODE></A>
"C-I"             -&gt;  <A HREF="#complete"><CODE>complete</CODE></A>
"C-J"             -&gt;  <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-K"             -&gt;  <A HREF="#kill-line"><CODE>kill-line</CODE></A>
"C-L"             -&gt;  <A HREF="#clear-screen"><CODE>clear-screen</CODE></A>
"C-M"             -&gt;  <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-N"             -&gt;  <A HREF="#next-history"><CODE>next-history</CODE></A>
"C-P"             -&gt;  <A HREF="#previous-history"><CODE>previous-history</CODE></A>
"C-Q"             -&gt;  <A HREF="#quoted-insert"><CODE>quoted-insert</CODE></A>
"C-R"             -&gt;  <A HREF="#reverse-search-history"><CODE>reverse-search-history</CODE></A>
"C-S"             -&gt;  <A HREF="#forward-search-history"><CODE>forward-search-history</CODE></A>
"C-T"             -&gt;  <A HREF="#transpose-chars"><CODE>transpose-chars</CODE></A>
"C-U"             -&gt;  <A HREF="#unix-line-discard"><CODE>unix-line-discard</CODE></A>
"C-V"             -&gt;  <A HREF="#quoted-insert"><CODE>quoted-insert</CODE></A>
"C-W"             -&gt;  <A HREF="#unix-word-rubout"><CODE>unix-word-rubout</CODE></A>
"C-Y"             -&gt;  <A HREF="#yank"><CODE>yank</CODE></A>
"C-_"             -&gt;  <A HREF="#undo"><CODE>undo</CODE></A>
" " to "/"        -&gt;  <A HREF="#self-insert"><CODE>self-insert</CODE></A>
"0"  to "9"       -&gt;  <A HREF="#self-insert"><CODE>self-insert</CODE></A>
":"  to "~"       -&gt;  <A HREF="#self-insert"><CODE>self-insert</CODE></A>
"C-?"             -&gt;  <A HREF="#backward-delete-char"><CODE>backward-delete-char</CODE></A>
</PRE>
<DT> Emacs Meta bindings
<DD> <PRE>
"<SAMP>M-C-H</SAMP>"           -&gt;  <A HREF="#backward-kill-word"><CODE>backward-kill-word</CODE></A>
"<SAMP>M-C-I</SAMP>"           -&gt;  <A HREF="#tab-insert"><CODE>tab-insert</CODE></A>
"<SAMP>M-C-J</SAMP>"           -&gt;  <A HREF="#vi-editing-mode"><CODE>vi-editing-mode</CODE></A>
"<SAMP>M-C-M</SAMP>"           -&gt;  <A HREF="#vi-editing-mode"><CODE>vi-editing-mode</CODE></A>
"<SAMP>M-C-R</SAMP>"           -&gt;  <A HREF="#revert-line"><CODE>revert-line</CODE></A>
"<SAMP>M-C-Y</SAMP>"           -&gt;  <A HREF="#yank-nth-arg"><CODE>yank-nth-arg</CODE></A>
"<SAMP>M-C-[</SAMP>"           -&gt;  <A HREF="#complete"><CODE>complete</CODE></A>
"<SAMP>M-&amp;</SAMP>"             -&gt;  <A HREF="#tilde-expand"><CODE>tilde-expand</CODE></A>
"<SAMP>M--</SAMP>"             -&gt;  <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-0</SAMP>"             -&gt;  <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-1</SAMP>"             -&gt;  <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-2</SAMP>"             -&gt;  <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-3</SAMP>"             -&gt;  <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-4</SAMP>"             -&gt;  <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-5</SAMP>"             -&gt;  <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-6</SAMP>"             -&gt;  <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-7</SAMP>"             -&gt;  <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-8</SAMP>"             -&gt;  <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-9</SAMP>"             -&gt;  <A HREF="#digit-argument"><CODE>digit-argument</CODE></A>
"<SAMP>M-&lt;</SAMP>"             -&gt;  <A HREF="#beginning-of-history"><CODE>beginning-of-history</CODE></A>
"<SAMP>M-&gt;</SAMP>"             -&gt;  <A HREF="#end-of-history"><CODE>end-of-history</CODE></A>
"<SAMP>M-?</SAMP>"             -&gt;  <A HREF="#possible-completions"><CODE>possible-completions</CODE></A>
"<SAMP>M-B</SAMP>"             -&gt;  <A HREF="#backward-word"><CODE>backward-word</CODE></A>
"<SAMP>M-C</SAMP>"             -&gt;  <A HREF="#capitalize-word"><CODE>capitalize-word</CODE></A>
"<SAMP>M-D</SAMP>"             -&gt;  <A HREF="#kill-word"><CODE>kill-word</CODE></A>
"<SAMP>M-F</SAMP>"             -&gt;  <A HREF="#forward-word"><CODE>forward-word</CODE></A>
"<SAMP>M-L</SAMP>"             -&gt;  <A HREF="#downcase-word"><CODE>downcase-word</CODE></A>
"<SAMP>M-N</SAMP>"             -&gt;  <A HREF="#non-incremental-forward-search-history"><CODE>non-incremental-forward-search-history</CODE></A>
"<SAMP>M-O</SAMP>"             -&gt;  <CODE>arrow-key-prefix</CODE>
"<SAMP>M-P</SAMP>"             -&gt;  <A HREF="#non-incremental-reverse-search-history"><CODE>non-incremental-reverse-search-history</CODE></A>
"<SAMP>M-R</SAMP>"             -&gt;  <A HREF="#revert-line"><CODE>revert-line</CODE></A>
"<SAMP>M-T</SAMP>"             -&gt;  <A HREF="#transpose-words"><CODE>transpose-words</CODE></A>
"<SAMP>M-U</SAMP>"             -&gt;  <A HREF="#upcase-word"><CODE>upcase-word</CODE></A>
"<SAMP>M-Y</SAMP>"             -&gt;  <A HREF="#yank-pop"><CODE>yank-pop</CODE></A>
"<SAMP>M-C-Y</SAMP>"           -&gt;  <A HREF="#yank-nth-arg"><CODE>yank-nth-arg</CODE></A>
"<SAMP>M-C-?</SAMP>"           -&gt;  <CODE>backward-delete-word</CODE>
</PRE>
<DT> Emacs Control-X bindings
<DD> <PRE>
"C-XC-G"          -&gt;  <A HREF="#abort"><CODE>abort</CODE></A>
"C-XC-R"          -&gt;  <A HREF="#re-read-init-file"><CODE>re-read-init-file</CODE></A>
"C-XC-U"          -&gt;  <A HREF="#undo"><CODE>undo</CODE></A>
"C-X("            -&gt;  <A HREF="#start-kbd-macro"><CODE>start-kbd-macro</CODE></A>
"C-X)"            -&gt;  <A HREF="#end-kbd-macro"><CODE>end-kbd-macro</CODE></A>
"C-Xe"            -&gt;  <A HREF="#call-last-kbd-macro"><CODE>call-last-kbd-macro</CODE></A>
"C-XC-?"          -&gt;  <A HREF="#backward-kill-line"><CODE>backward-kill-line</CODE></A>
</PRE>
</DL>

<A NAME="Key Bindings in VI Mode">
<H3>VI Mode bindings</H3>
</A>

<DL>
<DT> VI Insert Mode functions
<DD> <PRE>
"C-D"             -&gt;  <CODE>vi-eof-maybe</CODE>
"C-H"             -&gt;  <A HREF="#backward-delete-char"><CODE>backward-delete-char</CODE></A>
"C-I"             -&gt;  <A HREF="#complete"><CODE>complete</CODE></A>
"C-J"             -&gt;  <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-K"             -&gt;  <A HREF="#kill-line"><CODE>kill-line</CODE></A>
"C-L"             -&gt;  <A HREF="#clear-screen"><CODE>clear-screen</CODE></A>
"C-M"             -&gt;  <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-N"             -&gt;  <A HREF="#next-history"><CODE>next-history</CODE></A>
"C-P"             -&gt;  <A HREF="#previous-history"><CODE>previous-history</CODE></A>
"C-Q"             -&gt;  <A HREF="#quoted-insert"><CODE>quoted-insert</CODE></A>
"C-R"             -&gt;  <A HREF="#reverse-search-history"><CODE>reverse-search-history</CODE></A>
"C-S"             -&gt;  <A HREF="#forward-search-history"><CODE>forward-search-history</CODE></A>
"C-T"             -&gt;  <A HREF="#transpose-chars"><CODE>transpose-chars</CODE></A>
"C-U"             -&gt;  <A HREF="#unix-line-discard"><CODE>unix-line-discard</CODE></A>
"C-V"             -&gt;  <A HREF="#quoted-insert"><CODE>quoted-insert</CODE></A>
"C-W"             -&gt;  <A HREF="#unix-word-rubout"><CODE>unix-word-rubout</CODE></A>
"C-Y"             -&gt;  <A HREF="#yank"><CODE>yank</CODE></A>
"C-["             -&gt;  <CODE>vi-movement-mode</CODE>
" " to "~"        -&gt;  <A HREF="#self-insert"><CODE>self-insert</CODE></A>
"C-?"             -&gt;  <A HREF="#backward-delete-char"><CODE>backward-delete-char</CODE></A>
</PRE>
<DT> VI Command Mode functions
<DD> <PRE>
"C-D"             -&gt;  <CODE>vi-eof-maybe</CODE>
"C-E"             -&gt;  <A HREF="#emacs-editing-mode"><CODE>emacs-editing-mode</CODE></A>
"C-G"             -&gt;  <A HREF="#abort"><CODE>abort</CODE></A>
"C-H"             -&gt;  <A HREF="#backward-char"><CODE>backward-char</CODE></A>
"C-J"             -&gt;  <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-K"             -&gt;  <A HREF="#kill-line"><CODE>kill-line</CODE></A>
"C-L"             -&gt;  <A HREF="#clear-screen"><CODE>clear-screen</CODE></A>
"C-M"             -&gt;  <A HREF="#accept-line"><CODE>accept-line</CODE></A>
"C-N"             -&gt;  <A HREF="#next-history"><CODE>next-history</CODE></A>
"C-P"             -&gt;  <A HREF="#previous-history"><CODE>previous-history</CODE></A>
"C-Q"             -&gt;  <A HREF="#quoted-insert"><CODE>quoted-insert</CODE></A>
"C-R"             -&gt;  <A HREF="#reverse-search-history"><CODE>reverse-search-history</CODE></A>
"C-S"             -&gt;  <A HREF="#forward-search-history"><CODE>forward-search-history</CODE></A>
"C-T"             -&gt;  <A HREF="#transpose-chars"><CODE>transpose-chars</CODE></A>
"C-U"             -&gt;  <A HREF="#unix-line-discard"><CODE>unix-line-discard</CODE></A>
"C-V"             -&gt;  <A HREF="#quoted-insert"><CODE>quoted-insert</CODE></A>
"C-W"             -&gt;  <A HREF="#unix-word-rubout"><CODE>unix-word-rubout</CODE></A>
"C-Y"             -&gt;  <A HREF="#yank"><CODE>yank</CODE></A>
"C-["             -&gt;  <A HREF="#abort"><CODE>abort</CODE></A>
" "               -&gt;  <A HREF="#forward-char"><CODE>forward-char</CODE></A>
"#"               -&gt;  <CODE>vi-comment</CODE>
"$"               -&gt;  <A HREF="#end-of-line"><CODE>end-of-line</CODE></A>
"%"               -&gt;  <CODE>vi-match</CODE>
"&amp;"               -&gt;  <CODE>vi-tilde-expand</CODE>
"*"               -&gt;  <CODE>vi-complete</CODE>
"+"               -&gt;  <CODE>down-history</CODE>
","               -&gt;  <CODE>vi-char-search</CODE>
"-"               -&gt;  <A HREF="#previous-history"><CODE>previous-history</CODE></A>
"."               -&gt;  <CODE>vi-redo</CODE>
"/"               -&gt;  <CODE>vi-search</CODE>
"0"               -&gt;  <A HREF="#beginning-of-line"><CODE>beginning-of-line</CODE></A>
"1" to "9"        -&gt;  <CODE>vi-arg-digit</CODE>
";"               -&gt;  <CODE>vi-char-search</CODE>
"="               -&gt;  <CODE>vi-complete</CODE>
"?"               -&gt;  <CODE>vi-search</CODE>
"@"               -&gt;  <CODE>is undefined</CODE>
"A"               -&gt;  <CODE>vi-append-eol</CODE>
"B"               -&gt;  <CODE>vi-prev-word</CODE>
"C"               -&gt;  <CODE>vi-change-to</CODE>
"D"               -&gt;  <CODE>vi-delete-to</CODE>
"E"               -&gt;  <CODE>vi-end-word</CODE>
"F"               -&gt;  <CODE>vi-char-search</CODE>
"I"               -&gt;  <CODE>vi-insert-beg</CODE>
"N"               -&gt;  <CODE>vi-search-again</CODE>
"P"               -&gt;  <CODE>vi-put</CODE>
"R"               -&gt;  <CODE>vi-replace</CODE>
"S"               -&gt;  <CODE>vi-subst</CODE>
"T"               -&gt;  <CODE>vi-char-search</CODE>
"U"               -&gt;  <A HREF="#revert-line"><CODE>revert-line</CODE></A>
"W"               -&gt;  <CODE>vi-next-word</CODE>
"X"               -&gt;  <A HREF="#backward-delete-char"><CODE>backward-delete-char</CODE></A>
"Y"               -&gt;  <CODE>vi-yank-to</CODE>
"\"               -&gt;  <CODE>vi-complete</CODE>
"^"               -&gt;  <CODE>vi-first-print</CODE>
"_"               -&gt;  <CODE>vi-yank-arg</CODE>
"a"               -&gt;  <CODE>vi-append-mode</CODE>
"b"               -&gt;  <CODE>vi-prev-word</CODE>
"c"               -&gt;  <CODE>vi-change-to</CODE>
"d"               -&gt;  <CODE>vi-delete-to</CODE>
"e"               -&gt;  <CODE>vi-end-word</CODE>
"f"               -&gt;  <CODE>vi-char-search</CODE>
"h"               -&gt;  <A HREF="#backward-char"><CODE>backward-char</CODE></A>
"i"               -&gt;  <CODE>vi-insertion-mode</CODE>
"j"               -&gt;  <A HREF="#next-history"><CODE>next-history</CODE></A>
"k"               -&gt;  <CODE>prev-history</CODE>
"l"               -&gt;  <A HREF="#forward-char"><CODE>forward-char</CODE></A>
"n"               -&gt;  <CODE>vi-search-again</CODE>
"r"               -&gt;  <CODE>vi-change-char</CODE>
"s"               -&gt;  <CODE>vi-subst</CODE>
"t"               -&gt;  <CODE>vi-char-search</CODE>
"u"               -&gt;  <A HREF="#undo"><CODE>undo</CODE></A>
"w"               -&gt;  <CODE>vi-next-word</CODE>
"x"               -&gt;  <CODE>vi-delete</CODE>
"y"               -&gt;  <CODE>vi-yank-to</CODE>
"|"               -&gt;  <CODE>vi-column</CODE>
"~"               -&gt;  <CODE>vi-change-case</CODE>
</PRE>
</DL>

<A NAME="See also">
<H2>See also</H2>
</A>

<UL>
<LI> <EM>The Gnu Readline Library</EM>, Brian Fox and Chet Ramey
<LI> <EM>The Gnu History Library</EM>, Brian Fox and Chet Ramey
<LI> <A HREF="bash(1)"><CODE><B>bash</B></CODE></A>(1)
</UL>

<A NAME="Files">
<H2>Files</H2>
</A>

<DL>
<DT> <A NAME="~/.inputrc"><CODE>~/.inputrc</CODE></A>
<DD> Individual readline initialization file
</DL>

<A NAME="Authors">
<H2>Authors</H2>
</A>

<UL>
<LI> Brian   Fox,   Free  Software  Foundation  (primary
author)<BR>
<TT>bfox@ai.MIT.Edu</TT>
<LI>Chet Ramey, Case Western Reserve University<BR>
<TT>chet@ins.CWRU.Edu</TT>
</UL>

<A NAME="Bug Reports">
<H2>Bug Reports</H2>
</A>

If you find a bug in <EM>readline</EM>, you should report it.   But
first,  you  should make sure that it really is a bug, and
that it appears in the  latest  version  of  the  <EM>readline</EM>
library that you have.
<P>

Once  you have determined that a bug actually exists, mail
a bug report to <TT>bash-maintainers@prep.ai.MIT.Edu</TT>.  If  you
have a fix, you are welcome to mail that as well!  Suggestions
and `philosophical' bug reports  may  be  mailed  to
<TT>bug-bash@prep.ai.MIT.Edu</TT> or posted to the Usenet newsgroup
<TT>gnu.bash.bug</TT>.

Comments and  bug  reports  concerning  this  manual  page
should be directed to <TT>chet@ins.CWRU.Edu</TT>.

<A NAME="Bugs">
<H2>Bugs</H2>
</A>

It's too big and too slow.
<P>

<HR>

<ADDRESS>READLINE manual page<BR>
Bruno Haible &lt;haible@clisp.cons.org&gt;
</ADDRESS>
<P>
Last modified: 11 January 1998.

</BODY>

