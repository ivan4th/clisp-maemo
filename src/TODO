This file contains suggestions for further work.

MUST-FIX BEFORE NEXT RELEASE
============================

Finish MOP. (Bruno)

Defstruct accessors are defined twice, which leads to warnings. (Bruno)

Contagion warnings emitted by many floating-point operations. (Bruno)

Fix modules/exporting.lisp :
(eval-when (load compile eval)
  (defconstant FOO 10))
does not export FOO. (Bruno)


MUST-FIX BEFORE RELEASE 2.35
============================

Many pretty-printer test failures.
(Sam - but Bruno has to fix the risky-test in iofkts.tst first)


URGENT PROBLEMS
===============

Should handle these soon.


Embeddability: additional API in spvw.d; global error handler; example.


CLISP_LANGUAGE=german LC_ALL=C clisp -q
> (/ 0)
=> endless loop
*** - Character #\u00F6 cannot be represented in the character set
      CHARSET:ASCII


Fix unintuitive behaviour of REPL introduced on 2003-01-21:
[1]> (read-char)
abcdef
#\a
[2]>
*** - EVAL: variable BCDEF has no value
Mögliche Optionen:
USE-VALUE      :R1      Sie dürfen einen Ersatzwertfür BDEF eingeben.
STORE-VALUE    :R2      Sie dürfen einen neuen Wert für BDEF eingeben.
ABORT          :R3      ABORT

Break 1 [3]>


Make the *KEYBOARD-STREAM* recognize all kinds of function keys in Linux
console and xterm again.


Remove all unnecessary MACROEXPAND calls from compiler.lisp. When a macro
is also a special form or a compiler macro, the special form handler or
the compiler should be used, not the regular macro, for efficiency reasons.
Use macroexpand-form instead.


Reentrancy: remove the static filestatus variable from pathname.d.


Better error checking in get-setf-expansion for long defsetf


for Emacs: GC root macro, YETANOTHER macro


(let ((x 0)) (declare (special x)) (let ((x 1)) (let ((y x)) (declare (special x)) y)))
(let ((x 0)) (declare (special x)) (let ((x 1)) (let ((y x) (x 5)) (declare (special x)) y)))
(let ((x 0)) (declare (special x)) (let ((x 1)) (let* ((y x) (x 5)) (declare (special x)) y)))
should all return 1, not 0.
Scope von declare-special x:
LET ohne x:  free: only the body, bind last
LET* ohne x: free: only the body, bind last
LET mit x:  bound: only the body, bind last
LET* mit x: bound: ab der nächsten initform, bind after corresponding initform
LAMBDA: erst alle Argumente auswerten, dann erst die vorhandenen Parameter
binden, dann jeweils initform und binden.


(directory "/proc/self/*" :full t )
((#P"/proc/self/status" #P"/proc/self/status" (6 44 0 1 4 1999) 0)
  (#P"/proc/self/mem" #P"/proc/self/mem" (6 44 0 1 4 1999) 0)
  (#P"/proc/self/environ" #P"/proc/self/environ" (6 44 0 1 4 1999) 0)
  (#P"/proc/self/cmdline" #P"/proc/self/cmdline" (6 44 0 1 4 1999) 0)
  (#P"/proc/self/stat" #P"/proc/self/stat" (6 44 0 1 4 1999) 0)
  (#P"/proc/self/statm" #P"/proc/self/statm" (6 44 0 1 4 1999) 0)
  (#P"/proc/self/maps" #P"/proc/self/maps" (6 44 0 1 4 1999) 0)


(directory "/proc/self/fd/*")

stat("/proc", {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0
stat("/proc/self", {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0
stat("/proc/self/fd", {st_mode=S_IFDIR|0500, st_size=0, ...}) = 0
stat("/proc/self/fd/.", {st_mode=S_IFDIR|0500, st_size=0, ...}) = 0
open("/proc/self/fd/.", O_RDONLY)       = 6
fcntl(6, F_SETFD, FD_CLOEXEC)           = 0
getdents(6, /* 9 entries */, 1024)      = 112
stat("/proc/self/fd/0", {st_mode=S_IFCHR|0620, st_rdev=makedev(3, 2), ...}) = 0
lstat("/proc/self/fd/0", {st_mode=S_IFLNK|0700, st_size=64, ...}) = 0
readlink("/proc/self/fd/0", "[0303]:39982", 64) = 12
readlink("/proc/self/fd/0", "[0303]:39982", 12) = 12
readlink("/proc", 0xbfffd498, 4094)     = -1 EINVAL (Invalid argument)
readlink("/proc/self", "1108", 4094)    = 5
lstat("/proc/1108/fd/[0303]:39982", 0x8138260) = -1 ENOENT (No such file or directory)

Problem is the call to assure_dir_exists(TRUE,FALSE); where in fact not
all links are resolved in the directory!


print-readably for interpreted closures and #<specdecl> and #<unbound> ?


parse_namestring: split_name_type(1), und bei make_pathname
Klein->Großschreibung umwandeln, so dass (make-pathname :type "fas") immer geht.


If you (TRACE generic-function) and then reload the file defining that
function, you get an error saying that #<CLOSURE TRACED-xxx> is not a generic
function.


clean up and modularize spvw.d



MAYBE
=====

Still have to think about these, whether they are good ideas or not.


Add highlight/underline/etc. capability to the output side of *terminal-io*.


Optimize REPLACE so that (replace v v :start1 10 :end1 30 :start2 0 :end2 20)
doesn't cons. (vectors only, not lists)


CLOSE :ABORT T maybe do something on file streams.


Having two different handlings of Ctrl-C (once as a serious-condition, once
directly through tast_break(), bypassing ERROR and SIGNAL) is horrible.
Introduce a class of SERIOUS-CONDITION and then remove BATCHMODE-BREAK-DRIVER.


Distribute impnotes.html in the form of CLAHS, as an annotation against
Harlequin's HyperSpec. See http://clisp.cons.org/~haible/clahs/.


FFI: Introduce a macro like CMU's FFI:ADDR


FFI: Actually support :language :cc/:gcc by passing appropriate flags
to the avcall/vacall macros. The default should be the same compiler
as the one used to compile clisp.


(read-char *keyboard-input*) is still not perfect. Under Linux, it
returns the following key sequences for some keystrokes:

Under xterm:
Shift F1 --> F11
Shift F2 --> F12
Shift F3 --> Escape [ 2 5 ~
Shift F4 --> Escape [ 2 6 ~
Shift F5 --> Escape [ 2 8 ~
Shift F6 --> Escape [ 2 9 ~
Shift F7 --> Escape [ 3 1 ~
Shift F8 --> Escape [ 3 2 ~
Shift F9 --> F9
Shift F10 --> F10
Shift F11 --> F11
Shift F12 --> F12

Under console:
Shift F1 --> F11
Shift F2 --> F12
Shift F3 --> Escape [ 2 5 ~
Shift F4 --> Escape [ 2 6 ~
Shift F5 --> Escape [ 2 8 ~
Shift F6 --> Escape [ 2 9 ~
Shift F7 --> Escape [ 3 1 ~
Shift F8 --> Escape [ 3 2 ~
Shift F9 --> Escape [ 3 3 ~
Shift F10 --> Escape [ 3 4 ~
Shift F11 --> F11
Shift F12 --> F12
Ctrl-Alt-Q --> nothing at all


Looks at GCL CLCS (debugger.lsp top-patches.lsp condition-definitions.lsp)
whether it contains something clisp could profit from.


Debugger (user1.lisp, debug.d): Implement backtrace-? commands with a limit,
such that  BACKTRACE-1 20  will show the 20 newest frames. Good for people
without a "cmdtool" or an xterm with logging.


More CLtL2 compliance:
; List of X3J13 votes that may be implemented in CLISP
;
; Number: from CLtL2, Index of X3J13 Votes.
; Status: indicates whether CLISP currently supports code that makes use of
; this vote.
;
; Number Title                               Status          Files affected
;
;  <24>  compiler diagnostics                no              compiler.lisp
;  <85>  FORMAT & pretty print               yes             format.lisp
;                                            no: ~E, ~F, ~G, ~$ also bind *PRINT-BASE* to 10 and *PRINT-RADIX* to NIL
; <110>  LOAD & objects                      no              loadform.lisp
; <127>  package function consistency        no              package.d
; <129>  pathname: component value           no              pathname.d
; <133>  pathname: subdirectory list         no              pathname.d
; <134>  pathname: symbol                    no              pathname.d, stream.d
; <136>  pathname: unspecific component      no              pathname.d
; <139>  pretty-print interface              no              xp.lisp
; <153>  REMF & destruction: unspecified     no for NRECONC  list.d
;                                            yes for anything else


The completion in user2.lisp does bad things with respect to upper case and
lower case of symbols. Assume the symbols |TMP|, |TMP structure class|
are interned. Then type a tab in the following situations:
> (symbol-plist '\Tmp
> 'tm
> '|


Optimize the compiler or the LOOP expander so that
  (macroexpand '(loop for (a b c) = (multiple-value-list (foo))))
contains
  (MULTIPLE-VALUE-SETQ (A B C) (FOO))


NOT TO DO
=========

These have been in my mind, but are probably bad ideas.


upgrade to newest CLN, but still big-endian and without gmp

intgcd

* Speed up the functions `cl_I gcd (const cl_I&, const cl_I&)' and
  `cl_I xgcd (const cl_I&, const cl_I&, cl_I*, cl_I*)' by a factor
  of 1.5. Simple trick.
Why is there no cl_gcd_double_threshold in xgcd, only in gcd??

lfloat

* Speed up multiplication and division of large long-floats by small integers.

realtran

* Speed up the internal computation of ln(2) and ln(10) by about 20%.

* Speed up the computation of exp (for 1000 digits or more) by about 10%.

* Speed up the computation of the elementary transcendental functions:
  exp, sinh, cosh, asinh, atanh (for 100 digits) by about 30%,
  log (for 100 digits) by about 25%,
  sin, cos (for 1000 or 10000 digits) by about 20%,
  asin, acos, atan (for 1000 digits) by about 25%.

* Speed up the computation of pi, e, exp, log, sin, cos, tan, sinh, cosh, tanh,
  asin, acos, atan, asinh, acosh, atanh.
  All of them are now computed with asymptotically fast algorithms, of
  bit complexity O(log(N)^2*M(N)) = O(N^(1+epsilon)) for N digits.

It's not worth the effort: Most people really interested in fast numerics are
already using CLN, NTL, or a similar library. CLISP is already the champion
among the Common Lisp implementations regarding bignum performance.


Declaration  extern maygc ...

You can't put this declaration into a C macro definition. Therefore the
right place for it is still the comment.


Block the signals SIGHUP SIGPIPE SIGTERM SIGXCPU SIGXFSZ during GC, and
when they occur outside of GC, do a quit(1); .

Programs that deal too much with signals tend to be unfriendly. I hate
programs which stay alive when I try to kill them.


CLtL2 issue
; <162>  sharp-comma confusion               no              io.d

Backward compatibility to CLtL2. Doesn't cost much.


CLtL2 issue
; <174>  syntactic environment access        no

It never made it into ANSI CL.


CLtL2 issue
; <176>  :TEST-NOT, -IF-NOT                  no              sequence.d, list.d

It's a bad idea because REMOVE-IF-NOT is a kind of "positive filter", which
is more confusing when expressed as REMOVE of COMPLEMENT. Also, COMPLEMENT
is harder to understand than XXX-IF-NOT because COMPLEMENT is a function
returning a function.

