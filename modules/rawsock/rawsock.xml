<?xml version="1.0" encoding="UTF-8"?>

<section id="rawsock"><title>Raw Socket Access.</title>

<para>This is the raw socket interface, as described in
 <filename role="unix">sys/socket.h</filename>.
Sockets are represented by their &fixnum-t; &file-des;s.</para>

<simpara>When this module is present, &features-var; contains the
 symbol <constant>:RAWSOCK</constant>.</simpara>

<warning id="rawsock-use-sockets"><title>Use &socket-stream; instead!</title>
 <simpara>This interface is very low-level, and you probably do not need
 it - unless you are doing something <emphasis>very</emphasis> unusual.
 If you are interested in TCP/IP (Internet) stream sockets, you should use
 &socket-stream;s, &not-e; this package.</simpara></warning>

<warning id="rawsock-not-streams"><title>Do &not-e; use &make-stream;!</title>
 <simpara>You can turn such a raw socket into a usual lisp &stream-t;
  using &make-stream;, but you should be <emphasis>extremely</emphasis>
  careful with such dubious actions!  See the &clisp-devel;
  <ulink url="http://sourceforge.net/mailarchive/message.php?msg_id=7203955"
         >mailing list archives</ulink> for more details.
  Note that &make-stream; will duplicate the &file-des;
  (using <function role="unix">dup</function>),
  so you <emphasis>still</emphasis> have to &close; the original raw socket.
</simpara></warning>

<para>We implement access to
 <simplelist columns="4">
  <member><function role="unix">accept</function></member>
  <member><function role="unix">bind</function></member>
  <member><function role="unix">connect</function></member>
  <member><function role="unix">getpeername</function></member>
  <member><function role="unix">getsockname</function></member>
  <member><function role="unix">htonl</function></member>
  <member><function role="unix">htons</function></member>
  <member><function role="unix">listen</function></member>
  <member><function role="unix">ntohl</function></member>
  <member><function role="unix">ntohs</function></member>
  <member><function role="unix">recv</function></member>
  <member><function role="unix">recvfrom</function></member>
  <member><function role="unix">recvmsg</function></member>
  <member><function role="unix">send</function></member>
  <member><function role="unix">sendmsg</function></member>
  <member><function role="unix">sendto</function></member>
  <member><function role="unix">sockatmark</function></member>
  <member><function role="unix">socket</function></member>
  <member><function role="unix">socketpair</function></member></simplelist>
 using same-named lisp functions in package
 <quote role="package">RAWSOCK</quote>.
 Additionally,<itemizedlist>
  <listitem><simpara><function>RAWSOCK:SOCK-READ</function>
    calls <function role="unix">read</function>;</simpara></listitem>
  <listitem><simpara><function>RAWSOCK:SOCK-WRITE</function>
    calls <function role="unix">write</function>;</simpara></listitem>
  <listitem><simpara><function>RAWSOCK:SOCK-CLOSE</function>
    calls <function role="unix">close</function>.</simpara></listitem>
</itemizedlist></para>

<variablelist id="rawsock-args"><title>Common arguments</title>
<varlistentry><term><type>void*</type> &buf-r;</term>
 <listitem><simpara>A &unsigned-byte-vec;.  You do not need to supply its
   length because Lisp can determine it itself.  The vector may be
   adjustable and have a fill pointer.</simpara></listitem></varlistentry>
<varlistentry><term><type>int</type> &sock-r;</term>
 <listitem><simpara>An &integer-t;.</simpara></listitem></varlistentry>
<varlistentry><term><type>int</type> <replaceable>family</replaceable></term>
 <term><type>int</type> <replaceable>domain</replaceable></term>
 <listitem><simpara>A &nil; (stands for <constant>AF_UNSPEC</constant>),
   &integer-t;, or a platform-specific keyword, e.g.,
   <constant>:INET</constant> stands for <constant>AF_INET</constant>.
</simpara></listitem></varlistentry>
<varlistentry><term><type>int</type> <replaceable>type</replaceable></term>
 <listitem><simpara>A &nil; (stands for <constant>SOCK_STREAM</constant>),
   &integer-t;, or a platform-specific keyword, e.g.,
   <constant>:DGRAM</constant> stands for <constant>SOCK_DGRAM</constant>.
</simpara></listitem></varlistentry>
<varlistentry><term><type>int</type> <replaceable>protocol</replaceable></term>
 <listitem><simpara>A &nil; (stands for 0), &integer-t;, or a
   platform-specific keyword, e.g., <constant>:ARP</constant> stands
   for <constant>ETH_P_ARP</constant>.</simpara></listitem></varlistentry>
<varlistentry><term><type>int</type> <replaceable>flags</replaceable></term>
 <listitem><simpara>This &c-lang; argument corresponds to keyword
   arguments to the Lisp functions.  E.g., <function>rawsock:send</function>
   accepts <constant>:OOB</constant> and <constant>EOR</constant> arguments,
   while <function>rawsock:recv</function> accepts <constant>PEEK</constant>,
   <constant>OOB</constant> and <constant>WAITALL</constant>.
</simpara></listitem></varlistentry>
<varlistentry><term><type>struct sockaddr</type> &addr-r;</term>
 <listitem><simpara>An object returned by
   <link linkend="make-sockaddr"><function>MAKE-SOCKADDR</function></link>.
   You do not need to supply its length because Lisp can determine it itself.
</simpara></listitem></varlistentry>
</variablelist>

<note id="rawsock-plat-dep-constants"><title>Platform-dependent Keywords</title>
<para>One can extract the list of acceptable platform-dependent
 keywords for, e.g., socket domain using the following code:
<programlisting language="lisp">
 (&block; &nil;
   (&handler-bind; ((&type-error-t;
                    (&lambda-m; (c)
                      (&format; &t; "~&amp;error: ~A~%" c)
                      (&return; (&cddr; (&third; (&type-error-expected-type; c)))))))
     (rawsock:socket "bad" &nil; &nil;)))
</programlisting></para></note>

<para>The interface to <function role="unix">getsockopt</function>
 and <function role="unix">setsockopt</function> is available via
 the &setf;able function
 <code>(RAWSOCK:SOCKET-OPTION &sock-r; &name-r; &key-amp; :LEVEL)</code>
 which returns and sets individual (for specific option &name-r;
 and <replaceable>level</replaceable>) and multiple (when &name-r; is
 &nil; and/or <replaceable>level</replaceable> is &all-k;) options.
 (See also &so-opt;.)</para>

<para>We do not interface to <function role="unix">select</function>
 or <function role="unix">poll</function>,
 they are available through &so-status;.</para>

<para>We do not interface to <function role="unix">shutdown</function>,
 it is available through &sost-shut;.</para>

<para>We do not interface to <function role="unix">gethostbyname</function>
 or <function role="unix">gethostbyaddr</function>,
 they are available through &resolve-host;.</para>

<variablelist id="rawsock-add-on"><title>Additional Functions</title>
 <varlistentry><term><code>(RAWSOCK:CONVERT-ADDRESS
    <replaceable>family</replaceable> &addr-r;)</code></term>
  <listitem><simpara>convert between &string-t; and &integer-t; IP
    &addr-r; representations using <function role="unix">inet_addr</function>,
    <function role="unix">inet_ntoa</function>,
    <function role="unix">inet_ntop</function>,
    or <function role="unix">inet_pton</function>.
 </simpara></listitem></varlistentry>
 <varlistentry id="make-sockaddr"><term><code>(RAWSOCK:MAKE-SOCKADDR
    <replaceable>family</replaceable> &data-r;)</code></term>
  <listitem><simpara>create a <type>sockaddr</type> object.
 </simpara></listitem></varlistentry>
 <varlistentry><term><code>(RAWSOCK:SOCKADDR-FAMILY &addr-r;)</code></term>
  <listitem><simpara>return the numeric family of the
    <type>sockaddr</type> object.</simpara></listitem></varlistentry>
 <varlistentry><term><code>(RAWSOCK:SOCKADDR-DATA &addr-r;)</code></term>
  <listitem><simpara>return a &fresh; &vector-t; displaced to the
    <structfield>data</structfield> field of the
    <type>sockaddr</type> object.</simpara>
   <warning><simpara>Modifying this &vector-t;'s content will modify the
     &addr-r; argument data!</simpara></warning></listitem></varlistentry>
 <varlistentry><term><code>(RAWSOCK:OPEN-UNIX-SOCKET
    &path-r; &optional-amp; &type-r;)</code></term>
  <listitem><simpara>open a &unix; socket special file.
 </simpara></listitem></varlistentry>
 <varlistentry><term><code>(RAWSOCK:MAKE-MSGHDR &data-r;)</code></term>
  <listitem><simpara>Create a <type>RAWSOCK:MSGHDR</type> object for
    <function role="unix">sendmsg</function> and
    <function role="unix">recvmsg</function>.
 </simpara></listitem></varlistentry>
 <varlistentry>
  <term><code>(RAWSOCK:IPCSUM &buf-r;)</code></term>
  <term><code>(RAWSOCK:ICMPCSUM &buf-r;)</code></term>
  <term><code>(RAWSOCK:TCPCSUM &buf-r;)</code></term>
  <term><code>(RAWSOCK:UDPCSUM &buf-r;)</code></term>
  <listitem><simpara>Compute the appropriate protocol checksum.
 </simpara></listitem></varlistentry>
 <varlistentry><term><code>(RAWSOCK:CONFIGDEV &sock-r; &name-r; &addr-r;
    &key-amp; <replaceable>promisc</replaceable>
    <replaceable>noarp</replaceable>)</code></term>
  <listitem><simpara>Set some socket options and IP &addr-r;
  with <function role="unix">ioctl</function>.
 </simpara></listitem></varlistentry>
</variablelist>

</section>
