<?xml version="1.0" encoding="UTF-8"?>

<section id="regexp"><title>&clisp; &regexp-pac; module</title>

<para>The &regexp-pac; module implements the
 <ulink url="regexp.html">POSIX regular expressions</ulink>
by calling the standard &c-lang; system facilities.
The syntax of these regular expressions is described in many places,
such as your local &regex-h; manual and &emacs; info pages.</para>

<para>The &regexp-pac; package exports the following 9 symbols:</para>

<simplelist type="horiz" columns="3">
 <member>&re-match;</member>
 <member>&re-match-start;</member>
 <member>&re-match-end;</member>
 <member>&re-match-string;</member>
 <member>&re-regexp-quote;</member>
 <member>&re-regexp-compile;</member>
 <member>&re-regexp-exec;</member>
 <member>&re-regexp-split;</member>
 <member>&re-with-loop-split;</member>
</simplelist>

<variablelist id="re-api"><title>API</title>
<varlistentry id="re-match"><term><literal
    role="sexp">(&re-match; &pattern-r; &string-r; &key-amp;
   (&start-k; 0) &end-k; &re-cflags-opts; &re-eflags-opts;)</literal></term>
 <listitem><para>This macro returns as first value a &match-t; structure
  containing the indices of the start and end of the first match for the
  regular expression &pattern-r; in &string-r;;
  or &nil; if there is no match.
  Additionally, a &match-t; structure is returned for every matched
  <literal>"\(...\)"</literal> group in &pattern-r;, in the
  order that the open parentheses appear in &pattern-r;.
  If &start-r; is non-&nil;, the search starts at that index in &string-r;.
  If &end-r; is non-&nil;, only <literal role="sexp">(&subseq;
  &string-r; &start-r; &end-r;)</literal> is considered.
  <example id="ex-re-match"><title>&re-match;</title>
   <programlisting>
    (&re-match; "quick" "The quick brown fox jumped quickly.")
     <literal role="sexp">#S(&match-t; :START 4 :END 9)</literal>
    (&re-match; "quick" "The quick brown fox jumped quickly." :start 8)
     <literal role="sexp">#S(&match-t; :START 27 :END 32)</literal>
    (&re-match; "quick" "The quick brown fox jumped quickly." :start 8 :end 30)
     &nil;
    (&re-match; "\\([a-z]*\\)[0-9]*\\(bar\\)" "foo12bar")
     <literal role="sexp">#S(&match-t; :START 0 :END 8) ;</literal>
     <literal role="sexp">#S(&match-t; :START 0 :END 3) ;</literal>
     <literal role="sexp">#S(&match-t; :START 5 :END 8)</literal>
  </programlisting></example>
</para></listitem></varlistentry>

<varlistentry id="re-match-start"><term><literal
    role="sexp">(&re-match-start; &match-r;)</literal></term>
 <listitem><simpara>Extracts the start index of &match-r;; &setf;-able.
 </simpara></listitem></varlistentry>

<varlistentry id="re-match-end"><term><literal
    role="sexp">(&re-match-end; &match-r;)</literal></term>
 <listitem><simpara>Extracts the end index of &match-r;; &setf;-able.
</simpara></listitem></varlistentry>

<varlistentry id="re-match-string"><term><literal
    role="sexp">(&re-match-string; &string-r; &match-r;)</literal></term>
 <listitem><simpara>Extracts the substring of &string-r; corresponding
  to the given pair of start and end indices of &match-r;.
  The result is shared with &string-r;.
  If you want a freshly consed &string-t;, use &copy-seq; or
  <literal role="sexp">(&coerce; (&re-match-string; ...)
  '&simple-string-t;)</literal>.
</simpara></listitem></varlistentry>

<varlistentry id="re-regexp-quote"><term><literal
    role="sexp">(&re-regexp-quote; &string-r; &optional-amp;
   <replaceable>extended</replaceable>)</literal></term>
 <listitem><para>This function returns a regular expression string
  that matches exactly &string-r; and nothing else.
  This allows you to request an exact string match when calling a
  function that wants a regular expression.
  <example id="ex-re-quote"><title>&re-regexp-quote;</title>
   <programlisting>
    (regexp-quote "^The cat$")
     <returnvalue>"\\^The cat\\$"</returnvalue>
   </programlisting></example>
  One use of &re-regexp-quote; is to combine an exact string match with
  context described as a regular expression.
  When <replaceable>extended</replaceable> is non-&nil;, also
  quote <keysym>#\+</keysym> and <keysym>#\?</keysym>.
</para></listitem></varlistentry>

<varlistentry id="re-regexp-compile"><term><literal
    role="sexp">(&re-regexp-compile; &string-r; &key-amp;
   &re-cflags-opts;)</literal></term>
 <listitem><simpara>Compile the regular expression &string-r; into an
  object suitable for &re-regexp-exec;.</simpara></listitem></varlistentry>

<varlistentry id="re-regexp-exec"><term><literal
    role="sexp">(&re-regexp-exec; &pattern-r; &string-r; &key-amp;
     (&start-k; 0) &end-k; &re-eflags-opts;)</literal></term>
 <listitem><simpara>Execute the &pattern-r;, which must be a compiled
   regular expression returned by &re-regexp-compile;, against the
   appropriate portion of the &string-r;.</simpara>
  <simpara>Negative &end-r; means <literal role="sexp">(&plus; (&length;
    &string-r;) &end-r;)</literal></simpara>
  <simpara>Returns &match-t; structures as multiple values (one for each
   subexpression which successfully matched and one for the whole pattern),
   unless <literal>:BOOLEAN</literal> was non-&nil;, in which case
   return &t; as an indicator of success, but do not allocate anything.
</simpara></listitem></varlistentry>

<varlistentry id="re-regexp-split"><term><literal
    role="sexp">(&re-regexp-split;  &pattern-r; &string-r; &key-amp;
     (&start-k; 0) &end-k; &re-cflags-opts; &re-eflags-opts;)</literal></term>
 <listitem><simpara>Return a list of substrings of &string-r; (all
  sharing the structure with &string-r;) separated by &pattern-r; (a
  regular expression string or a return value of &re-regexp-compile;)
 </simpara></listitem></varlistentry>

<varlistentry id="re-with-loop-split"><term><literal
    role="sexp">(&re-with-loop-split; (&var-r; &stream-r; &pattern-r;
     &key-amp; (&start-k; 0) &end-k; &re-cflags-opts; &re-eflags-opts;)
     &body-amp; &body-r;)</literal></term>
 <listitem><simpara>Read lines from &stream-r;, split them with
  &re-regexp-split; on &pattern-r;, and bind the resulting list to
  &var-r;.</simpara></listitem></varlistentry>

<varlistentry id="re-cflags"><term>&re-cflags-opts;</term>
 <listitem><simpara>These options control compilation of a pattern.
   You can specify <replaceable>cflags</replaceable> directly by
   combining <constant>REGEXP::REG_EXTENDED</constant>,
   <constant>REGEXP::REG_ICACE</constant>,
   <constant>REGEXP::REG_NEWLINE</constant>, and
   <constant>REGEXP::REG_NOSUB</constant>.
   See &regex-h; for their meaning.
</simpara></listitem></varlistentry>

<varlistentry id="re-eflags"><term>&re-eflags-opts;</term>
 <listitem><simpara>These options constrol execution of a pattern.
   You can specify <replaceable>eflags</replaceable> directly by
   combining <constant>REGEXP::REG_NOTBOL</constant>, and
   <constant>REGEXP::REG_NOTEOL</constant>.
   See &regex-h; for their meaning.
</simpara></listitem></varlistentry>

<varlistentry id="re-matcher"><term>&re-matcher;</term>
 <listitem><simpara>A valid value for &apropos-matcher;.
</simpara></listitem></varlistentry>

</variablelist>

<para>The following code computes the number of people who use a
 particular shell:
<programlisting>
(&defpackage; "REGEXP-TEST" (:use "LISP" "REGEXP"))
(&in-package; "REGEXP-TEST")
(let ((h (make-hash-table :test #'equal :size 10)) (n 0))
  (with-open-file (f "/etc/passwd")
    (with-loop-split (s f ":")
      (incf (gethash (seventh s) h 0))))
  (with-hash-table-iterator (i h)
    (loop (multiple-value-bind (r k v) (i)
            (unless r (return))
            (format t "[~d] ~s~30t== ~5:d~%" (incf n) k v)))))
</programlisting></para>

<para>For comparison, the same can be done by the following &perl;:
<programlisting>
#!/usr/local/bin/perl -w

use diagnostics;
use strict;

my $IN = $ARGV[0];
open(INF,"&lt; $IN") || die "$0: cannot read file [$IN]: $!\n;";
my %hash;
while (&lt;INF&gt;) {
  chop;
  my @all = split($ARGV[1]);
  my $shell = ($#all &gt;= 6 ? $all[6] : "");
  if ($hash{$shell}) { $hash{$shell} ++; }
  else { $hash{$shell} = 1; }
}
my $ii = 0;
for my $kk (keys(%hash)) {
  print "[",++$ii,"] \"",$kk,"\"  --  ",$hash{$kk},"\n";
}
close(INF);
</programlisting></para>

</section>
