<?xml version="1.0" encoding="UTF-8"?>

<chapter id="mop-chap"><title>Meta-Object Protocol</title>
<subtitle>Adapted from chapters 5 and 6 of &amop;.</subtitle>

<section id="mop-intro"><title>Introduction</title>

<para>The &clos; specification (&ansi-cl; Chanpter 7) describes the
standard Programmer Interface for the &cl; Object System (&clos;).  This
document extends that specification by defining a metaobject protocol
for &clos; - that is, a description of &clos; itself as an extensible
&clos; program.  In this description, the fundamental elements of &clos;
programs (classes, slot definitions, generic functions, methods,
specializers and method combinations) are represented by first-class
objects.  The behavior of &clos; is provided by these objects, or, more
precisely, by methods specialized to the classes of these objects.
</para>

<para>Because these objects represent pieces of &clos; programs, and
because their behavior provides the behavior of the &clos; language
itself, they are considered meta-level objects or metaobjects.  The
protocol followed by the metaobjects to provide the behavior of &clos;
is called the &clos; Metaobject Protocol (MOP).</para>

</section>

<section id="metaobjects"><title>Metaobjects</title>

<para>For each kind of program element there is a corresponding
 <firstterm>basic metaobject class
  <indexterm id="ba-mo-cl" significance="preferred">
   <primary>metaobject class</primary><secondary>basic</secondary>
 </indexterm></firstterm>.
These are the classes: &class;, &slot-definition-t;,
&generic-function-t;, &method-t; and &method-combination-t;.
A <firstterm>metaobject class<indexterm id="mo-cl" significance="preferred">
   <primary>metaobject class</primary></indexterm></firstterm>
is a subclass of exactly one of these classes.
The results are undefined if an attempt is made to define a &class;
that is a subclass of more than one basic metaobject class.
A <firstterm>metaobject<indexterm id="mop-mo" significance="preferred">
   <primary>metaobject</primary></indexterm></firstterm>
is an instance of a metaobject class.</para>

<para>Each metaobject represents one program element.  Associated with
each metaobject is the information required to serve its role.  This
includes information that might be provided directly in a user interface
macro such as &defclass; or &defmethod;.  It also includes information
computed indirectly from other metaobjects such as that computed from
class inheritance or the full set of methods associated with a generic
function.</para>

<para>Much of the information associated with a metaobject is in the
form of connections to other metaobjects.  This interconnection means
that the role of a metaobject is always based on that of other
metaobjects.  As an introduction to this interconnected structure, this
section presents a partial enumeration of the kinds of information
associated with each kind of metaobject.  More detailed information is
presented later.</para>

<section id="mo-classes"><title>Classes</title>

<para>A <firstterm>class metaobject
  <indexterm id="class-mo" significance="preferred">
   <primary>metaobject</primary><secondary>class</secondary>
 </indexterm></firstterm>
determines the structure and the default behavior of its instances.
The following information is associated with class metaobjects:

<itemizedlist>
<listitem><simpara>The name, if there is one, is available as an object.
</simpara></listitem>
<listitem><simpara>The direct subclasses, direct superclasses and class
  precedence list are available as lists of class metaobjects.
</simpara></listitem>
<listitem><simpara>The slots defined directly in the class are available
  as a list of direct slot definition metaobjects.  The slots which are
  accessible in instances of the class are available as a list of
  effective slot definition metaobjects.</simpara></listitem>
<listitem><simpara>The methods which use the class as a specializer, and
  the generic functions associated with those methods are available as
  lists of method and generic function metaobjects respectively.
</simpara></listitem>
&doc-li;</itemizedlist></para>
</section>

<section id="mo-slot-defs"><title>Slot Definitions</title>

<para>A <firstterm>slot definition metaobject
  <indexterm id="slot-def-mo" significance="preferred">
   <primary>metaobject</primary><secondary>slot definition</secondary>
 </indexterm></firstterm>
 contains information about the definition of a slot.
There are two kinds of slot definition metaobjects.
A <emphasis>direct</emphasis> slot definition metaobject is used to
 represent the direct definition of a slot in a class.
This corresponds roughly to the slot specifiers found in &defclass; forms.
An <emphasis>effective</emphasis> slot definition metaobject is used to
 represent information, including inherited information, about a slot
 which is accessible in instances of a particular class.</para>

<para>Associated with each class metaobject is a list of direct slot
definition metaobjects representing the slots defined directly in the
class.  Also associated with each class metaobject is a list of
effective slot definition metaobjects representing the set of slots
accessible in instances of that class.</para>

<para>The following information is associated with both direct and
effective slot definitions metaobjects:
<itemizedlist>
<listitem><simpara>The name, allocation, and type are available as forms
  that could appear in a &defclass; form.</simpara></listitem>
<listitem><simpara>The initialization form, if there is one, is
  available as a form that could appear in a &defclass; form.  The
  initialization form together with its lexical environment is available
  as a function of no arguments which, when called, returns the result
  of evaluating the initialization form in its lexical environment. This
  is called the <emphasis>initfunction</emphasis> of the slot.
</simpara></listitem>
<listitem><simpara>The slot filling initialization arguments are
  available as a list of symbols.</simpara></listitem>
&doc-li;</itemizedlist></para>

<para>Certain other information is only associated with direct slot
definition metaobjects.  This information applies only to the direct
definition of the slot in the class (it is not inherited).
<itemizedlist><listitem><simpara>The function names of those generic
  functions for which there are automatically generated reader and
  writer methods.  This information is available as lists of function
  names.  Any accessors specified in the &defclass; form are broken down
  into their equivalent readers and writers in the direct slot
  definition.</simpara></listitem></itemizedlist></para>

<para>Information, including inherited information, which applies to the
definition of a slot in a particular class in which it is accessible is
associated only with effective slot definition metaobjects.
<itemizedlist><listitem><simpara>For certain slots, the location of the
slot in instances of the class is available.
</simpara></listitem></itemizedlist></para>

</section>

<section id="mo-gen-funs"><title>Generic Functions</title>

<para>A <firstterm>generic function metaobject
  <indexterm id="gen-fun-mo" significance="preferred">
   <primary>metaobject</primary><secondary>generic function</secondary>
 </indexterm></firstterm>
 contains information about a generic function over and above the
 information associated with each of the generic function's methods.
<itemizedlist><listitem><simpara>The name is available as a function name.
</simpara></listitem>
<listitem><simpara>The methods associated with the generic function are
  available as a list of method metaobjects.</simpara></listitem>
<listitem><simpara>The default class for this generic function's method
  metaobjects is available as a class metaobject.</simpara></listitem>
<listitem><simpara>The lambda list is available as a &list-t;.
</simpara></listitem>
<listitem><simpara>The method combination is available as a method
  combination metaobject.</simpara></listitem>
<listitem><simpara>The argument precedence order is available as a
  permutation of those symbols from the lambda list which name the
  required arguments of the generic function.</simpara></listitem>
<listitem><simpara>The declarations are available as a list of declarations.
</simpara>
<note><simpara>There is some ambiguity in &cl; about the terms used to
  identify the various parts of &declare; special forms.
  In this document, the term <emphasis>declaration</emphasis> is used to
  refer to an object that could be an argument to a &declare; special form.
  For example, in the special form
  <literal role="sexp">(&declare; (&special-dec; *g1*))</literal>,
  the list <literal role="sexp">(&special-dec; *g1*)</literal>
  is a declaration.</simpara></note></listitem>
&doc-li;</itemizedlist></para></section>

<section id="mo-methods"><title>Methods</title>

<para>A <firstterm>method metaobject
  <indexterm id="method-mo" significance="preferred">
   <primary>metaobject</primary><secondary>method</secondary>
 </indexterm></firstterm> contains information about a specific &method-t;.
<itemizedlist><listitem><simpara>The qualifiers are available as a
   &list-t; of of non-&nil; atoms.</simpara></listitem>
 <listitem><simpara>The lambda list is available as a &list-t;.
</simpara></listitem>
<listitem><simpara>The specializers are available as a list of
  specializer metaobjects.</simpara></listitem>
<listitem><simpara>The function is available as a &function-t;.  This
  function can be applied to arguments and a list of next methods using
  &apply; or &funcall;.</simpara></listitem>
<listitem><simpara>When the method is associated with a generic
  function, that generic function metaobject is available.  A method can
  be associated with at most one generic function at a time.
</simpara></listitem>
&doc-li;</itemizedlist></para></section>

<section id="mo-spec"><title>Specializers</title>

<para>A <firstterm>specializer metaobject
  <indexterm id="spec-mo" significance="preferred">
   <primary>metaobject</primary><secondary>specializer</secondary>
 </indexterm></firstterm> represents the specializers of a &method-t;.
 Class metaobjects are themselves specializer metaobjects.  A special
 kind of specializer metaobject is used for &eql-t; specializers.</para>

</section>

<section id="mo-meth-combs"><title>Method Combinations</title>

<para>A <firstterm>method combination metaobject
  <indexterm id="meth-comp-mo" significance="preferred">
   <primary>metaobject</primary><secondary>method combination</secondary>
 </indexterm></firstterm>
 represents the information about the method combination being used by a
 generic function.</para>

<note><para>This document does not specify the structure of method
combination metaobjects.</para></note>

</section>
</section>

<section id="mo-cl-inheritance">
 <title>Inheritance Structure of Metaobject Classes</title>

<para>The inheritance structure of the specified metaobject classes is
 shown in Table~\ref{inherit-struct-figure}.

<table id="inherit-struct">
 <title>The inheritance structure of metaobject classes</title>
 <caption>Direct superclass relationships among the specified metaobject
  classes. The class of every class shown is &standard-class-t; except
  for the class &t-t; which is an instance of the class
  &built-in-class-t; and the classes &generic-function-t; and
  &standard-generic-function-t; which are instances of the class
  &funcallable-standard-class;.</caption>
\toprule
&\bf  Metaobject Class&\bf Direct Superclasses\\
\tablerule
      & \bf standard-object                &\bf (t)\\
      & \bf funcallable-standard-object    &\bf (standard-object function)\\
$\ast$& \bf metaobject                     &\bf (standard-object)\\
$\ast$& \bf generic-function               &\bf (metaobject \\
      &                                    &\bf\quad funcallable-standard-object)\\
      & \bf standard-generic-function      &\bf (generic-function)\\
$\ast$& \bf method                         &\bf (metaobject)\\
      & \bf standard-method                &\bf (method)\\
$\ast$& \bf standard-accessor-method       &\bf (standard-method)\\
      & \bf standard-reader-method         &\bf (standard-accessor-method)\\
      & \bf standard-writer-method         &\bf (standard-accessor-method)\\
$\ast$& \bf method-combination             &\bf (metaobject)\\
$\ast$& \bf slot-definition                &\bf (metaobject)\\
$\ast$& \bf direct-slot-definition         &\bf (slot-definition)\\
$\ast$& \bf effective-slot-definition      &\bf (slot-definition)\\
$\ast$& \bf standard-slot-definition       &\bf (slot-definition)\\
      & \bf standard-direct-slot-          &\bf (standard-slot-definition \\
      & \bf \quad definition               &\bf\quad direct-slot-definition)\\
      & \bf standard-effective-slot-       &\bf (standard-slot-definition \\
      & \bf \quad definition               &\bf\quad effective-slot-definition)\\
$\ast$& \bf specializer                    &\bf (metaobject)\\
      & \bf eql-specializer                &\bf (specializer)\\
$\ast$& \bf class                          &\bf (specializer)\\
      & \bf built-in-class                 &\bf (class)\\
      & \bf forward-referenced-class       &\bf (class)\\
      & \bf standard-class                 &\bf (class)\\
      & \bf funcallable-standard-class     &\bf (class)\\
\bottomrule
\end{tabular}
\caption[]{Direct superclass relationships among the specified metaobject classes.
The class of every class shown is {\bf standard-class} except for the class {\bf
t} which is an instance of the class {\bf built-in-class} and the classes {\bf
generic-function} and {\bf standard-generic-function} which are instances of the
class {\bf funcallable-standard-class}.\label{inherit-struct-figure}\tolerant\tolerant\tolerant}
\end{table}

Each class marked with a ``$\ast$'' is an {\em abstract class\/} and is not intended
to be instantiated.  The results are undefined if an attempt is made to make
an instance of one of these classes with {\bf make-instance}.

{The classes {\bf standard-class}, {\bf standard-direct-slot-definition}, {\bf
standard-effective-slot-definition}, {\bf standard-method}, {\bf
standard-reader-method}, {\bf standard-writer-method} and {\bf
standard-generic-function} are called {\em standard metaobject classes}.  For
each kind of metaobject, this is the class the user interface macros presented
in the &clos; Specification use by default.  These are also the classes on which
user specializations are normally based.\tolerant\tolerant\tolerant\par}

The classes {\bf built-in-class}, {\bf funcallable-standard-class} and {\bf
forward-referenced-class} are special-purpose class metaobject classes.
Built-in classes are instances of the class {\bf built-in-class}.  The class
{\bf funcallable-standard-class} provides a special kind of instances
described in the section called ``Funcallable Instances.''  When the
definition of a class references another class which has not yet been defined,
an instance of {\bf forward-referenced-class} is used as a stand-in until the
class is actually defined.

The class {\bf standard-object} is the {\em default direct
superclass\/} of the class {\bf standard-class}.  When an instance of the
class {\bf standard-class} is created, and no direct superclasses are
explicitly specified, it defaults to the class {\bf standard-object}.  In
this way, any behavior associated with the class {\bf standard-object}
will be inherited, directly or indirectly, by all instances of the class
{\bf standard-class}.  A subclass of {\bf standard-class} may have a
different class as its default direct superclass, but that class must be
a subclass of the class {\bf standard-object}.

The same is true for {\bf funcallable-standard-class} and {\bf
funcallable-standard-object}.

The class {\bf specializer} captures only the most basic behavior of method
specializers, and is not itself intended to be instantiated.  The class {\bf
class} is a direct subclass of {\bf specializer} reflecting the property that
classes by themselves can be used as method specializers.  The class {\bf
eql-specializer} is used for {\bf eql} specializers.

\subsection{Implementation and User Specialization}

The purpose of the Metaobject Protocol is to provide users with a powerful
mechanism for extending and customizing the basic behavior of the Common Lisp
Object System.  As an object-oriented description of the basic &clos; behavior,
the Metaobject Protocol makes it possible to create these extensions by
defining specialized subclasses of existing metaobject classes.

The Metaobject Protocol provides this capability without interfering
with the implementor's ability to develop high-performance
implementations.  This balance between user extensibility and
implementor freedom is mediated by placing explicit restrictions on
each.  Some of these restrictions are general---they apply to the
entire class graph and the applicability of all methods.  These are
presented in this section.

The following additional terminology is used to present these
restrictions:\label{specialization-terminology}

<itemizedlist>

\item Metaobjects are divided into three categories.  Those defined
in this document are called {\em specified}; those defined by an
implementation but not mentioned in this document are called {\em
implementation-specific}; and those defined by a portable program are
called {\em portable}.

\item A class $I$ is {\em interposed\/} between two other classes
$C\sub{1}$ and $C\sub{2}$ if and only if there is some path, following
direct superclasses, from the class $C\sub{1}$ to the class $C\sub{2}$
which includes $I$.

\item A method is {\em specialized to\/} a class if and only if that
class is in the list of specializers associated with the method; and the
method is in the list of methods associated with some generic function.

\item In a given implementation, a specified method is said to have been {\em
promoted\/} if and only if the specializers of the method, $S\sub{1} \dots
S\sub{n}$, are defined in this specification as the classes $C\sub{1}
\dots C\sub{n}$, but in the implementation, one or more of the
specializers $S\sub{i}$, is a superclass of the class given in the
specification~$C\sub{i}$.

\item For a given generic function and set of  arguments, a method $M\sub{2}$
{\em extends\/} a method $M\sub{1}$ if and only if:

<itemizedlist>
\item[] (i) $M\sub{1}$ and $M\sub{2}$ are both associated with the given generic
function,

\item[] (ii) $M\sub{1}$ and $M\sub{2}$ are both applicable to the given
arguments,

\item[] (iii) the specializers and qualifiers of the methods are such that when
the generic function is called, $M\sub{2}$ is executed before $M\sub{1}$,

\item[] (iv) $M\sub{1}$ will be executed if and only if {\bf call-next-method}
is invoked from within the body of $M\sub{2}$ and

\item[] (v) {\bf call-next-method} is invoked from within the body of $M\sub{2}$,
thereby causing $M\sub{1}$ to be executed.
</itemizedlist>

\item For a given generic function and set of arguments, a method $M\sub{2}$
{\em overrides\/} a method $M\sub{1}$ if and only if conditions i through iv
above hold and

<itemizedlist>
\item[] (v$^\prime$) {\bf call-next-method} is not invoked from within the body
of $M\sub{2}$, thereby preventing $M\sub{1}$ from being executed.
</itemizedlist>
</itemizedlist>

\subsubsection{Restrictions on Implementations}

Implementations are allowed latitude to modify the structure of specified
classes and methods.  This includes:  the interposition of
implementation-specific classes; the promotion of specified methods; and the
consolidation of two or more specified methods into a single method
specialized to interposed classes.

Any such modifications are permitted only so long as for any portable class
$C\sub{\hbox{p}}$ that is a subclass of one or more specified classes
$C\sub{0} \ldots C\sub{i}$, the following conditions are met:

<itemizedlist>

\item In the actual class precedence list of $C\sub{\hbox{p}}$, the classes
$C\sub{0} \ldots C\sub{i}$ must appear in the same order as they would have
if no implementation-specific modifications had been made.

\item The method applicability of any specified generic function must be the
same in terms of behavior as it would have been had no implementation-specific
changes been made.  This includes specified generic functions that have had
portable methods added.  In this context, the expression ``the same in terms
of behavior'' means that methods with the same behavior as those specified are
applicable, and in the same order.

\item No portable class $C\sub{\hbox{p}}$ may inherit, by virtue
of being a direct or indirect subclass of a specified class, any slot for
which the name is a symbol accessible in the {\bf common-lisp-user} package or
exported by any package defined in the &ansi-cl;.

\item Implementations are free to define implementation-specific before-
and after-methods on specified generic functions.  Implementations are also
free to define implementation-specific around-methods with extending behavior.

</itemizedlist>

\subsubsection{Restrictions on Portable Programs}

Portable programs are allowed to define subclasses of specified classes, and
are permitted to define methods on specified generic functions, with the
following restrictions.  The results are undefined if any of these
restrictions is violated.

<itemizedlist>

\item Portable programs must not redefine any specified classes, generic
functions, methods or method combinations.  Any method defined by a portable
program on a specified generic function must have at least one specializer
that is neither a specified class nor an {\bf eql} specializer whose
associated value is an instance of a specified class.

\item Portable programs may define methods that extend specified methods
unless the description of the specified method explicitly prohibits this.
Unless there is a specific statement to the contrary, these extending methods
must return whatever value was returned by the call to {\bf call-next-method}.

\item Portable programs may define methods that override specified methods
only when the description of the specified method explicitly allows this.
Typically, when a method is allowed to be overridden, a small number of
related methods will need to be overridden as well.

An example of this is the specified methods on the generic functions {\bf
add-depend\-ent}, {\bf remove-dependent} and {\bf map-dependents}.  Overriding a
specified method on one of these generic functions requires that the
corresponding method on the other two generic functions be overridden as well.

\item Portable methods on specified generic functions specialized to portable
metaobject classes must be defined before any instances of those classes (or
any subclasses) are created, either directly or indirectly by a call to {\bf
make-instance}.  Methods can be defined after instances are created by {\bf
allocate-instance} however.  Portable metaobject classes cannot be redefined.

\begin{ImplNote}
The purpose of this last restriction is to permit implementations to provide
performance optimizations by analyzing, at the time the first instance of a
metaobject class is initialized, what portable methods will be applicable to
it.  This can make it possible to optimize calls to those specified generic
functions which would have no applicable portable methods.
\end{ImplNote}

\begin{Note}
The specification technology used in this document needs further development.
The concepts of object-oriented protocols and subclass specialization are
intuitively familiar to programmers of object-oriented systems; the protocols
presented here fit quite naturally into this framework.  Nonetheless, in
preparing this document, we have found it difficult to give
specification-quality descriptions of the protocols in a way that makes it
clear what extensions users can and cannot write.  Object-oriented protocol
specification is inherently about specifying leeway, and this seems difficult
using current technology.
\end{Note}

</itemizedlist>

</section>

<section id=""><title>Processing of the User Interface Macros</title>

A list in which the first element is one of the symbols &defclass;, {\bf
defmethod}, &defgeneric;, {\bf define-method-combination}, {\bf
generic-function}, {\bf generic-flet} or {\bf generic-labels}, and which has
proper syntax for that macro is called a {\em user interface macro form}.
This document provides an extended specification of the &defclass;, {\bf
defmethod} and &defgeneric; macros.

The user interface macros &defclass;, &defgeneric; and &defmethod;
can be used not only to define metaobjects that are instances of the
corresponding standard metaobject class, but also to define metaobjects that
are instances of appropriate portable metaobject classes.  To make it possible
for portable metaobject classes to properly process the information appearing
in the macro form, this document provides a limited specification of the
processing of these macro forms.

User interface macro forms can be {\em evaluated\/} or {\em compiled\/} and later
{\em executed}.  The effect of evaluating or executing a user interface macro
form is specified in terms of calls to specified functions and generic
functions which provide the actual behavior of the macro.  The arguments
received by these functions and generic functions are derived in a specified
way from the macro form.

Converting a user interface macro form into the arguments to the appropriate
functions and generic functions has two major aspects:  the conversion of the
macro argument syntax into a form more suitable for later processing, and the
processing of macro arguments which are forms to be evaluated (including
method bodies).

In the syntax of the &defclass; macro, the {\it initform\/} and {\it
default-initarg-initial-value-form\/} arguments are forms which will be
evaluated one or more times after the macro form is evaluated or executed.
Special processing must be done on these arguments to ensure that the lexical
scope of the forms is captured properly.  This is done by building a function
of zero arguments which, when called, returns the result of evaluating the
form in the proper lexical environment.

In the syntax of the &defmethod; macro the {\it form*\/} argument is a list
of forms that comprise the body of the method definition.  This list of forms
must be processed specially to capture the lexical scope of the macro form.
In addition, the lexical functions available only in the body of methods must
be introduced.  To allow this and any other special processing (such as slot
access optimization), a specializable protocol is used for processing the body
of methods.  This is discussed in the section ``Processing Method Bodies.''

\subsection{Compile-file Processing of the User Interface Macros}

It is common practice for &cl; compilers, while processing a file
or set of files, to maintain information about the definitions that have
been compiled so far.  Among other things, this makes it possible to
ensure that a global macro definition ({\bf defmacro} form) which
appears in a file will affect uses of the macro later in that file.
This information about the state of the compilation is called the {\em
compile-file environment}.

When compiling files containing &clos; definitions, it is useful to maintain
certain additional information in the compile-file environment.  This can make
it possible to issue various kinds of warnings (e.g., lambda list congruence)
and to do various performance optimizations that would not otherwise be
possible.

At this time, there is such significant variance in the way existing
&cl; implementations handle compile-file environments that it
would be premature to specify this mechanism.  Consequently, this
document specifies only the behavior of evaluating or executing user
interface macro forms. What functions and generic functions are called
during compile-file processing of a user interface macro form is not
specified.  Implementations are free to define and document their own
behavior.  Users may need to check implementation-specific behavior
before attempting to compile certain portable programs.

\subsection{The defclass Macro}

The evaluation or execution of a &defclass; form results in a call to the
{\bf ensure-class} function. The arguments received by {\bf ensure-class} are
derived from the &defclass; form in a defined way.  The exact
macro-expansion of the &defclass; form is not defined, only the
relationship between the arguments to the &defclass; macro and the
arguments received by the {\bf ensure-class} function.  Examples of typical
&defclass; forms and sample expansions are shown in
Figures~\ref{defclass1} and~\ref{defclass2}.


\begin{figure}
\hrule
\begin{lispcode}
(defclass plane (moving-object graphics-object)
     ((altitude :initform 0 :accessor plane-altitude)
      (speed))
  (:default-initargs :engine *jet*))

(ensure-class 'plane
  ':direct-superclasses '(moving-object graphics-object)
  ':direct-slots (list (list ':name 'altitude
                             ':initform '0
                             ':initfunction #'(lambda () 0)
                             ':readers '(plane-altitude)
                             ':writers '((setf plane-altitude)))
                       (list ':name 'speed))
  ':direct-default-initargs (list (list ':engine
                                        '*jet*
                                        #'(lambda () *jet*))))
\end{lispcode}
\hrule
\caption[]{A &defclass; form with standard slot and class options and an
expansion of it that would result in the proper call to {\bf
ensure-class}.\label{defclass1}}
\end{figure}

\begin{figure}
\hrule
\begin{lispcode}
(defclass sst (plane)
     ((mach mag-step 2
            locator sst-mach
            locator mach-location
            :reader mach-speed
            :reader mach))
  (:metaclass faster-class)
  (another-option foo bar))

(ensure-class 'sst
  ':direct-superclasses '(plane)
  ':direct-slots (list (list ':name 'mach
                             ':readers '(mach-speed mach)
                             'mag-step '2
                             'locator '(sst-mach mach-location)))
  ':metaclass 'faster-class
  'another-option '(foo bar))
\end{lispcode}
\hrule
\caption[]{A &defclass; form with non-standard class and slot options, and an
expansion of it which results in the proper call to {\bf ensure-class}.
Note that the order of the slot options has not affected the order of
the properties in the canonicalized slot specification, but has affected
the order of the elements in the lists which are the values of those
properties.\label{defclass2}}
\end{figure}

<itemizedlist>

\item The {\it name\/} argument to &defclass; becomes the value of the first
argument to {\bf ensure-class}.  This is the only positional argument accepted
by {\bf ensure-class}; all other arguments are keyword arguments.

\item {The {\it direct-superclasses\/} argument to &defclass; becomes the
value of the {\bf :direct-super\-classes} keyword argument to {\bf
ensure-class}.\par}

\item The {\it direct slots\/} argument to &defclass; becomes the value of
the {\bf :direct-slots} keyword argument to {\bf ensure-class}.  Special
processing of this value is done to regularize the form of each slot
specification and to properly capture the lexical scope of the initialization
forms.  This is done by converting each slot specification to a property list
called a {\em canonicalized slot specification}.  The resulting list of
canonicalized slot specifications is the value of the {\bf :direct-slots}
keyword argument.

Canonicalized slot specifications are later used as the keyword arguments to a
generic function which will, in turn, pass them to {\bf make-instance} for use
as a set of initialization arguments. Each canonicalized slot specification is
formed from the corresponding slot specification as follows:

<itemizedlist>
\item The name of the slot is the value of the {\bf :name} property.  This
property appears in every canonicalized slot specification.

\item When the {\bf :initform} slot option is present in the slot
specification, then both the {\bf :initform} and {\bf :initfunction}
properties are present in the canonicalized slot specification.  The
value of the {\bf :initform} property is the initialization form.  The value of the
{\bf :initfunction} property is a function of zero arguments which, when
called, returns the result of evaluating the initialization form in its proper
lexical environment.

If the {\bf :initform} slot option is not present in the slot specification,
then either the {\bf :initfunction} property will not appear, or its value
will be false.  In such cases, the value of the {\bf :initform} property, or
whether it appears, is unspecified.

\item The value of the {\bf :initargs} property is a list of the
values of each {\bf :initarg} slot option.  If there are no {\bf
:initarg} slot options, then either the {\bf :initargs} property will
not appear or its value will be the empty list.

\item The value of the {\bf :readers} property is a list
of the values of each {\bf :reader} and {\bf :accessor} slot option.  If
there are no {\bf :reader} or {\bf :accessor} slot options, then either
the {\bf :readers} property will not appear or its value will be the
empty list.

\item The value of the {\bf :writers} property is a list of the
values specified by each {\bf :writer} and {\bf :accessor} slot option.
The value specified by a {\bf :writer} slot option is just the value of
the slot option.  The value specified by an {\bf :accessor} slot option
is a two element list:  the first element is the symbol {\bf setf}, the
second element is the value of the slot option.  If there are no {\bf
:writer} or {\bf :accessor} slot options, then either the {\bf :writers}
property will not appear or its value will be the empty list.

\item The value of the {\bf :documentation} property is the value of the {\bf
:documentation} slot option.  If there is no {\bf :documentation} slot option,
then either the {\bf :documentation} property will not appear or its value
will be false.

\item All other slot options appear as the values of properties
with the same name as the slot option.  Note that this includes not only
the remaining standard slot options ({\bf :allocation} and {\bf :type}),
but also any other options and values appearing in the slot specification.
If one of these slot options appears more than once, the value of the
property will be a list of the specified values.

\item An implementation is free to add additional properties
to the canonicalized slot specification provided these are not symbols
accessible in the {\bf common-lisp-user} package, or exported by any
package defined in the &ansi-cl;.
</itemizedlist>

\noindent Returning to the correspondence between arguments to the &defclass; macro and the arguments received by the {\bf ensure-class} function:

\item The {\it default initargs\/} class option, if it is present in
the &defclass; form, becomes the value of the {\bf
:direct-default-initargs} keyword argument to {\bf ensure-class}.
Special processing of this value is done to properly capture the lexical
scope of the default value forms.  This is done by converting each
default initarg in the class option into a {\em canonicalized default
initarg}.  The resulting list of canonicalized default initargs is the
value of the {\bf :direct-default-initargs} keyword argument to {\bf
ensure-class}.

A canonicalized default initarg is a list of three elements.  The first
element is the name; the second is the actual form itself; and the third
is a function of zero arguments which, when called, returns the result
of evaluating the default value form in its proper lexical environment.

\item The {\it metaclass\/} class option, if it is present in
the &defclass; form, becomes the value of the {\bf :metaclass}
keyword argument to {\bf ensure-class}.

\item The {\it documentation\/} class option, if it is present in the &defclass; form, becomes the value of the {\bf :documentation} keyword argument
to {\bf ensure-class}.

\item Any other class options become the value of keyword arguments
with the same name.  The value of the keyword argument is the tail of the
class option. An error is signaled if any class option appears more than once
in the &defclass; form.

</itemizedlist>

In the call to {\bf ensure-class}, every element of its arguments appears in
the same left-to-right order as the corresponding element of the &defclass; form, except that the order of the properties of canonicalized
slot specifications is unspecified.  The values of properties in
canonicalized slot specifications do follow this ordering requirement.
Other ordering relationships in the keyword arguments to {\bf
ensure-class} are unspecified.

The result of the call to {\bf ensure-class} is returned as the result
of evaluating or executing the &defclass; form.

\subsection{The defmethod Macro}

The evaluation or execution of a &defmethod; form requires first that the
body of the method be converted to a method function.  This process is
described in the next section. The result of this process is a method function
and a set of additional initialization arguments to be used when creating the
new method.  Given these two values, the evaluation or execution of a {\bf
defmethod} form proceeds in three steps.

The first step ensures the existence of a generic function with the specified
name.  This is done by calling the function {\bf ensure-generic-function}.  The
first argument in this call is the generic function name specified in the {\bf
defmethod} form.

{The second step is the creation of the new method metaobject by calling {\bf
make-instance}.  The class of the new method metaobject is determined by calling
{\bf generic-function-method-class} on the result of the call to {\bf
ensure-generic-function} from the first step.\tolerant\tolerant\tolerant\par}

The initialization arguments received by the call to {\bf make-instance}
are as follows:

<itemizedlist>

\item The value of the {\bf :qualifiers} initialization argument is a list
of the qualifiers which appeared in the &defmethod; form.  No special
processing is done on these values.  The order of the elements of this list is
the same as in the &defmethod; form.

\item  The value of the {\bf :lambda-list} initialization argument is the
unspecialized lambda list from the &defmethod; form.

\item The value of the {\bf :specializers} initialization argument is a list
of the specializers for the method.  For specializers which are classes, the
specializer is the class metaobject itself.  In the case of {\bf eql}
specializers, it will be an {\bf eql-specializer} metaobject obtained by
calling {\bf intern-eql-specializer} on the result of evaluating the {\bf eql}
specializer form in the lexical environment of the &defmethod; form.

\item The value of the {\bf :function} initialization argument is the method
function.

\item The value of the {\bf :declarations} initialization argument is a
list of the declarations from the &defmethod; form.  If there are no
declarations in the macro form, this initialization argument either doesn't
appear, or appears with a value of the empty list.

\item The value of the {\bf :documentation} initialization argument is the
documentation string from the &defmethod; form.  If there is no
documentation string in the macro form this initialization argument either
doesn't appear, or appears with a value of false.

\item Any other initialization argument produced in conjunction with the method
function are also included.

\item The implementation is free to include additional
initialization arguments provided these are not symbols accessible in the {\bf
common-lisp-user} package, or exported by any package defined in the &ansi-cl;.

</itemizedlist>

In the third step, &add-method; is called to add the newly created
method to the set of methods associated with the generic function
metaobject.

The result of the call to &add-method; is returned as the result of
evaluating or executing the &defmethod; form.

\begin{figure}
\hrule
\begin{lispcode}
(defmethod move :before ((p position) (l (eql 0))
                         &optional (visiblyp t)
                         &key color)
  (set-to-origin p)
  (when visiblyp (show-move p 0 color)))

(let ((#:g001 (ensure-generic-function 'move)))
  (add-method #:g001
    (make-instance (generic-function-method-class #:g001)
                   ':qualifiers '(:before)
                   ':specializers (list (find-class 'position)
                                        (intern-eql-specializer 0))
                   ':lambda-list '(p l &optional (visiblyp t)
                                       &key color)
                   ':function (function\em method-lambda\tt)
                   'additional-initarg-1 't
                   'additional-initarg-2 '39)))
\end{lispcode}
\hrule
\caption[]{An example &defmethod; form and one possible correct expansion.
In the expansion, {\em method-lambda\/} is the result of calling {\bf
make-method-lambda} as described in the section ``Processing Method Bodies''.
The initargs appearing after {\bf :function} are assumed to be additional
initargs returned from the call to {\bf make-method-lambda}.\label{defmethod1}}
\end{figure}

An example showing a typical &defmethod; form and a sample expansion is
shown in Figure~\ref{defmethod1}.  The processing of the method body for this
method is shown in Figure~\ref{defmethod2}.

\subsection{Processing Method Bodies}

Before a method can be created, the list of forms comprising the method body
must be converted to a method function.  This conversion is a two step
process.

\begin{Note}
The body of methods can also appear in the {\bf :initial-methods} option of
&defgeneric; forms.  Initial methods are not considered by any of the
protocols specified in this document.
\end{Note}

\begin{figure}
\hrule
\begin{lispcode}
(let ((gf (ensure-generic-function 'move)))
  (make-method-lambda
    gf
    (class-prototype (generic-function-method-class gf))
    '(lambda (p l &optional (visiblyp t) &key color)
       (set-to-origin p)
       (when visiblyp (show-move p 0 color)))
   \em environment\tt))
\end{lispcode}
\hrule
\caption[]{During macro-expansion of the &defmethod; macro shown in
Figure~\protect\ref{defmethod1}, code similar to this would be run to produce
the method lambda and additional initargs.  In this example, {\em environment\/}
is the macroexpansion environment of the &defmethod; macro form.\label{defmethod2}}
\end{figure}

The first step occurs during macro-expansion of the macro form.  In this step,
the method lambda list, declarations and body are converted to a lambda
expression called a {\em method lambda}.  This conversion is based on
information associated with the generic function definition in effect at the
time the macro form is expanded.

The generic function definition is obtained by calling {\bf
ensure-generic-function} with a first argument of the generic function name
specified in the macro form.  The {\bf :lambda-list} keyword argument is not
passed in this call.

Given the generic function, production of the method lambda proceeds by
calling {\bf make-method-lambda}.  The first argument in this call is the
generic function obtained as described above.  The second argument is the
result of calling {\bf class-prototype} on the result of calling {\bf
generic-function-method-class} on the generic function.  The third argument is
a lambda expression formed from the method lambda list, declarations and body.
The fourth argument is the macro-expansion environment of the macro form; this
is the value of the {\bf \&environment} argument to the &defmethod; macro.

The generic function {\bf make-method-lambda} returns two values.  The first
is the method lambda itself.  The second is a list of initialization arguments
and values.  These are included in the initialization arguments when the
method is created.

In the second step, the method lambda is converted to a function which
properly captures the lexical scope of the macro form.  This is done by having
the method lambda appear in the macro-expansion as the argument of the {\bf
function} special form.  During the subsequent evaluation of the
macro-expansion, the result of the {\bf function} special form is the method
function.

\subsection{The defgeneric Macro}

The evaluation or execution of a &defgeneric; form results in a call to
the {\bf ensure-generic-function} function. The arguments received by {\bf
ensure-generic-function} are derived from the &defgeneric; form in a
defined way.  As with &defclass; and &defmethod;, the exact
macro-expansion of the &defgeneric; form is not defined, only the
relationship between the arguments to the macro and the arguments received by
{\bf ensure-generic-function}.

<itemizedlist>

\item The {\it function-name\/} argument to &defgeneric; becomes the first
argument to {\bf ensure-generic-function}.  This is the only positional
argument accepted by {\bf ensure-generic-function}; all other arguments are
keyword arguments.

\item The {\it lambda-list\/} argument to &defgeneric; becomes
the value of the {\bf :lambda-list} keyword argument to {\bf
ensure-generic-function}.

\item For each of the options {\bf :argument-precedence-order}, {\bf
:documentation}, {\bf :generic-function-class} and {\bf :method-class}, the
value of the option becomes the value of the keyword argument with the same
name.  If the option does not appear in the macro form, the keyword argument
does not appear in the resulting call to {\bf ensure-generic-function}.

\item For the option {\bf declare}, the list of declarations becomes the value
of the {\bf :declarations} keyword argument.  If the {\bf declare} option does
not appear in the macro form, the {\bf :declarations} keyword argument does
not appear in the call to {\bf ensure-generic-function}.

\item The handling of the {\bf :method-combination} option is not specified.

</itemizedlist>

The result of the call to {\bf ensure-generic-function} is returned as the
result of evaluating or executing the &defgeneric; form.

</section>

<section id=""><title>Subprotocols</title>

This section provides an overview of the Metaobject Protocols.  The detailed
behavior of each function, generic function and macro in the Metaobject
Protocol is presented in Chapter~\ref{spec2}.  The remainder of this chapter
is intended to emphasize connections among the parts of the Metaobject
Protocol, and to provide some examples of the kinds of specializations and
extensions the protocols are designed to support.

\subsection{Metaobject Initialization Protocols}

Like other objects, metaobjects can be created by calling {\bf
make-instance}.  The initialization arguments passed to {\bf make-instance}
are used to initialize the metaobject in the usual way.  The set of legal
initialization arguments, and their interpretation, depends on the kind of
metaobject being created.  Implementations and portable programs are free to
extend the set of legal initialization arguments.  Detailed information about
the initialization of each kind of metaobject are provided in
Chapter~\ref{spec2}; this section provides an overview and examples of this
behavior.

\subsubsection{Initialization of Class Metaobjects}

{Class metaobjects created with {\bf make-instance} are usually {\em
anonymous}; that is, they have no proper name.  An anonymous class metaobject
can be given a proper name using {\bf(setf find-class)} and {\bf(setf
class-name)}.\par}

When a class metaobject is created with {\bf make-instance}, it is initialized
in the usual way.  The initialization arguments passed to {\bf make-instance}
are use to establish the definition of the class.  Each initialization argument
is checked for errors and associated with the class metaobject.  The
initialization arguments correspond roughly to the arguments accepted by the
&defclass; macro, and more closely to the arguments accepted by the {\bf
ensure-class} function.

Some class metaobject classes allow their instances to be redefined.  When
permissible, this is done by calling {\bf reinitialize-instance}.  This is
discussed in the next section.

An example of creating an anonymous class directly using {\bf make-instance}
follows:

\begin{lispcode}
(flet ((zero () 0)
       (propellor () *propellor*))
  (make-instance 'standard-class
    :name '(my-class foo)
    :direct-superclasses (list (find-class 'plane)
                              \em another-anonymous-class\tt)
    :direct-slots `((:name x
                     :initform 0
                     :initfunction ,#'zero
                     :initargs (:x)
                     :readers (position-x)
                     :writers ((setf position-x)))
                    (:name y
                     :initform 0
                     :initfunction ,#'zero
                     :initargs (:y)
                     :readers (position-y)
                     :writers ((setf position-y))))
    :direct-default-initargs `((:engine *propellor* ,#'propellor))))
\end{lispcode}

\subsubsection{Reinitialization of Class Metaobjects}

Some class metaobject classes allow their instances to be reinitialized.  This
is done by calling {\bf reinitialize-instance}.  The initialization arguments
have the same interpretation as in class initialization.

If the class metaobject was finalized before the call to {\bf
reinitialize-instance}, {\bf finalize-inheritance} will be called again once all
the initialization arguments have been processed and associated with the class
metaobject.  In addition, once finalization is complete, any dependents of the
class metaobject will be updated by calling {\bf update-dependent}.


\subsubsection{Initialization of Generic Function and Method Metaobjects}

An example of creating a generic function and a method metaobject, and then
adding the method to the generic function is shown below.  This example is
comparable to the method definition shown in Figure~\ref{defmethod1}.

\begin{lispcode}
(let* ((gf (make-instance 'standard-generic-function
                          :lambda-list '(p l &optional visiblyp &key)))
       (method-class (generic-function-method-class gf)))
  (multiple-value-bind (lambda initargs)
       (make-method-lambda
         gf
         (class-prototype method-class)
         '(lambda (p l &optional (visiblyp t) &key color)
            (set-to-origin p)
            (when visiblyp (show-move p 0 color)))
         nil)
    (add-method gf
                (apply #'make-instance method-class
                       :function (compile nil lambda)
                       :specializers (list (find-class 'position)
                                           (intern-eql-specializer 0))
                       :qualifiers ()
                       :lambda-list '(p l &optional (visiblyp t)
                                          &key color)
                       initargs))))
\end{lispcode}

\subsection{Class Finalization Protocol}

Class {\em finalization\/} is the process of computing the information a class
inherits from its superclasses and preparing to actually allocate instances of
the class.  The class finalization process includes computing the class's
class precedence list, the full set of slots accessible in instances of the
class and the full set of default initialization arguments for the class.
These values are associated with the class metaobject and can be accessed by
calling the appropriate reader.  In addition, the class finalization process
makes decisions about how instances of the class will be implemented.

To support forward-referenced superclasses, and to account for the fact that
not all classes are actually instantiated, class finalization is not done as
part of the initialization of the class metaobject.  Instead, finalization is
done as a separate protocol, invoked by calling the generic function {\bf
finalize-inheritance}.  The exact point at which {\bf finalize-inheritance} is
called depends on the class of the class metaobject; for {\bf standard-class}
it is called sometime after all the classes superclasses are defined, but no
later than when the first instance of the class is allocated (by {\bf
allocate-instance}).

The first step of class finalization is computing the class precedence list.
Doing this first allows subsequent steps to access the class precedence list.
This step is performed by calling the generic function {\bf
compute-class-precedence-list}.  The value returned from this call is
associated with the class metaobject and can be accessed by calling the {\bf
class-precedence-list} generic function.

The second step is computing the full set of slots that will be accessible
in instances of the class.  This step is performed by calling the generic
function {\bf compute-slots}.  The result of this call is a list of
effective slot definition metaobjects.  This value is associated with the
class metaobject and can be accessed by calling the {\bf class-slots}
generic function.

The behavior of {\bf compute-slots} is itself layered, consisting of calls
to {\bf effective-slot-definition-class} and {\bf
compute-effective-slot-definition}.

The final step of class finalization is computing the full set of
initialization arguments for the class.  This is done by calling the generic
function {\bf compute-default-initargs}.  The value returned by this generic
function is associated with the class metaobject and can be accessed by
calling {\bf class-default-initargs}.

If the class was previously finalized, {\bf finalize-inheritance} may call
{\bf make-instances-obsolete}.  The circumstances under which this happens are
describe in the section of the &clos; specification called ``Redefining
Classes.''

Forward-referenced classes, which provide a temporary definition for a class
which has been referenced but not yet defined, can never be finalized.  An
error is signalled if {\bf finalize-inheritance} is called on a
forward-referenced class.

\subsection{Instance Structure Protocol}

The instance structure protocol is responsible for implementing the behavior
of the slot access functions like {\bf slot-value} and {\bf (setf
slot-value)}.

For each &clos; slot access function other than {\bf slot-exists-p}, there is a
corresponding generic function which actually provides the behavior of the
function.  When called, the slot access function finds the pertinent effective
slot definition metaobject, calls the corresponding generic function and
returns its result.  The arguments passed on to the generic function include
one additional value, the class of the {\it object\/} argument, which always
immediately precedes the {\it object\/} argument

{\samepage
The correspondences between slot access function and underlying slot access
generic function are as follows:

\begin{center}
\def\slotargs{}%{(\it object slot-name\bf)}
\def\gfslotargs{}%{(\it class object slot\bf)}
\begin{tabular}{ll}
\toprule
\bf Slot Access Function &\bf Corresponding Slot Access \\
&\bf\quad Generic Function\\
\tablerule
\bf slot-boundp       \slotargs &\bf slot-boundp-using-class       \gfslotargs\\
\bf slot-makunbound   \slotargs &\bf slot-makunbound-using-class   \gfslotargs\\
\bf slot-value        \slotargs &\bf slot-value-using-class        \gfslotargs\\
\bf (setf slot-value) \slotargs &\bf (setf slot-value-using-class) \gfslotargs\\
\bottomrule
\end{tabular}
\end{center}
}

At the lowest level, the instance structure protocol provides only limited
mechanisms for portable programs to control the implementation of instances
and to directly access the storage associated with instances without going
through the indirection of slot access.  This is done to allow portable
programs to perform certain commonly requested slot access optimizations.

In particular, portable programs can control the implementation of, and obtain
direct access to, slots with allocation {\bf :instance} and type {\bf t}.  These
are called {\em directly accessible slots}.

The relevant specified around-method on {\bf compute-slots} determines the
implementation of instances by deciding how each slot in the instance will be
stored.  For each directly accessible slot, this method allocates a {\em
location\/} and associates it with the effective slot definition metaobject.
The location can be accessed by calling the {\bf slot-definition-location}
generic function.  Locations are non-negative integers.  For a given class,
the locations increase consecutively, in the order that the directly
accessible slots appear in the list of effective slots.  (Note that here, the
next paragraph, and the specification of this around-method are the only
places where the value returned by {\bf compute-slots} is described as a list
rather than a set.)

Given the location of a directly accessible slot, the value of that slot in an
instance can be accessed with the appropriate accessor.  For {\bf
standard-class}, this accessor is the function {\bf standard-instance-access}.
For {\bf funcallable-standard-class}, this accessor is the function {\bf
funcallable-standard-instance-access}.  In each case, the arguments to the
accessor are the instance and the slot location, in that order.  See the
definition of each accessor in Chapter~\ref{spec2} for additional restrictions
on the use of these function.

Portable programs are permitted to affect and rely on the allocation of
locations only in the following limited way:  By first defining a portable
primary method on {\bf compute-slots} which orders the returned value in a
predictable way, and then relying on the defined behavior of the specified
around-method to assign locations to all directly accessible slots.
Portable programs may compile-in calls to low-level accessors which take
advantage of the resulting predictable allocation of slot locations.

\begin{Example}
The following example shows the use of this mechanism to implement a new class
metaobject class, {\bf ordered-class} and class option {\bf :slot-order}.  This
option provides control over the allocation of slot locations.  In this simple
example implementation, the {\bf :slot-order} option is not inherited by
subclasses; it controls only instances of the class itself.

\begin{lispcode}
(defclass ordered-class (standard-class)
     ((slot-order :initform ()
                  :initarg :slot-order
                  :reader class-slot-order)))

(defmethod compute-slots ((class ordered-class))
  (let ((order (class-slot-order class)))
    (sort (copy-list (call-next-method))
          #'(lambda (a b)
              (< (position (slot-definition-name a) order)
                 (position (slot-definition-name a) order))))))
\end{lispcode}

\noindent Following is the source code the user of this extension would write.
 Note that because the code above doesn't implement inheritance of the {\bf
:slot-order} option, the function {\bf distance} must not be called on
instances of subclasses of {\bf point}; it can only be called on instances
of {\bf point} itself.

\begin{lispcode}
(defclass point ()
     ((x :initform 0)
      (y :initform 0))
  (:metaclass ordered-class)
  (:slot-order x y))

(defun distance (point)
  (sqrt (/ (+ (expt (standard-instance-access point 0) 2)
              (expt (standard-instance-access point 1) 2))
           2.0)))
\end{lispcode}

\noindent In more realistic uses of this mechanism, the calls to the low-level
instance structure accessors would not actually appear textually in the source
program, but rather would be generated by a meta-level analysis program run
during the process of compiling the source program.
\end{Example}

\subsection{Funcallable Instances}

Instances of classes which are themselves instances of {\bf
funcallable-standard-class} or one of its subclasses are called {\it
funcallable instances}.  Funcallable instances can only be created by
\method{allocate-instance}{funcallable-standard-class}.

Like standard instances, funcallable instances have slots with the normal
behavior.  They differ from standard instances in that they can be used as
functions as well; that is, they can be passed to &funcall; and {\bf
apply}, and they can be stored as the definition of a function name.
Associated with each funcallable instance is the function which it runs when
it is called.  This function can be changed with {\bf
set-funcallable-instance-function}.

\begin{Example}
The following simple example shows the use of funcallable instances to create
a simple, {\bf defstruct}-like facility.  (Funcallable instances are useful
when a program needs to construct and maintain a set of functions and
information about those functions.  They make it possible to maintain both as
the same object rather than two separate objects linked, for example, by hash
tables.)

\begin{lispcode}
(defclass constructor ()
     ((name :initarg :name :accessor constructor-name)
      (fields :initarg :fields :accessor constructor-fields))
  (:metaclass funcallable-standard-class))

(defmethod initialize-instance :after ((c constructor) &key)
  (with-slots (name fields) c
    (set-funcallable-instance-function
      c
      #'(lambda ()
          (let ((new (make-array (1+ (length fields)))))
            (setf (aref new 0) name)
            new)))))

(setq c1 (make-instance 'constructor
                        :name 'position :fields '(x y)))
#<CONSTRUCTOR 262437>

(setq p1 (funcall c1))
#<ARRAY 3 263674>
\end{lispcode}
\end{Example}

\subsection{Generic Function Invocation Protocol}

Associated with each generic function is its discriminating function.  Each
time the generic function is called, the discriminating function is called to
provide the behavior of the generic function.  The discriminating function
receives the full set of arguments received by the generic function.  It must
lookup and execute the appropriate methods, and return the appropriate values.

The discriminating function is computed by the highest layer of the generic
function invocation protocol, {\bf compute-discriminating-function}.  Whenever
a generic function metaobject is initialized, reinitialized, or a method is
added or removed, the discriminating function is recomputed.  The new
discriminating function is then stored with {\bf
set-funcallable-instance-function}.

{Discriminating functions call {\bf compute-applicable-methods} and {\bf
compute-applicable-methods-using-classes} to compute the methods applicable to
the generic functions arguments.  Applicable methods are combined by {\bf
compute-effective-method} to produce an {\it effective method\/}.  Provisions
are made to allow memoization of the method applicability and effective
methods computations.  (See the description of {\bf
compute-discriminating-function} for details.)\tolerant\tolerant\tolerant\par}

The body of method definitions are processed by {\bf make-method-lambda}.  The
result of this generic function is a lambda expression which is processed by
either {\bf compile} or the file compiler to produce a {\it method function}.
The arguments received by the method function are controlled by the {\bf
call-method} forms appearing in the effective methods.  By default, method
functions accept two arguments: a list of arguments to the generic function,
and a list of next methods.  The list of next methods corresponds to the next
methods argument to {\bf call-method}.  If {\bf call-method} appears with
additional arguments, these will be passed to the method functions as well; in
these cases, {\bf make-method-lambda} must have created the method lambdas to
expect additional arguments.

\subsection{Dependent Maintenance Protocol}

It is convenient for portable metaobjects to be able to memoize information
about other metaobjects, portable or otherwise.  Because class and generic
function metaobjects can be reinitialized, and generic function metaobjects
can be modified by adding and removing methods, a means must be provided to
update this memoized information.

The dependent maintenance protocol supports this by providing a way to
register an object which should be notified whenever a class or generic
function is modified.  An object which has been registered this way is called a
{\em dependent\/} of the class or generic function metaobject.  The dependents
of class and generic function metaobjects are maintained with {\bf
add-dependent} and {\bf remove-dependent}.  The dependents of a class or
generic function metaobject can be accessed with {\bf map-dependents}.
Dependents are notified about a modification by calling {\bf
update-dependent}.  (See the specification of {\bf update-dependent} for
detailed description of the circumstances under which it is called.)

To prevent conflicts between two portable programs, or between portable
programs and the implementation, portable code must not register metaobjects
themselves as dependents. Instead, portable programs which need to record a
metaobject as a dependent, should encapsulate that metaobject in some other
kind of object, and record that object as the dependent.  The results are
undefined if this restriction is violated.

\begin{Example}
This example shows a general facility for encapsulating metaobjects before
recording them as dependents.  The facility defines a basic kind of
encapsulating object: an updater.  Specializations of the basic class can be
defined with appropriate special updating behavior.  In this way, information
about the updating required is associated with each updater rather than with
the metaobject being updated.

Updaters are used to encapsulate any metaobject which requires updating when a
given class or generic function is modified.  The function {\bf
record-updater} is called to both create an updater and add it to the
dependents of the class or generic function.  Methods on the generic function
{\bf update-dependent}, specialized to the specific class of updater do the
appropriate update work.

\begin{lispcode}
(defclass updater ()
     ((dependent :initarg :dependent :reader dependent)))

(defun record-updater (class dependee dependent &rest initargs)
  (let ((updater (apply #'make-instance class :dependent dependent
                                              initargs)))
    (add-dependent dependee updater)
    updater))
\end{lispcode}

A {\bf flush-cache-updater} simply flushes the cache of the dependent when it
is updated.

\begin{lispcode}
(defclass flush-cache-updater (updater) ())

(defmethod update-dependent (dependee (updater flush-cache-updater)
                             &rest args)
  (declare (ignore args))
  (flush-cache (dependent updater)))
\end{lispcode}
\end{Example}

                 <!-- ------------------ -->
% Document type: LaTeX
\chapter[Generic Functions and Methods]{\label{spec2}Generic Functions and Methods}
\setcounter{secnumdepth}{0}

\pagestyle{dictionaryheadings}

This chapter describes each of the functions and generic functions that make
up the &clos; Metaobject Protocol.  The descriptions appear in alphabetical
order with the exception that all the reader generic functions for each kind
of metaobject are grouped together.  So, for example, {\bf method-function}
would be found with {\bf method-qualifiers} and other method metaobject
readers under ``Readers for Method Metaobjects.''

The description of functions follows the same form as used in the &clos;
specification.  The description of generic functions is similar to that in the
&clos; specification, but some minor changes have been made in the way methods
are presented.

The following is an example of the format for the syntax description of a
generic function:

\Defmethod {gf1} {{\it x\/} {\it y\/} {\opt} {\it z\/} \key {\it k\/}} {}

This description indicates that {\bf gf1} is a generic function with two
required parameters, {\it x\/} and {\it y}, an optional parameter {\it z\/}
and a keyword parameter {\it k}.

The description of a generic function includes a description of its behavior.
This provides the general behavior, or protocol of the generic function.  All
methods defined on the generic function, both portable and specified, must
have behavior consistent with this description.

Every generic function described in this section is an instance of the class
{\bf standard-generic-function} and uses standard method combination.

The description of a generic function also includes descriptions of the
specified methods for that generic function.  In the description of these
methods, a {\em method signature\/} is used to describe the parameters and
parameter specializers of each method. The following is an example of the
format for a method signature:

\Defmeth {gf1}
         {({\it x\/} {\it class}) {\it y\/} \&optional {\it z\/} \&key {\it k\/}}

This signature indicates that this primary method on the generic function {\bf
gf1} has two required parameters, named {\it x\/} and {\it y}.  In addition,
there is an optional parameter {\it z\/} and a keyword parameter {\it k}.
This signature also indicates that the method's parameter specializers are the
classes named {\bf class\/} and {\bf t}.

The description of each method includes a description of the behavior
particular to that method.

An abbreviated syntax is used when referring to a method defined elsewhere in
the document.  This abbreviated syntax includes the name of the generic
function, the qualifiers, and the parameter specializers.  A reference to the
method with the signature shown above is written as:  \method{gf1}{class t}.

\begingfcom{add-dependent}

\Syntaxlabel

\Defgen {add-dependent} {metaobject dependent}

\Argumentslabel

The {\it metaobject\/} argument is a class or generic function metaobject.

The {\it dependent\/} argument is an object.

\Valueslabel

The value returned by this generic function is unspecified.

\Purposelabel

This generic function adds {\it dependent\/} to the dependents of {\it
metaobject\/}.  If {\it dependent\/} is already in the set of dependents it is not
added again (no error is signaled).

The generic function {\bf map-dependents} can be called to access the
set of dependents of a class or generic function.  The generic function
{\bf remove-dependent} can be called to remove an object from the set of
dependents of a class or generic function.  The effect of calling {\bf
add-dependent} or {\bf remove-dependent} while a call to {\bf
map-dependents} on the same class or generic function is in progress is
unspecified.

The situations in which {\bf add-dependent} is called are not specified.

\Methodslabel

\Defmeth {add-dependent} {({\it class\/} standard-class) {\it dependent\/}}

No behavior is specified for this method beyond that which is specified for
the generic function.

This method cannot be overridden unless the following methods are
overridden as well:

\begin{methods}
\method{remove-dependent}{standard-class t}\\
\method{map-dependents}{standard-class t}
\end{methods}

\Defmeth {add-dependent} {({\it class\/} funcallable-standard-class) {\it dependent\/}}

No behavior is specified for this method beyond that which is specified for
the generic function.

This method cannot be overridden unless the following methods are
overridden as well:

\begin{methods}
\method{remove-dependent}{funcallable-standard-class t}\\
\method{map-dependents}{funcallable-standard-class t}
\end{methods}

\Defmeth {add-dependent} {({\it generic-function\/} standard-generic-function) {\it dependent\/}}

No behavior is specified for this method beyond that which is specified for
the generic function.

This method cannot be overridden unless the following methods are
overridden as well:

\begin{methods}
\method{remove-dependent}{standard-generic-function t}\\
\method{map-dependents}{standard-generic-function t}
\end{methods}

\Remarkslabel

See the ``Dependent Maintenance Protocol'' section for remarks about the use
of this facility.

\endcom

\begingfcom{add-direct-method}

\Syntaxlabel

\Defgen {add-direct-method} {specializer method}

\Argumentslabel

The {\it specializer\/} argument is a specializer metaobject.

The {\it method\/} argument is a method metaobject.

\Valueslabel

The value returned by this generic function is unspecified.

\Purposelabel

This generic function is called to maintain a set of backpointers from a
specializer to the set of methods specialized to it.  If {\it method\/} is
already in the set, it is not added again (no error is signaled).

This set can be accessed as a list by calling the generic function {\bf
specializer-direct-methods}.  Methods are removed from the set by {\bf
remove-direct-method}.

The generic function {\bf add-direct-method} is called by &add-method;
whenever a method is added to a generic function.  It is called once for each
of the specializers of the method.  Note that in cases where a specializer
appears more than once in the specializers of a method, this generic function
will be called more than once with the same specializer as argument.

The results are undefined if the {\it specializer\/} argument is not one of the
specializers of the {\it method\/} argument.

\Methodslabel

\Defmeth {add-direct-method} {{({\it specializer\/} class)\\
                               ({\it method\/} method)}}

This method implements the behavior of the generic function for class
specializers.  No behavior is specified for this method beyond that which is
specified for the generic function.

This method cannot be overridden unless the following methods are
overridden as well:

\begin{methods}
\method{remove-direct-method}{class method}\\
\method{specializer-direct-generic-functions}{class}\\
\method{specializer-direct-methods}{class}
\end{methods}

\Defmeth {add-direct-method} {{({\it specializer\/} eql-specializer)\\
                               ({\it method\/} method)}}

This method implements the behavior of the generic function for {\bf eql}
specializers.  No behavior is specified for this method beyond that which is
specified for the generic function.

\endcom

\begingfcom{add-direct-subclass}

\Syntaxlabel

\Defgen {add-direct-subclass} {superclass subclass}

\Argumentslabel

The {\it superclass\/} argument is a class metaobject.

The {\it subclass\/} argument is a class metaobject.

\Valueslabel

The value returned by this generic function is unspecified.

\Purposelabel

This generic function is called to maintain a set of backpointers from a class
to its direct subclasses.  This generic function adds {\it subclass\/} to the
set of direct subclasses of {\it superclass}.

When a class is initialized, this generic function is called once for each
direct superclass of the class.

When a class is reinitialized, this generic function is called once for each
added direct superclass of the class.  The generic function {\bf
remove-direct-subclass} is called once for each deleted direct superclass of
the class.

\Methodslabel

\Defmeth {add-direct-subclass} {{({\it superclass\/} class)\\
                                 ({\it subclass\/} class)}}

No behavior is specified for this method beyond that which is specified for
the generic function.

This method cannot be overridden unless the following methods are overridden
as well:

\begin{methods}
\method{remove-direct-subclass}{class class}\\
\method{class-direct-subclasses}{class}
\end{methods}

\endcom

\begingfcom{add-method}

\Syntaxlabel

\Defgen {add-method} {generic-function method}

\Argumentslabel

The {\it generic-function\/} argument is a generic function metaobject.

The {\it method\/} argument is a method metaobject.

\Valueslabel

The {\it generic-function\/} argument is returned.

\Purposelabel

This generic function associates an unattached method with a generic function.

An error is signaled if the lambda list of the method is not congruent with
the lambda list of the generic function.  An error is also signaled if the
method is already associated with some other generic function.

If the given method agrees with an existing method of the generic function on
parameter specializers and qualifiers, the existing method is removed by
calling {\bf remove-method} before the new method is added.  See the section
of the &clos; Specification called ``Agreement on Parameter Specializers and
Qualifiers'' for a definition of agreement in this context.

Associating the method with the generic function then proceeds in four steps:
(i) add {\it method\/} to the set returned by {\bf generic-function-methods} and
arrange for {\bf method-generic-function} to return {\it generic-function};
(ii) call {\bf add-direct-method} for each of the method's specializers; (iii)
call {\bf compute-discriminating-function} and install its result with {\bf
set-funcallable-instance-function}; and (iv) update the dependents of the
generic function.

The generic function &add-method; can be called by the user or the
implementation.

\Methodslabel

\Defmeth {add-method} {{({\it generic-function\/} standard-generic-function)\\
                        ({\it method\/} standard-method)}}

No behavior is specified for this method beyond that which is specified for
the generic function.

\endcom

\begingfcom{allocate-instance}

\Syntaxlabel

\Defgen {allocate-instance} {class {\rest} {\it initargs\/}}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

The {\it initargs\/} argument consists of alternating initialization argument
names and values.

\Valueslabel

The value returned is a newly allocated instance of {\it class}.

\Purposelabel

This generic function is called to create a new, uninitialized instance of a
class.  The interpretation of the concept of an ``uninitialized'' instance
depends on the class metaobject class.

Before allocating the new instance, {\bf class-finalized-p} is called to
see if {\it class\/} has been finalized.  If it has not been finalized,
{\bf finalize-inheritance} is called before the new instance is
allocated.

\Methodslabel

\Defmeth {allocate-instance}
         {({\it class\/} standard-class) {\rest} {\it initargs}}

This method allocates storage in the instance for each slot with allocation
{\bf :instance}.  These slots are unbound.  Slots with any other allocation
are ignored by this method (no error is signaled).

\Defmeth {allocate-instance}
         {({\it class\/} funcallable-standard-class) {\rest} {\it initargs}}

This method allocates storage in the instance for each slot with allocation
{\bf :instance}.  These slots are unbound.  Slots with any other allocation
are ignored by this method (no error is signaled).

The funcallable instance function of the instance is undefined---the results
are undefined if the instance is applied to arguments before {\bf
set-funcallable-instance-function} has been used to set the funcallable
instance function.

\Defmeth {allocate-instance}
         {({\it class\/} built-in-class) {\rest} {\it initargs}}

This method signals an error.

\endcom

\begincom{class-\dots}\ftype{Generic Function}

{The following generic functions are described together under ``Readers for
Class Metaobjects'' (page~\pageref{class-mo-readers}): {\bf
class-default-initargs}, {\bf class-direct-default-initargs}, {\bf
class-direct-slots}, {\bf class-direct-subclasses}, {\bf
class-direct-superclasses}, {\bf class-finalized-p}, {\bf class-name}, {\bf
class-precedence-list}, {\bf class-prototype} and {\bf class-slots}.
\tolerant\tolerant\tolerant\par}

\endcom

\begingfcom{compute-applicable-methods}

\Syntaxlabel

\Defgen {compute-applicable-methods} {generic-function arguments}

\Argumentslabel

The {\it generic-function\/} argument is a generic function metaobject.

The {\it arguments\/} argument is a list of objects.

\Valueslabel

This generic function returns a possibly empty list of method metaobjects.

\Purposelabel

This generic function determines the method applicability of a generic
function given a list of required arguments.  The returned list of method
metaobjects is sorted by precedence order with the most specific method
appearing first.  If no methods are applicable to the supplied arguments the
empty list is returned.

When a generic function is invoked, the discriminating function must determine
the ordered list of methods applicable to the arguments.  Depending on the
generic function and the arguments, this is done in one of three ways: using a
memoized value; calling {\bf compute-applicable-methods-using-classes}; or
calling {\bf compute-applicable-methods}.  (Refer to the description of {\bf
compute-discriminating-function} for the details of this process.)

The {\it arguments\/} argument is permitted to contain more elements than the
generic function accepts required arguments; in these cases the extra
arguments will be ignored.  An error is signaled if {\it arguments\/} contains
fewer elements than the generic function accepts required arguments.

The list returned by this generic function will not be mutated by the
implementation.  The results are undefined if a portable program mutates the
list returned by this generic function.

\Methodslabel

\Defmeth {compute-applicable-methods}
         {{({\it generic-function} standard-generic-function)\\
                {\it arguments\/}}}

This method signals an error if any method of the generic function has a
specializer which is neither a class metaobject nor an {\bf eql} specializer
metaobject.

Otherwise, this method computes the sorted list of applicable methods
according to the rules described in the section of the &clos; Specification called
``Method Selection and Combination.''

{This method can be overridden.  Because of the consistency requirements
between this generic function and {\bf
compute-applicable-methods-using-classes}, doing so may require also
overriding
\method{compute-applicable-methods-using-classes}{standard-generic-function
t}.\tolerant\tolerant\tolerant\par}

\endcom

\begingfcom{compute-applicable-methods-using-classes}

\Syntaxlabel

\Defgen {compute-applicable-methods-using-classes} {generic-function classes}

\Argumentslabel

The {\it generic-function\/} argument is a generic function metaobject.

The {\it classes\/} argument is a list of class metaobjects.

\Valueslabel

This generic function returns two values.  The first is a possibly empty
list of method metaobjects.  The second is either true or false.

\Purposelabel

This generic function is called to attempt to determine the method
applicability of a generic function given only the classes of the required
arguments.

If it is possible to completely determine the ordered list of applicable
methods based only on the supplied classes, this generic function returns that
list as its first value and true as its second value.  The returned list of
method metaobjects is sorted by precedence order, the most specific method
coming first.  If no methods are applicable to arguments with the specified
classes, the empty list and true are returned.

If it is not possible to completely determine the ordered list of applicable
methods based only on the supplied classes, this generic function returns an
unspecified first value and false as its second value.

When a generic function is invoked, the discriminating function must determine
the ordered list of methods applicable to the arguments.  Depending on the
generic function and the arguments, this is done in one of three ways: using a
memoized value; calling {\bf compute-applicable-methods-using-classes}; or
calling {\bf compute-applicable-methods}.  (Refer to the description of {\bf
compute-discriminating-function} for the details of this process.)

{The following consistency relationship between {\bf
compute-applicable-methods-using-classes} and {\bf compute-applicable-methods}
must be maintained:  for any given generic function and set of arguments, if
{\bf compute-applicable-methods-using-classes} returns a second value of true,
the first value must be equal to the value that would be returned by a
corresponding call to {\bf compute-applicable-methods}.  The results are
undefined if a portable method on either of these generic functions causes
this consistency to be violated.\par}

The list returned by this generic function will not be mutated by the
implementation.  The results are undefined if a portable program mutates the
list returned by this generic function.

\Methodslabel

\Defmeth {compute-applicable-methods-using-classes}
         {{({\it generic-function\/} standard-generic-function)\\
                {\it classes\/}}}

If any method of the generic function has a specializer which is neither a
class metaobject nor an {\bf eql} specializer metaobject, this method signals
an error.

In cases where the generic function has no methods with {\bf eql}
specializers, or has no methods with {\bf eql} specializers that could be
applicable to arguments of the supplied classes, this method returns the
ordered list of applicable methods as its first value and true as its second
value.

Otherwise this method returns an unspecified first value and false as its
second value.

This method can be overridden. Because of the consistency requirements between
this generic function and {\bf compute-applicable-methods}, doing so may
require also overriding
\method{compute-applicable-methods}{standard-generic-function t}.

\Remarkslabel

This generic function exists to allow user extensions which alter method
lookup rules, but which base the new rules only on the classes of the required
arguments, to take advantage of the class-based method lookup memoization
found in many implementations.  (There is of course no requirement for an
implementation to provide this optimization.)

Such an extension can be implemented by two methods, one on this generic
function and one on {\bf compute-applicable-methods}.  Whenever the user
extension is in effect, the first method will return a second value of true.
This should allow the implementation to absorb these cases into its own
memoization scheme.

To get appropriate performance, other kinds of extensions may require methods
on {\bf compute-discriminating-function} which implement their own memoization
scheme.

\endcom

\begingfcom{compute-class-precedence-list}

\Syntaxlabel

\Defgen {compute-class-precedence-list} {class}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

\Valueslabel

The value returned by this generic function is a list of class metaobjects.

\Purposelabel

This generic-function is called to determine the class precedence list of a
class.

The result is a list which contains each of {\it class\/} and its superclasses
once and only once.  The first element of the list is {\it class\/} and the last
element is the class named {\bf t}.

All methods on this generic function must compute the class precedence
list as a function of the ordered direct superclasses of the
superclasses of {\it class\/}.  The results are undefined if the rules
used to compute the class precedence list depend on any other factors.

When a class is finalized, {\bf finalize-inheritance} calls this generic
function and associates the returned value with the class metaobject.
The value can then be accessed by calling {\bf class-precedence-list}.

The list returned by this generic function will not be mutated by the
implementation.  The results are undefined if a portable program mutates the
list returned by this generic function.

\Methodslabel

\Defmeth {compute-class-precedence-list} {({\it class\/} class)}

This method computes the class precedence list according to the rules
described in the section of the &clos; Specification called ``Determining the Class
Precedence List.''

This method signals an error if {\it class\/} or any of its superclasses is a
forward referenced class.

This method can be overridden.

\endcom

\begingfcom{compute-default-initargs}

\Syntaxlabel

\Defgen {compute-default-initargs} {class}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

\Valueslabel

The value returned by this generic function is a list of canonicalized default
initialization arguments.

\Purposelabel

This generic-function is called to determine the default initialization
arguments for a class.

The result is a list of canonicalized default initialization arguments, with
no duplication among initialization argument names.

All methods on this generic function must compute the default initialization
arguments as a function of only: (i) the class precedence list of {\it class\/},
and (ii) the direct default initialization arguments of each class in that
list.  The results are undefined if the rules used to compute the default
initialization arguments depend on any other factors.

When a class is finalized, {\bf finalize-inheritance} calls this generic
function and associates the returned value with the class metaobject.  The
value can then be accessed by calling {\bf class-default-initargs}.

The list returned by this generic function will not be mutated by the
implementation.  The results are undefined if a portable program mutates the
list returned by this generic function.

\Methodslabel

\Defmeth {compute-default-initargs} {({\it class\/} standard-class)}
\Defmeth {compute-default-initargs} {({\it class\/} funcallable-standard-class)}

These methods compute the default initialization arguments according to the
rules described in the section of the &clos; Specification called ``Defaulting
of Initialization Arguments.''

These methods signal an error if {\it class\/} or any of its superclasses is a
forward referenced class.

These methods can be overridden.

\endcom

\begingfcom{compute-discriminating-function}

\Syntaxlabel

\Defgen {compute-discriminating-function} {generic-function}

\Argumentslabel

The {\it generic-function\/} argument is a generic function metaobject.

\Valueslabel

The value returned by this generic function is a function.

\Purposelabel

This generic function is called to determine the discriminating function for a
generic function.  When a generic function is called, the {\em installed\/}
discriminating function is called with the full set of arguments received by
the generic function, and must implement the behavior of calling the generic
function:  determining the ordered set of applicable methods, determining the
effective method, and running the effective method.

{To determine the ordered set of applicable methods, the discriminating
function first calls {\bf compute-applicable-methods-using-classes}.  If
{\bf compute-applicable-methods-using-classes} returns a second value of
false, the discriminating function then calls {\bf
compute-applicable-methods}.\tolerant\tolerant\tolerant\par}

When {\bf compute-applicable-methods-using-classes} returns a second value of
true, the discriminating function is permitted to memoize the first returned
value as follows.  The discriminating function may reuse the list of
applicable methods without calling {\bf
compute-applicable-methods-using-classes} again provided that:

\begin{unlabeled}

\item(i) the generic function is being called again with required arguments
which are instances of the same classes,

\item(ii) the generic function has not been reinitialized,

\item(iii) no method has been added to or removed from the generic function,

\item(iv) for all the specializers of all the generic function's methods
which are classes, their class precedence lists have not changed and

\item(v) for any such memoized value, the class precedence list of the class
of each of the required arguments has not changed.

\end{unlabeled}

Determination of the effective method is done by calling {\bf
compute-effective-method}.  When the effective method is run, each method's
function is called, and receives as arguments: (i) a list of the arguments to
the generic function, and (ii) whatever other arguments are specified in the
{\bf call-method} form indicating that the method should be called.  (See {\bf
make-method-lambda} for more information about how method functions are
called.)

{The generic function {\bf compute-discriminating-function} is called, and its
result installed, by &add-method;, {\bf remove-method}, {\bf
initialize-instance} and {\bf reinitialize-instance}.\tolerant\tolerant\tolerant\par}

\Methodslabel

\Defmeth {compute-discriminating-function}
         {({\it generic-function\/} standard-generic-function)}

No behavior is specified for this method beyond that specified for the generic
function.

This method can be overridden.

\endcom

\begingfcom{compute-effective-method}

\Syntaxlabel

\Defgen {compute-effective-method} {generic-function method-combination methods}

\Argumentslabel

The {\it generic-function\/} argument is a generic function metaobject.

The {\it method-combination\/} argument is a method combination metaobject.

The {\it methods\/} argument is a list of method metaobjects.

\Valueslabel

This generic function returns two values.  The first is an effective method,
the second is a list of effective method options.

\Purposelabel

This generic function is called to determine the effective method from a
sorted list of method metaobjects.

An effective method is a form that describes how the applicable methods are to
be combined.  Inside of effective method forms are {\bf call-method} forms
which indicate that a particular method is to be called.  The arguments to the
{\bf call-method} form indicate exactly how the method function of the method
should be called.  (See {\bf make-method-lambda} for more details about method
functions.)

An effective method option has the same interpretation and syntax as either
the {\bf :arguments} or the {\bf :generic-function} option in the long form of
{\bf define-method-combination}.

More information about the form and interpretation of effective methods and
effective method options can be found under the description of the {\bf
define-method-combination} macro in the &clos; specification.

This generic function can be called by the user or the implementation.  It is
called by discriminating functions whenever a sorted list of applicable
methods must be converted to an effective method.

\Methodslabel

\Defmeth {compute-effective-method}
         {{({\it generic-function\/} standard-generic-function)\\
            {\it method-combination}\\
            {\it methods}}}

This method computes the effective method according to the rules of the
method combination type implemented by {\it method-combination}.

This method can be overridden.

\endcom

\begingfcom{compute-effective-slot-definition}

\Syntaxlabel

\Defgen {compute-effective-slot-definition}
        {class name direct-slot-definitions}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

The {\it name\/} argument is a slot name.

The {\it direct-slot-definitions\/} argument is an ordered list of direct
slot definition metaobjects.  The most specific direct slot definition
metaobject appears first in the list.

\Valueslabel

The value returned by this generic function is an effective slot definition
metaobject.

\Purposelabel

This generic function determines the effective slot definition for a slot in a
class.  It is called by {\bf compute-slots} once for each slot accessible in
instances of {\it class}.

This generic function uses the supplied list of direct slot definition
metaobjects to compute the inheritance of slot properties for a single slot.
The returned effective slot definition represents the result of computing the
inheritance.  The name of the new effective slot definition is the same as the
name of the direct slot definitions supplied.

{The class of the effective slot definition metaobject is determined by calling
{\bf effective-slot-definition-class}.  The effective slot definition is then
created by calling {\bf make-instance}.  The initialization arguments passed
in this call to {\bf make-instance} are used to initialize the new effective
slot definition metaobject.  See ``Initialization of Slot Definition
Metaobjects'' for details.\tolerant\tolerant\tolerant\par}

\Methodslabel

\Defmeth {compute-effective-slot-definition}
         {{({\it class\/} standard-class)\\
                {\it name}\\
                {\it direct-slot-definitions}}}

This method implements the inheritance and defaulting of slot options
following the rules described in the ``Inheritance of Slots and
Options'' section of the &clos; Specification.

This method can be extended, but the value returned by the extending method
must be the value returned by this method.

\Defmeth {compute-effective-slot-definition}
         {{({\it class\/} funcallable-standard-class)\\
          {\it name}\\
          {\it direct-slot-definitions}}}

This method implements the inheritance and defaulting of slot options
following the rules described in the ``Inheritance of Slots and
Options'' section of the &clos; Specification.

This method can be extended, but the value returned by the extending method
must be the value returned by this method.

\endcom

\begingfcom{compute-slots}

\Syntaxlabel

\Defgen {compute-slots} {class}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

\Valueslabel

The value returned is a set of effective slot definition metaobjects.

\Purposelabel

This generic function computes a set of effective slot definition
metaobjects for the class {\it class\/}.  The result is a list of
effective slot definition metaobjects: one for each slot that will be
accessible in instances of {\it class}.

This generic function proceeds in 3 steps:

The first step collects the full set of direct slot definitions from the
superclasses of {\it class}.

The direct slot definitions are then collected into individual lists, one list
for each slot name associated with any of the direct slot definitions.  The
slot names are compared with {\bf eql}.  Each such list is then sorted into
class precedence list order.  Direct slot definitions coming from classes
earlier in the class precedence list of {\it class\/} appear before those coming
from classes later in the class precedence list.  For each slot name, the
generic function {\bf compute-effective-slot-definition} is called to compute
an effective slot definition.  The result of {\bf compute-slots} is a list of
these effective slot definitions, in unspecified order.

In the final step, the location for each effective slot definition is set.
This is done by specified around-methods; portable methods cannot take over
this behavior. For more information on the slot definition locations, see the
section ``Instance Structure Protocol.''

The list returned by this generic function will not be mutated by the
implementation.  The results are undefined if a portable program mutates the
list returned by this generic function.

\Methodslabel

\Defmeth {compute-slots} {({\it class\/} standard-class)}

This method implements the specified behavior of the generic function.

This method can be overridden.

\Defmeth {compute-slots} {({\it class\/} funcallable-standard-class)}

This method implements the specified behavior of the generic function.

This method can be overridden.

\Defmetharound {compute-slots} {({\it class\/} standard-class)}

This method implements the specified behavior of computing and storing slot
locations.  This method cannot be overridden.

\Defmetharound {compute-slots} {({\it class\/} funcallable-standard-class)}

This method implements the specified behavior of computing and storing slot
locations.  This method cannot be overridden.

\endcom

\begingfcom{direct-slot-definition-class}

\Syntaxlabel

\Defgen {direct-slot-definition-class} {class {\rest} initargs}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

The {\it initargs\/} argument is a set of initialization arguments and values.

\Valueslabel

The value returned is a subclass of the class {\bf direct-slot-definition}.

\Purposelabel

When a class is initialized, each of the canonicalized slot specifications must
be converted to a direct slot definition metaobject.  This generic function is
called to determine the class of that direct slot definition metaobject.

The {\it initargs\/} argument is simply the canonicalized slot specification for
the slot.

\Methodslabel

\Defmeth {direct-slot-definition-class}
               {{({\it class\/} standard-class)\\
                 {\rest} {\it initargs}}}

This method returns the class {\bf standard-direct-slot-definition}.

This method can be overridden.

\Defmeth {direct-slot-definition-class}
               {{({\it class\/} funcallable-standard-class)\\
                 {\rest} {\it initargs}}}

This method returns the class {\bf standard-direct-slot-definition}.

This method can be overridden.

\endcom

\begingfcom{effective-slot-definition-class}

\Syntaxlabel

\Defgen {effective-slot-definition-class} {class {\rest} initargs}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

The {\it initargs\/} argument is a set of initialization arguments and values.

\Valueslabel

The value returned is a subclass of the class {\bf
effective-slot-definition-class}.

\Purposelabel

This generic function is called by {\bf compute-effective-slot-definition} to
determine the class of the resulting effective slot definition metaobject.
The {\it initargs\/} argument is the set of initialization arguments and values
that will be passed to {\bf make-instance} when the effective slot definition
metaobject is created.

\Methodslabel

\Defmeth {effective-slot-definition-class}
               {{({\it class\/} standard-class)\\
                 {\rest} initargs}}

This method returns the class {\bf standard-effective-slot-definition}.

This method can be overridden.

\Defmeth {effective-slot-definition-class}
               {{({\it class\/} funcallable-standard-class)\\
                 {\rest} initargs}}

This method returns the class {\bf standard-effective-slot-definition}.

This method can be overridden.

\endcom

% *** ENSURE-XXX ***
\beginfncom{ensure-class}

\Syntaxlabel

\Defun {ensure-class} {name \key {\tt \&allow-other-keys}}


\Argumentslabel

The {\it name\/} argument is a symbol.

Some of the keyword arguments accepted by this function are actually processed
by {\bf ensure-class-using-class}, others are processed during initialization
of the class metaobject (as described in the section called ``Initialization
of Class Metaobjects'').

\Valueslabel

The result is a class metaobject.

\Purposelabel

This function is called to define or redefine a class with the specified name,
and can be called by the user or the implementation.  It is the functional
equivalent of &defclass;, and is called by the expansion of the &defclass; macro.

The behavior of this function is actually implemented by the generic function
{\bf ensure-class-using-class}.  When {\bf ensure-class} is called, it
immediately calls {\bf ensure-class-using-class} and returns that result as
its own.

The first argument to {\bf ensure-class-using-class} is computed as follows:

<itemizedlist>

\item If {\it name\/} names a class ({\bf find-class} returns a class when
called with {\it name}) use that class.

\item Otherwise use &nil;.

</itemizedlist>

\noindent The second argument is {\it name}.  The remaining arguments are the
complete set of keyword arguments received by the {\bf ensure-class} function.

\endcom

\begingfcom{ensure-class-using-class}

\Syntaxlabel

\Defgen {ensure-class-using-class}
        {class name\/ \vtop{\hbox{\key \vtop{\hbox{{:direct-default-initargs} {:direct-slots}}
                                             \hbox{{:direct-superclasses} {:name}}
                                             \hbox{{:metaclass}}}}
                            \hbox{{\tt \&allow-other-keys}}}}

\Argumentslabel

The {\it class\/} argument is a class metaobject or &nil;.

The {\it name\/} argument is a class name.

The {\bf :metaclass} argument is a class metaobject class or a class
metaobject class name.  If this argument is not supplied, it defaults to the
class named {\bf standard-class}.   If a class name is supplied, it is
interpreted as the class with that name.  If a class name is supplied, but
there is no such class, an error is signaled.

The {\bf :direct-superclasses} argument is a list of which each element is a
class metaobject or a class name.  An error is signaled if this argument is
not a proper list.

For the interpretation of additional keyword arguments, see ``Initialization
of Class Metaobjects'' (page~\pageref{class-mo-init}).

\Valueslabel

The result is a class metaobject.

\Purposelabel

This generic function is called to define or modify the definition of a named
class.  It is called by the {\bf ensure-class} function.  It can also be
called directly.

The first step performed by this generic function is to compute the set of
initialization arguments which will be used to create or reinitialize the
named class.  The initialization arguments are computed from the full set of
keyword arguments received by this generic function as follows:

<itemizedlist>
\item The {\bf :metaclass} argument is not included in the initialization
arguments.

\item If the {\bf :direct-superclasses} argument was received by this
generic function, it is converted into a list of class metaobjects.  This
conversion does not affect the structure of the supplied {\bf
:direct-superclasses} argument.  For each element in the {\bf
:direct-superclasses} argument:

<itemizedlist>

\item If the element is a class metaobject, that class metaobject is used.

\item If the element names a class, that class metaobject is used.

\item Otherwise an instance of the class {\bf forward-referenced-class} is
created and used.  The proper name of the newly created forward referenced
class metaobject is set to {\it name}.

</itemizedlist>

\item All other keyword arguments are included directly in the initialization
arguments.

</itemizedlist>

If the {\it class\/} argument is &nil;, a new class metaobject is created by
calling the {\bf make-instance} generic function with the value of the {\bf
:metaclass} argument as its first argument, and the previously computed
initialization arguments.  The proper name of the newly created class
metaobject is set to {\it name}.  The newly created class metaobject is
returned.

If the {\it class\/} argument is a forward referenced class, {\bf change-class}
is called to change its class to the value specified by the {\bf :metaclass}
argument.  The class metaobject is then reinitialized with the previously
initialization arguments.  (This is a documented violation of the general
constraint that {\bf change-class} not be used with class metaobjects.)

If the class of the {\it class\/} argument is not the same as the class
specified by the {\bf :metaclass} argument, an error is signaled.

Otherwise, the class metaobject {\it class\/} is redefined by calling the {\bf
reinitialize-instance} generic function with {\it class\/} and the
initialization arguments.  The {\it class\/} argument is then returned.

\Methodslabel

\Defmeth {ensure-class-using-class}
         {\vtop{\hbox{({\it class\/} class)}
                \hbox{{\it name}}
                \hbox{\key \vtop{\hbox{:metaclass}
                                 \hbox{:direct-superclasses}}}
                \hbox{{\tt \&allow-other-keys}}}}

This method implements the behavior of the generic function in the case where
the {\it class\/} argument is a class.

This method can be overridden.

\Defmeth {ensure-class-using-class}
         {\vtop{\hbox{({\it class\/} forward-referenced-class)}
                \hbox{{\it name}}
                \hbox{\key \vtop{\hbox{:metaclass}
                                 \hbox{:direct-superclasses}}}
                \hbox{{\tt \&allow-other-keys}}}}

This method implements the behavior of the generic function in the case where
the {\it class\/} argument is a forward referenced class.

\Defmeth {ensure-class-using-class}
         {\vtop{\hbox{({\it class\/} null)}
                \hbox{{\it name}}
                \hbox{\key \vtop{\hbox{:metaclass}
                                 \hbox{:direct-superclasses}}}
                \hbox{{\tt \&allow-other-keys}}}}

This method implements the behavior of the generic function in the case where
the {\it class\/} argument is &nil;.

\endcom

\beginfncom{ensure-generic-function}

\Syntaxlabel

\Defun {ensure-generic-function}
       {function-name \key {\tt \&allow-other-keys}}

\Argumentslabel

The {\it function-name\/} argument is a symbol or a list of the form {\tt
(setf {\it symbol\/})}.

Some of the keyword arguments accepted by this function are actually processed
by {\bf ensure-generic-function-using-class}, others are processed during
initialization of the generic function metaobject (as described in the section
called ``Initialization of Generic Function Metaobjects'').


\Valueslabel

The result is a generic function metaobject.

\Purposelabel

This function is called to define a globally named generic function or to
specify or modify options and declarations that pertain to a globally named
generic function as a whole.  It can be called by the user or the
implementation.

It is the functional equivalent of &defgeneric;, and is called by the
expansion of the &defgeneric; and &defmethod; macros.

The behavior of this function is actually implemented by the generic function
{\bf ensure-generic-function-using-class}.  When {\bf ensure-generic-function}
is called, it immediately calls {\bf ensure-generic-function-using-class} and
returns that result as its own.

The first argument to {\bf ensure-generic-function-using-class} is computed as
follows:

<itemizedlist>

\item If {\it function-name\/} names a non-generic function, a macro, or a
special form, an error is signaled.

\item If {\it function-name\/} names a generic function, that generic function
metaobject is used.

\item Otherwise, &nil; is used.

</itemizedlist>

The second argument is {\it function-name}.  The remaining arguments are the
complete set of keyword arguments received by {\bf ensure-generic-function}.

\endcom

\begingfcom{ensure-generic-function-using-class}

\Syntaxlabel

\Defgen {ensure-generic-function-using-class}
        {\vtop{\hbox{{\it generic-function}}
               \hbox{{\it function-name}}
               \hbox{\key \vtop{\hbox{{:argument-precedence-order} {:declarations}}
                                \hbox{{:documentation} {:generic-function-class}}
                                \hbox{{:lambda-list} {:method-class}}
                                \hbox{{:method-combination} {:name}}}}
               \hbox{{\tt \&allow-other-keys}}}}

\Argumentslabel

The {\it generic-function\/} argument is a generic function metaobject or {\bf
nil}.

The {\it function-name\/} argument is a symbol or a list of the form {\tt
(setf {\it symbol\/})}.

The {\bf :generic-function-class} argument is a class metaobject or a class
name.  If it is not supplied, it defaults to the class named {\bf
standard-generic-function}.  If a class name is supplied, it is interpreted as
the class with that name.  If a class name is supplied, but there is no such
class, an error is signaled.

For the interpretation of additional keyword arguments, see ``Initialization
of Generic Function Metaobjects'' (page~\pageref{gf-mo-init}).

\Valueslabel

The result is a generic function metaobject.

\Purposelabel

The generic function {\bf ensure-generic-function-using-class} is called to
define or modify the definition of a globally named generic function.  It is
called by the {\bf ensure-generic-function} function.  It can also be called
directly.

The first step performed by this generic function is to compute the set of
initialization arguments which will be used to create or reinitialize the
globally named generic function.  These initialization arguments are computed
from the full set of keyword arguments received by this generic function as
follows:

<itemizedlist>
\item The {\bf :generic-function-class} argument is not included in the
initialization arguments.

\item If the {\bf :method-class} argument was received by this generic
function, it is converted into a class metaobject.  This is done by looking up
the class name with {\bf find-class}.  If there is no such class, an error is
signalled.

\item All other keyword arguments are included directly in the initialization
arguments.

</itemizedlist>

If the {\it generic-function\/} argument is &nil;, an instance of the class
specified by the {\bf :generic-function-class} argument is created by calling
{\bf make-instance} with the previously computed initialization arguments.
The function name {\it function-name\/} is set to name the generic function.
The newly created generic function metaobject is returned.

If the class of the {\it generic-function\/} argument is not the same as the
class specified by the {\bf :generic-function-class} argument, an error is
signaled.

Otherwise the generic function {\it generic-function\/} is redefined by calling
the {\bf reinitialize-instance} generic function with {\it generic-function\/}
and the initialization arguments.  The {\it generic-function\/} argument is then
returned.

\Methodslabel

\Defmeth {ensure-generic-function-using-class}
         {\vtop{\hbox{({\it generic-function\/} generic-function)}
                \hbox{{\it function-name}}
                \hbox{\key \vtop{\hbox{:generic-function-class}}}
                \hbox{{\tt \&allow-other-keys}}}}

This method implements the behavior of the generic function in the case where
{\it function-name\/} names an existing generic function.

This method can be overridden.

\Defmeth {ensure-generic-function-using-class}
         {\vtop{\hbox{({\it generic-function\/} null)}
                \hbox{{\it function-name}}
                \hbox{\key \vtop{\hbox{:generic-function-class}}}
               \hbox{{\tt \&allow-other-keys}}}}

This method implements the behavior of the generic function in the case where
{\it function-name\/} names no function, generic function, macro or special
form.

\endcom

\beginfncom{eql-specializer-object}

\Syntaxlabel

\Defun {eql-specializer-object} {eql-specializer}

\Argumentslabel

The {\it eql-specializer\/} argument is an {\bf eql} specializer metaobject.

\Valueslabel

The value returned by this function is an object.

\Purposelabel

This function returns the object associated with {\it eql-specializer\/} during
initialization.  The value is guaranteed to be {\bf eql} to the value
originally passed to {\bf intern-eql-specializer}, but it is not necessarily
{\bf eq} to that value.

This function signals an error if {\it eql-specializer\/} is not an {\bf eql}
specializer.

\endcom

\beginfncom{extract-lambda-list}

\Syntaxlabel

\Defun {extract-lambda-list} {specialized-lambda-list}

\Argumentslabel

The {\it specialized-lambda-list\/} argument is a specialized lambda list as
accepted by {\bf def\-method}.

\Valueslabel

The result is an unspecialized lambda list.

\Purposelabel

This function takes a specialized lambda list and returns the lambda list with
the specializers removed.  This is a non-destructive operation.  Whether the
result shares any structure with the argument is unspecified.

If the {\it specialized-lambda-list\/} argument does not have legal syntax, an
error is signaled.  This syntax checking does not check the syntax of the
actual specializer names, only the syntax of the lambda list and where the
specializers appear.

\Exampleslabel

\begin{lispcode}
(extract-lambda-list '((p position)))             ==> (P)

(extract-lambda-list '((p position) x y))         ==> (P X Y)

(extract-lambda-list '(a (b (eql x)) c &rest i))  ==> (A B C &OPTIONAL I)
\end{lispcode}

\endcom

\beginfncom{extract-specializer-names}

\Syntaxlabel

\Defun {extract-specializer-names} {specialized-lambda-list}

\Argumentslabel

The {\it specialized-lambda-list\/} argument is a specialized lambda list as
accepted by {\bf def\-method}.

\Valueslabel

The result is a list of specializer names.

\Purposelabel

This function takes a specialized lambda list and returns its specializer
names.  This is a non-destructive operation.  Whether the result shares
structure with the argument is unspecified.  The results are undefined if the
result of this function is modified.

The result of this function will be a list with a number of elements equal to
the number of required arguments in {\it specialized-lambda-list\/}.
Specializers are defaulted to the symbol {\bf t}.

If the {\it specialized-lambda-list\/} argument does not have legal syntax, an
error is signaled.  This syntax checking does not check the syntax of the
actual specializer names, only the syntax of the lambda list and where the
specializers appear.

\Exampleslabel

\begin{lispcode}
(extract-specializer-names '((p position)))            ==> (POSITION)

(extract-specializer-names '((p position) x y))        ==> (POSITION T T)

(extract-specializer-names '(a (b (eql x)) c &rest i)) ==> (T (EQL X) T)
\end{lispcode}

\endcom

\begingfcom{finalize-inheritance}

\Syntaxlabel

\Defgen {finalize-inheritance} {class}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

\Valueslabel

The value returned by this generic function is unspecified.

\Purposelabel

This generic function is called to finalize a class metaobject.  This is
described in the Section named ``Class Finalization Protocol.''

After {\bf finalize-inheritance} returns, the class metaobject is finalized
and the result of calling {\bf class-finalized-p} on the class metaobject will
be true.

\Methodslabel

\Defmeth {finalize-inheritance} {({\it class\/} standard-class)}
\Defmeth {finalize-inheritance} {({\it class\/} funcallable-standard-class)}

No behavior is specified for these methods beyond that which is specified for
the generic function.

\Defmeth {finalize-inheritance} {({\it class\/} forward-referenced-class)}

This method signals an error.

\endcom

\begingfcom{find-method-combination}

\Syntaxlabel

\Defgen {find-method-combination} {     {generic-function\\
                                         method-combination-type-name\\
                                         method-combination-options}}

\Argumentslabel

The {\it generic-function\/} argument is a generic function metaobject.

The {\it method-combination-type-name\/} argument is a symbol which names a type
of method combination.

The {\it method-combination-options\/} argument is a list of arguments to the
method combination type.

\Valueslabel

The value returned by this generic function is a method combination
metaobject.

\Purposelabel

This generic function is called to determine the method combination object
used by a generic function.

\Remarkslabel

Further details of method combination metaobjects are not specified.

\endcom

\beginfncom{funcallable-standard-instance-access}

\Syntaxlabel

\Defun {funcallable-standard-instance-access} {instance location}

\Argumentslabel

The {\it instance\/} argument is an object.

The {\it location\/} argument is a slot location.

\Valueslabel

The result of this function is an object.

\Purposelabel

This function is called to provide direct access to a slot in an instance.  By
usurping the normal slot lookup protocol, this function is intended to provide
highly optimized access to the slots associated with an instance.

The following restrictions apply to the use of this function:

<itemizedlist>
\item The {\it instance\/} argument must be a funcallable instance (it must have
been returned by \method{allocate-instance}{funcallable-standard-class}).

\item The {\it instance\/} argument cannot be an non-updated obsolete instance.

\item The {\it location\/} argument must be a location of one of the directly
accessible slots of the instance's class.

\item The slot must be bound.
</itemizedlist>

The results are undefined if any of these restrictions are not met.

\endcom

\begincom{generic-function-\dots}\ftype{Generic Function}

{The following generic functions are described together under ``Readers for
Generic Function Metaobjects'' (page~\pageref{gf-mo-readers}):  {\bf
generic-function-argument-precedence-order}, {\bf
generic-function-declarations}, {\bf generic-function-lambda-list}, {\bf
generic-function-method-class}, {\bf generic-function-method-combination},
{\bf generic-function-meth\-ods} and {\bf generic-function-name}.\tolerant\tolerant\tolerant\par}

\endcom

\newpage                % Think carefully before taking this out.  Without it,
                        % the tables in this and the next few sections probably
                        % won't come out where they are supposed to.

\begincom{Initialization of Class Metaobjects}\ftype{}\label{class-mo-init}

A class metaobject can be created by calling {\bf make-instance}.  The
initialization arguments establish the definition of the class.  A class
metaobject can be redefined by calling {\bf reinitialize-instance}.  Some
classes of class metaobject do not support redefinition; in these cases,
{\bf reinitialize-instance} signals an error.

Initialization of a class metaobject must be done by calling {\bf
make-instance} and allowing it to call {\bf initialize-instance}.
Reinitialization of a class metaobject must be done by calling {\bf
reinitialize-instance}.  Portable programs must not call {\bf
initialize-instance} directly to initialize a class metaobject. Portable
programs must not call {\bf shared-initialize} directly to initialize or
reinitialize a class metaobject.  Portable programs must not call {\bf
change-class} to change the class of any class metaobject or to turn a
non-class object into a class metaobject.

Since metaobject classes may not be redefined, no behavior is specified for
the result of calls to {\bf update-instance-for-redefined-class} on class
metaobjects.  Since the class of class metaobjects may not be changed, no
behavior is specified for the result of calls to {\bf
update-instance-for-different-class} on class metaobjects.

During initialization or reinitialization, each initialization argument is
checked for errors and then associated with the class metaobject.  The value
can then be accessed by calling the appropriate accessor as shown in
Table~\ref{class-mo-initargs}.

This section begins with a description of the error checking and processing
of each initialization argument.  This is followed by a table showing the
generic functions that can be used to access the stored initialization
arguments.  Initialization behavior specific to the different specified
class metaobject classes comes next.  The section ends with a set of
restrictions on portable methods affecting class metaobject initialization and
reinitialization.

In these descriptions, the phrase ``this argument defaults to {\it value}''
means that when that initialization argument is not supplied, initialization
or reinitialization is performed as if {\it value\/} had been supplied.  For
some initialization arguments this could be done by the use of default
initialization arguments, but whether it is done this way is not specified.
Implementations are free to define default initialization arguments for
specified class metaobject classes.  Portable programs are free to define
default initialization arguments for portable subclasses of the class {\bf
class}.

Unless there is a specific note to the contrary, then during reinitialization,
if an initialization argument is not supplied, the previously stored value is
left unchanged.

<itemizedlist>
\item The {\bf :direct-default-initargs} argument is a list of
canonicalized default initialization arguments.

An error is signaled if this value is not a proper list, or if any element
of the list is not a canonicalized default initialization argument.

If the class metaobject is being initialized, this argument defaults to the
empty list.

\item The {\bf :direct-slots} argument is a list of canonicalized
slot specifications.

An error is signaled if this value is not a proper list or if any
element of the list is not a canonicalized slot specification.

After error checking, this value is converted to a list of direct slot
definition metaobjects before it is associated with the class metaobject.
Conversion of each canonicalized slot specification to a direct slot
definition metaobject is a two-step process.  First, the generic function {\bf
direct-slot-definition-class} is called with the class metaobject and the
canonicalized slot specification to determine the class of the new direct slot
definition metaobject; this permits both the class metaobject and the
canonicalized slot specification to control the resulting direct slot
definition metaobject class.  Second, {\bf make-instance} is applied to the
direct slot definition metaobject class and the canonicalized slot
specification.  This conversion could be implemented as shown in the following
code:

\begin{lispcode}
(defun convert-to-direct-slot-definition (class canonicalized-slot)
  (apply #'make-instance
         (apply #'direct-slot-definition-class
                class canonicalized-slot)
         canonicalized-slot))
\end{lispcode}

If the class metaobject is being initialized, this argument defaults to the
empty list.

Once the direct slot definition metaobjects have been created, the specified
reader and writer methods are created.  The generic functions {\bf
reader-method-class} and {\bf writer-method-class} are called to determine the
classes of the method metaobjects created.

\item The {\bf :direct-superclasses} argument is a list of class metaobjects.
Classes which do not support multiple inheritance signal an error if the list
contains more than one element.

An error is signaled if this value is not a proper list or if {\bf
validate-superclass} applied to {\it class\/} and any element of this list
returns false.

When the class metaobject is being initialized, and this argument is either
not supplied or is the empty list, this argument defaults as follows:  if the
class is an instance of {\bf standard-class} or one of its subclasses the
default value is a list of the class {\bf standard-object}; if the class is an
instance of {\bf funcallable-standard-class} or one of its subclasses the
default value is list of the class {\bf funcallable-standard-object}.

After any defaulting of the value, the generic function {\bf
add-direct-subclass} is called once for each element of the list.

When the class metaobject is being reinitialized and this argument is
supplied, the generic function {\bf remove-direct-subclass} is called once for
each class metaobject in the previously stored value but not in the new value;
the generic function {\bf add-direct-subclass} is called once for each class
metaobject in the new value but not in the previously stored value.

\item  The {\bf :documentation} argument is a string or &nil;.

An error is signaled if this value is not a string or &nil;.

If the class metaobject is being initialized, this argument defaults to {\bf
nil}.

\item  The {\bf :name} argument is an object.

If the class is being initialized, this argument defaults to &nil;.

</itemizedlist>

After the processing and defaulting of initialization arguments described
above, the value of each initialization argument is associated with the class
metaobject.  These values can then be accessed by calling the corresponding
generic function.  The correspondences are as follows:

\begin{table}[h]
\begin{tabular}{ll}
\toprule
\bf Initialization Argument&\quad\bf Generic Function\\
\tablerule
\bf :direct-default-initargs &\quad\bf class-direct-default-initargs \\
\bf :direct-slots            &\quad\bf class-direct-slots            \\
\bf :direct-superclasses     &\quad\bf class-direct-superclasses     \\
\bf :documentation           &\quad\bf documentation                 \\
\bf :name                    &\quad\bf class-name                    \\
\bottomrule
\end{tabular}
\caption{Initialization arguments and accessors for class metaobjects.\label{class-mo-initargs}}
\end{table}

Instances of the class {\bf standard-class} support multiple inheritance and
reinitialization.  Instances of the class {\bf funcallable-standard-class}
support multiple inheritance and reinitialization.  For forward referenced
classes, all of the initialization arguments default to &nil;.

Since built-in classes cannot be created or reinitialized by the user, an
error is signaled if {\bf initialize-instance} or {\bf reinitialize-instance}
are called to initialize or reinitialize a derived instance of the class {\bf
built-in-class}.

\Methodslabel

It is not specified which methods provide the initialization and
reinitialization behavior described above.  Instead, the information needed to
allow portable programs to specialize this behavior is presented as a set of
restrictions on the methods a portable program can define.  The model is that
portable initialization methods have access to the class metaobject when
either all or none of the specified initialization has taken effect.

These restrictions govern the methods that a portable program can define
on the generic functions {\bf initialize-instance}, {\bf
reinitialize-instance}, and {\bf shared-initialize}.  These restrictions
apply only to methods on these generic functions for which the first
specializer is a subclass of the class {\bf class}.  Other portable
methods on these generic functions are not affected by these
restrictions.

<itemizedlist>
\item Portable programs must not define methods on {\bf
shared-initialize}.

\item For {\bf initialize-instance} and {\bf reinitialize-instance}:

<itemizedlist>

\item Portable programs must not define primary methods.

\item Portable programs may define around-methods, but these must be
extending, not overriding methods.

\item Portable before-methods must assume that when they are run, none of the
initialization behavior described above has been completed.

\item Portable after-methods must assume that when they are run, all of the
initialization behavior described above has been completed.

The results are undefined if any of these restrictions are violated.

</itemizedlist>

</itemizedlist>

\endcom

\newpage                % Think carefully before taking this out.  Without it,
                        % the tables in this and the next few sections probably
                        % won't come out where they are supposed to.

\begincom{Initialization of Generic Function Metaobjects}\ftype{}\label{gf-mo-init}

A generic function metaobject can be created by calling {\bf make-instance}.
The initialization arguments establish the definition of the generic
function.  A generic function metaobject can be redefined by calling {\bf
reinitialize-instance}.  Some classes of generic function metaobject do not
support redefinition; in these cases, {\bf reinitialize-instance} signals an
error.

Initialization of a generic function metaobject must be done by calling {\bf
make-instance} and allowing it to call {\bf initialize-instance}.
Reinitialization of a generic-function metaobject must be done by calling {\bf
reinitialize-instance}.  Portable programs must not call {\bf
initialize-instance} directly to initialize a generic function metaobject.
Portable programs must not call {\bf shared-initialize} directly to initialize
or reinitialize a generic function metaobject.  Portable programs must not
call {\bf change-class} to change the class of any generic function metaobject
or to turn a non-generic-function object into a generic function metaobject.

Since metaobject classes may not be redefined, no behavior is specified for
the result of calls to {\bf update-instance-for-redefined-class} on generic
function metaobjects.  Since the class of a generic function metaobject may
not be changed, no behavior is specified for the results of calls to {\bf
update-instance-for-different-class} on generic function metaobjects.

During initialization or reinitialization, each initialization argument is
checked for errors and then associated with the generic function metaobject.
The value can then be accessed by calling the appropriate accessor as shown
in Table~\ref{gf-mo-initargs}.

This section begins with a description of the error checking and processing of
each initialization argument.  This is followed by a table showing the generic
functions that can be used to access the stored initialization arguments. The
section ends with a set of restrictions on portable methods affecting generic
function metaobject initialization and reinitialization.

In these descriptions, the phrase ``this argument defaults to {\it value}''
means that when that initialization argument is not supplied, initialization
or reinitialization is performed as if {\it value\/} had been supplied.  For
some initialization arguments this could be done by the use of default
initialization arguments, but whether it is done this way is not specified.
Implementations are free to define default initialization arguments for
specified generic function metaobject classes.  Portable programs are free
to define default initialization arguments for portable subclasses of the
class {\bf generic-function}.

Unless there is a specific note to the contrary, then during reinitialization,
if an initialization argument is not supplied, the previously stored value is
left unchanged.

<itemizedlist>
\item The {\bf :argument-precedence-order} argument is a list of symbols.

An error is signaled if this argument appears but the {\bf :lambda-list}
argument does not appear.  An error is signaled if this value is not a proper
list or if this value is not a permutation of the symbols from the required
arguments part of the {\bf :lambda-list} initialization argument.

When the generic function is being initialized or reinitialized, and this
argument is not supplied, but the {\bf :lambda-list} argument is supplied,
this value defaults to the symbols from the required arguments part of the
{\bf :lambda-list} argument, in the order they appear in that argument.  If
neither argument is supplied, neither are initialized (see the description of
{\bf :lambda-list}.)

\item The {\bf :declarations} argument is a list of declarations.

An error is signaled if this value is not a proper list or if each of its
elements is not a legal declaration.

When the generic function is being initialized, and this argument is not
supplied, it defaults to the empty list.

\item The {\bf :documentation} argument is a string or &nil;.

An error is signaled if this value is not a string or &nil;.

If the generic function is being initialized, this argument defaults to {\bf
nil}.

\item The {\bf :lambda-list} argument is a lambda list.

An error is signaled if this value is not a proper generic function lambda
list.

When the generic function is being initialized, and this argument is not
supplied, the generic function's lambda list is not initialized.  The
lambda list will be initialized later, either when the first method is
added to the generic function, or a later reinitialization of the
generic function.

\item The {\bf :method-combination} argument is a method combination
metaobject.

\item The {\bf :method-class} argument is a class metaobject.

An error is signaled if this value is not a subclass of the class {\bf
method}.

When the generic function is being initialized, and this argument is not
supplied, it defaults to the class {\bf standard-method}.

\item  The {\bf :name} argument is an object.

If the generic function is being initialized, this argument defaults to {\bf
nil}.

</itemizedlist>

After the processing and defaulting of initialization arguments described
above, the value of each initialization argument is associated with the
generic function metaobject.  These values can then be accessed by calling the
corresponding generic function.  The correspondences are as follows:

\newpage                % Think carefully before taking this out.  Without it,
                        % the tables in this and the next few sections probably
                        % won't come out where they are supposed to.

\begin{table}[h]
\begin{tabular}{l@{\hspace{6pt}}l}
\toprule
\bf Initialization Argument&\bf Generic Function                   \\
\tablerule
\bf :argument-precedence-order &\bf generic-function-argument-precedence-order\\
\bf :declarations              &\bf generic-function-declarations \\
\bf :documentation             &\bf documentation                  \\
\bf :lambda-list               &\bf generic-function-lambda-list   \\
\bf :method-combination        &\bf generic-function-method-combination\\
\bf :method-class              &\bf generic-function-method-class  \\
\bf :name                      &\bf generic-function-name          \\
\bottomrule
\end{tabular}
\caption{Initialization arguments and accessors for generic function
metaobjects.\label{gf-mo-initargs}}
\end{table}

\Methodslabel

It is not specified which methods provide the initialization and
reinitialization behavior described above.  Instead, the information needed to
allow portable programs to specialize this behavior is presented as a set of
restrictions on the methods a portable program can define.  The model is that
portable initialization methods have access to the generic function metaobject
when either all or none of the specified initialization has taken effect.

These restrictions govern the methods that a portable program can define
on the generic functions {\bf initialize-instance}, {\bf
reinitialize-instance}, and {\bf shared-initialize}.  These restrictions
apply only to methods on these generic functions for which the first
specializer is a subclass of the class {\bf generic-function}.  Other
portable methods on these generic functions are not affected by these
restrictions.

<itemizedlist>
\item Portable programs must not define methods on {\bf shared-initialize}.

\item For {\bf initialize-instance} and {\bf reinitialize-instance}:

<itemizedlist>

\item Portable programs must not define primary methods.

\item Portable programs may define around-methods, but these must be
extending, not overriding methods.

\item Portable before-methods must assume that when they are run, none
of the initialization behavior described above has been completed.

\item Portable after-methods must assume that when they are run,
all of the initialization behavior described above has been completed.

</itemizedlist>

</itemizedlist>

The results are undefined if any of these restrictions are violated.

\endcom

\newpage                % Think carefully before taking this out.  Without it,
                        % the tables in this and the next few sections probably
                        % won't come out where they are supposed to.

\begincom{Initialization of Method Metaobjects}\ftype{}

A method metaobject can be created by calling {\bf make-instance}.  The
initialization arguments establish the definition of the method.  A method
metaobject cannot be redefined; calling {\bf reinitialize-instance} signals an
error.

Initialization of a method metaobject must be done by calling {\bf
make-instance} and allowing it to call {\bf initialize-instance}.  Portable
programs must not call {\bf initialize-instance} directly to initialize a
method metaoject. Portable programs must not call {\bf shared-initialize}
directly to initialize a method metaobject.  Portable programs must not
call {\bf change-class} to change the class of any method metaobject
or to turn a non-method object into a method metaobject.

Since metaobject classes may not be redefined, no behavior is specified for
the result of calls to {\bf update-instance-for-redefined-class} on method
metaobjects.  Since the class of a method metaobject cannot be changed, no
behavior is specified for the result of calls to {\bf
update-instance-for-different-class} on method metaobjects.

During initialization, each initialization argument is checked for errors and
then associated with the method metaobject.  The value can then be accessed by
calling the appropriate accessor as shown in Table~\ref{method-mo-initargs}.

This section begins with a description of the error checking and processing of
each initialization argument.  This is followed by a table showing the generic
functions that can be used to access the stored initialization arguments.  The
section ends with a set of restrictions on portable methods affecting method
metaobject initialization.

In these descriptions, the phrase ``this argument defaults to {\it value}''
means that when that initialization argument is not supplied, initialization
is performed as if {\it value\/} had been supplied.  For
some initialization arguments this could be done by the use of default
initialization arguments, but whether it is done this way is not specified.
Implementations are free to define default initialization arguments for
specified method metaobject classes.  Portable programs are free to define
default initialization arguments for portable subclasses of the class {\bf
method}.


<itemizedlist>

\item The {\bf :qualifiers} argument is a list of method qualifiers.
An error is signaled if this value is not a proper list, or if any element of
the list is not a non-null atom. This argument defaults to the empty list.

\item The {\bf :lambda-list} argument is the unspecialized lambda list of the
method.  An error is signaled if this value is not a proper lambda list. If
this value is not supplied, an error is signaled.

\item The {\bf :specializers} argument is a list of the specializer
metaobjects for the method.  An error is signaled if this value is not a
proper list, or if the length of the list differs from the number of required
arguments in the {\bf :lambda-list} argument, or if any element of the list is
not a specializer metaobject.  If this value is not supplied, an error is
signaled.

\item The {\bf :function} argument is a method function.  It must be
compatible with the methods on {\bf compute-effective-method} defined for this
class of method and generic function with which it will be used.  That is, it
must accept the same number of arguments as all uses of {\bf call-method} that
will call it supply.  (See {\bf compute-effective-method} for more
information.)  An error is signaled if this argument is not supplied.

\item When the method being initialized is an instance of a subclass of {\bf
standard-accessor-method}, the {\bf :slot-definition} initialization argument
must be provided.  Its value is the direct slot definition metaobject which
defines this accessor method.  An error is signaled if the value is not an
instance of a subclass of {\bf direct-slot-definition}.

\item  The {\bf :documentation} argument is a string or &nil;.
An error is signaled if this value is not a string or &nil;.  This
argument defaults to &nil;.

</itemizedlist>

After the processing and defaulting of initialization arguments described
above, the value of each initialization argument is associated with the method
metaobject.  These values can then be accessed by calling the corresponding
generic function.  The correspondences are as follows:

\begin{table}[h]
\begin{tabular}{ll}
\toprule
\bf Initialization Argument  &\quad\bf Generic Function                \\
\tablerule
\bf :qualifiers              &\quad\bf method-qualifiers               \\
\bf :lambda-list             &\quad\bf method-lambda-list              \\
\bf :specializers            &\quad\bf method-specializers             \\
\bf :function                &\quad\bf method-function                 \\
\bf :slot-definition         &\quad\bf accessor-method-slot-definition \\
\bf :documentation           &\quad\bf documentation                   \\
\bottomrule
\end{tabular}
\caption{Initialization arguments and accessors for method
metaobjects.\label{method-mo-initargs}}
\end{table}

\endcom

\Methodslabel

It is not specified which methods provide the initialization behavior
described above.  Instead, the information needed to allow portable programs
to specialize this behavior is presented in as a set of restrictions on the
methods a portable program can define.  The model is that portable
initialization methods have access to the method metaobject when either all or
none of the specified initialization has taken effect.

These restrictions govern the methods that a portable program can define on
the generic functions {\bf initialize-instance}, {\bf reinitialize-instance},
and {\bf shared-initialize}.  These restrictions apply only to methods on
these generic functions for which the first specializer is a subclass of the
class {\bf method}.  Other portable methods on these generic functions are not
affected by these restrictions.

<itemizedlist>

\item {Portable programs must not define methods on {\bf shared-initialize} or
{\bf reinitialize-instance}.\tolerant\tolerant\tolerant\par}

\item For {\bf initialize-instance}:

<itemizedlist>

\item Portable programs must not define primary methods.

\item Portable programs may define around-methods, but these must be
extending, not overriding methods.

\item Portable before-methods must assume that when they are run, none
of the initialization behavior described above has been completed.

\item Portable after-methods must assume that when they are run,
all of the initialization behavior described above has been completed.

</itemizedlist>

</itemizedlist>

The results are undefined if any of these restrictions are violated.

\endcom

\newpage                % Think carefully before taking this out.  Without it,
                        % the tables in this and the next few sections probably
                        % won't come out where they are supposed to.

\begincom{Initialization of Slot Definition Metaobjects}\ftype{}

A slot definition metaobject can be created by calling {\bf make-instance}.
The initialization arguments establish the definition of the slot definition.
A slot definition metaobject cannot be redefined; calling {\bf
reinitialize-instance} signals an error.

Initialization of a slot definition metaobject must be done by calling {\bf
make-instance} and allowing it to call {\bf initialize-instance}.  Portable
programs must not call {\bf initialize-instance} directly to initialize a slot
definition metaobject.  Portable programs must not call {\bf
shared-initialize} directly to initialize a slot definition metaobject.
Portable programs must not call {\bf change-class} to change the class of any
slot definition metaobject or to turn a non-slot-definition object into a slot
definition metaobject.

Since metaobject classes may not be redefined, no behavior is specified for
the result of calls to {\bf update-instance-for-redefined-class} on slot
definition metaobjects.  Since the class of a slot definition metaobject
cannot be changed, no behavior is specified for the result of calls to {\bf
update-instance-for-different-class} on slot definition metaobjects.

During initialization, each initialization argument is checked for errors and
then associated with the slot definition metaobject.  The value can then be
accessed by calling the appropriate accessor as shown in Table~\ref{slotd-mo-initargs}.

This section begins with a description of the error checking and processing of
each initialization argument.  This is followed by a table showing the generic
functions that can be used to access the stored initialization arguments.

In these descriptions, the phrase ``this argument defaults to {\it value}''
means that when that initialization argument is not supplied, initialization
is performed as if {\it value\/} had been supplied.  For some initialization
arguments this could be done by the use of default initialization arguments,
but whether it is done this way is not specified.  Implementations are free to
define default initialization arguments for specified slot definition
metaobject classes.  Portable programs are free to define default
initialization arguments for portable subclasses of the class {\bf
slot-definition}.

<itemizedlist>

\item The {\bf :name} argument is a slot name.  An error is signaled if this
argument is not a symbol which can be used as a variable name.  An error is
signaled if this argument is not supplied.

\item The {\bf :initform} argument is a form. The {\bf :initform} argument
defaults to &nil;.  An error is signaled if the {\bf :initform} argument is
supplied, but the {\bf :initfunction} argument is not supplied.

\item The {\bf :initfunction} argument is a function of zero arguments which,
when called, evaluates the {\bf :initform} in the appropriate lexical
environment.  The {\bf :initfunction} argument defaults to false.  An error is
signaled if the {\bf :initfunction} argument is supplied, but the {\bf
:initform} argument is not supplied.

\item The {\bf :type} argument is a type specifier name.  An error is
signaled otherwise.  The {\bf :type} argument defaults to the symbol {\bf t}.

\item The {\bf :allocation} argument is a symbol.  An error is signaled
otherwise.  The {\bf :allocation} argument defaults to the symbol {\bf
:instance}.

\item The {\bf :initargs} argument is a list of symbols.  An error is
signaled if this argument is not a proper list, or if any element of this
list is not a symbol.  The {\bf :initargs} argument defaults to the empty
list.

\item The {\bf :readers} argument is a list of function names.  An error is
signaled if it is not a proper list, or if any element is not a valid
function name. It defaults to the empty list.  An error is signaled if this
argument is supplied and the metaobject is not a direct slot definition.

\item The {\bf :writers} argument is a list of function names.  An error is
signaled if it is not a proper list, or if any element is not a valid
function name. It defaults to the empty list.  An error is signaled if this
argument is supplied and the metaobject is not a direct slot definition.

\item The {\bf :documentation} argument is a string or &nil;.  An
error is signaled otherwise.  The {\bf :documentation} argument defaults to
&nil;.

</itemizedlist>

After the processing and defaulting of initialization arguments described
above, the value of each initialization argument is associated with the slot
definition metaobject.  These values can then be accessed by calling the
corresponding generic function.  The correspondences are as follows:

\newpage                % Think carefully before taking this out.  Without it,
                        % the tables in this and the next few sections probably
                        % won't come out where they are supposed to.

\begin{table}[h]
\begin{tabular}{ll}
\toprule
\bf Initialization Argument &\bf Generic Function              \\
\tablerule
\bf :name                   &\bf slot-definition-name          \\
\bf :initform               &\bf slot-definition-initform      \\
\bf :initfunction           &\bf slot-definition-initfunction  \\
\bf :type                   &\bf slot-definition-type          \\
\bf :allocation             &\bf slot-definition-allocation    \\
\bf :initargs               &\bf slot-definition-initargs      \\
\bf :readers                &\bf slot-definition-readers       \\
\bf :writers                &\bf slot-definition-writers       \\
\bf :documentation          &\bf documentation                 \\
\bottomrule
\end{tabular}
\caption{Initialization arguments and accessors for slot definition
metaobjects.\label{slotd-mo-initargs}}
\end{table}

\Methodslabel

It is not specified which methods provide the initialization and
reinitialization behavior described above.  Instead, the information needed to
allow portable programs to specialize this behavior is presented as a set of
restrictions on the methods a portable program can define.  The model is that
portable initialization methods have access to the slot definition metaobject
when either all or none of the specified initialization has taken effect.

These restrictions govern the methods that a portable program can define on
the generic functions {\bf initialize-instance}, {\bf reinitialize-instance},
and {\bf shared-initialize}.  These restrictions apply only to methods on
these generic functions for which the first specializer is a subclass of the
class {\bf slot-definition}.  Other portable methods on these generic
functions are not affected by these restrictions.

<itemizedlist>
\item {Portable programs must not define methods on {\bf shared-initialize} or
{\bf reinitialize-instance}.\tolerant\tolerant\tolerant\par}

\item For {\bf initialize-instance}:

<itemizedlist>

\item Portable programs must not define primary methods.

\item Portable programs may define around-methods, but these must be
extending, not overriding methods.

\item Portable before-methods must assume that when they are run, none
of the initialization behavior described above has been completed.

\item Portable after-methods must assume that when they are run,
all of the initialization behavior described above has been completed.

</itemizedlist>

</itemizedlist>

The results are undefined if any of these restrictions are violated.

\endcom

\beginfncom{intern-eql-specializer}

\Syntaxlabel

\Defun {intern-eql-specializer} {object}

\Argumentslabel

The {\it object\/} argument is any Lisp object.

\Valueslabel

The result is the {\bf eql} specializer metaobject for {\it object}.

\Purposelabel

This function returns the unique {\bf eql} specializer metaobject for {\it
object\/}, creating one if necessary.  Two calls to {\bf intern-eql-specializer}
with {\bf eql} arguments will return the same (i.e., {\bf eq}) value.

\Remarkslabel

The result of calling {\bf eql-specializer-object} on the result of a call to
{\bf intern-eql-special\-izer} is only guaranteed to be {\bf eql} to the
original {\it object\/} argument, not necessarily {\bf eq}.

\endcom

\begingfcom{make-instance}

\Syntaxlabel

\Defgen {make-instance} {class {\rest} {\it initargs\/}}

\Argumentslabel

The {\it class\/} argument is a class metaobject or a class name.

The {\it initargs\/} argument is a list of alternating initialization argument
names and values.

\Valueslabel

The result is a newly allocated and initialized instance of {\it class}.

\Purposelabel

The generic function {\bf make-instance} creates and returns a new instance of
the given class.  Its behavior and use is described in the &clos; specification.

\Methodslabel

\Defmeth {make-instance} {({\it class\/} symbol) {\rest} {\it initargs}}

This method simply invokes {\bf make-instance} recursively on the arguments
{\tt (find-class {\it class\/})} and {\it initargs}.

\Defmeth {make-instance} {({\it class\/} standard-class) {\rest} {\it initargs}}
\Defmeth {make-instance} {({\it class\/} funcallable-standard-class) {\rest} {\it initargs}}

These methods implement the behavior of {\bf make-instance} described in the
&clos; specification section named ``Object Creation and Initialization.''

\endcom

\begingfcom{make-method-lambda}

\Syntaxlabel

\Defgen {make-method-lambda} {generic-function method lambda-expression environment}

\Argumentslabel

The {\it generic-function\/} argument is a generic function metaobject.

The {\it method\/} argument is a (possibly uninitialized) method metaobject. %%%% change to uninitialized???

The {\it lambda-expression\/} argument is a lambda expression.

The {\it environment\/} argument is the same as the {\bf \&environment} argument
to macro expansion functions.

\Valueslabel

This generic function returns two values.  The first is a lambda expression,
the second is a list of initialization arguments and values.

\Purposelabel

This generic function is called to produce a lambda expression which can
itself be used to produce a method function for a method and generic function
with the specified classes.  The generic function and method the method
function will be used with are not required to be the given ones.  Moreover,
the method metaobject may be uninitialized.

Either the function {\bf compile}, the special form {\bf function} or the
function {\bf coerce} must be used to convert the lambda expression a method
function.  The method function itself can be applied to arguments with {\bf
apply} or &funcall;.

When a method is actually called by an effective method, its first argument
will be a list of the arguments to the generic function.  Its remaining
arguments will be all but the first argument passed to {\bf call-method}.  By
default, all method functions must accept two arguments: the list of arguments
to the generic function and the list of next methods.

{For a given generic function and method class, the applicable methods on {\bf
make-method-lambda} and {\bf compute-effective-method} must be consistent in
the following way:  each use of {\bf call-method} returned by the method on
{\bf compute-effective-method} must have the same number of arguments, and the
method lambda returned by the method on {\bf make-method-lambda} must accept a
corresponding number of arguments.\tolerant\tolerant\tolerant\par}

Note that the system-supplied implementation of {\bf call-next-method} is not
required to handle extra arguments to the method function.  Users who define
additional arguments to the method function must either redefine or forego
{\bf call-next-method}.  (See the example below.)

When the method metaobject is created with {\bf make-instance}, the method
function must be the value of the {\bf :function} initialization argument.
The additional initialization arguments, returned as the second value of this
generic function, must also be passed in this call to {\bf make-instance}.

\Methodslabel

\Defmeth {make-method-lambda} {     {({\it generic-function\/} standard-generic-function)\\
                                     ({\it method\/} standard-method)\\
                                     {\it lambda-expression}\\
                                     {\it environment}}}

This method returns a method lambda which accepts two arguments, the list of
arguments to the generic function, and the list of next methods.  What
initialization arguments may be returned in the second value are unspecified.

This method can be overridden.

\begin{Example}

This example shows how to define a kind of method which, from within the body
of the method, has access to the actual method metaobject for the method.
This simplified code overrides whatever method combination is specified for
the generic function, implementing a simple method combination supporting only
primary methods, {\bf call-next-method} and {\bf next-method-p}.  (In
addition, its a simplified version of {\bf call-next-method} which does no
error checking.)

Notice that the extra lexical function bindings get wrapped around the body
before {\bf call-next-method} is called.  In this way, the user's definition
of {\bf call-next-method} and {\bf next-method-p} are sure to override the
system's definitions.

\begin{lispcode}
(defclass my-generic-function (standard-generic-function)
     ()
  (:default-initargs :method-class (find-class 'my-method)))

(defclass my-method (standard-method) ())

(defmethod make-method-lambda ((gf my-generic-function)
                               (method my-method)
                               lambda-expression
                               environment)
  (declare (ignore environment))
  `(lambda (args next-methods this-method)
     (,(call-next-method gf method
         `(lambda ,(cadr lambda-expression)
            (flet ((this-method () this-method)
                   (call-next-method (&rest cnm-args)
                     (funcall (method-function (car next-methods))
                              (or cnm-args args)
                              (cdr next-methods)
                              (car next-methods)))
                   (next-method-p ()
                     (not (null next-methods))))
              ,@(cddr lambda-expression)))
          environment)
       args next-methods)))

(defmethod compute-effective-method ((gf my-generic-function)
                                     method-combination
                                     methods)
  `(call-method ,(car methods) ,(cdr methods) ,(car methods)))
\end{lispcode}

\end{Example}

\endcom

\begingfcom{map-dependents}

\Syntaxlabel

\Defgen {map-dependents} {metaobject function}

\Argumentslabel

The {\it metaobject\/} argument is a class or generic function metaobject.

The {\it function\/} argument is a function which accepts one argument.

\Valueslabel

The value returned is unspecified.

\Purposelabel

This generic function applies {\it function\/} to each of the dependents of {\it
metaobject\/}.  The order in which the dependents are processed is not
specified, but {\it function\/} is applied to each dependent once and only once.
If, during the mapping, {\bf add-dependent} or {\bf remove-dependent} is
called to alter the dependents of {\it metaobject\/}, it is not specified
whether the newly added or removed dependent will have {\it function\/} applied
to it.

\Methodslabel

\Defmeth {map-dependents} {({\it metaobject\/} standard-class) {\it function\/}}

This method has no specified behavior beyond that which is specified for the
generic function.

This method cannot be overridden unless the following methods are overridden
as well:

\begin{methods}
\method{add-dependent}{standard-class t}\\
\method{remove-dependent}{standard-class t}
\end{methods}

\Defmeth {map-dependents} {({\it metaobject\/} funcallable-standard-class) {\it function\/}}

This method has no specified behavior beyond that which is specified for the
generic function.

This method cannot be overridden unless the following methods are overridden
as well:

\begin{methods}
\method{add-dependent}{funcallable-standard-class t}\\
\method{remove-dependent}{funcallable-standard-class t}
\end{methods}

\Defmeth {map-dependents} {({\it metaobject\/} standard-generic-function) {\it function\/}}

This method has no specified behavior beyond that which is specified for the
generic function.

This method cannot be overridden unless the following methods are overridden
as well:

\begin{methods}
\method{add-dependent}{standard-generic-function t}\\
\method{remove-dependent}{standard-generic-function t}
\end{methods}

\Remarkslabel

See the ``Dependent Maintenance Protocol'' section for remarks about the use
of this facility.

\endcom

\begincom{method-\dots}\ftype{Generic Function}

{The following generic functions are described together under ``Readers for
Method Metaobjects'' (page~\pageref{method-mo-readers}): {\bf method-function},
{\bf method-generic-function}, {\bf method-lambda-list}, {\bf
method-specializers}, {\bf method-qualifiers} and {\bf
accessor-method-slot-definition}.\par}

\endcom

% *** READERS ***

\newpage                % Think carefully before taking this out.  Without it,
                        % the tables in this and the next few sections probably
                        % won't come out where they are supposed to.

\begincom{Readers for Class Metaobjects}\ftype{}\label{class-mo-readers}

In this and the immediately following sections, the ``reader'' generic
functions which simply return information associated with a particular kind of
metaobject are presented together.  General information is presented first,
followed by a description of the purpose of each, and ending with the
specified methods for these generic functions.

The reader generic functions which simply return information associated with
class metaobjects are presented together in this section.

Each of the reader generic functions for class metaobjects has the same
syntax, accepting one required argument called {\it class\/}, which must be an
class metaobject; otherwise, an error is signaled.  An error is also
signaled if the class metaobject has not been initialized.

These generic functions can be called by the user or the implementation.

For any of these generic functions which returns a list, such lists will not
be mutated by the implementation.  The results are undefined if a portable
program allows such a list to be mutated.

\Defgeni {class-default-initargs} {class}

Returns a list of the default initialization arguments for {\it class}.
Each element of this list is a canonicalized default initialization
argument.  The empty list is returned if {\it class\/} has no default
initialization arguments.

During finalization {\bf finalize-inheritance} calls {\bf
compute-default-initargs} to compute the default initialization arguments for
the class.  That value is associated with the class metaobject and is returned
by {\bf class-default-initargs}.

This generic function signals an error if {\it class\/} has not been finalized.

\Defgeni {class-direct-default-initargs} {class}

Returns a list of the direct default initialization arguments for {\it class}.
Each element of this list is a canonicalized default initialization argument.
The empty list is returned if {\it class\/} has no direct default initialization
arguments.  This is the defaulted value of the {\bf :direct-default-initargs}
initialization argument that was associated with the class during
initialization or reinitialization.

\Defgeni {class-direct-slots} {class}

Returns a set of the direct slots of {\it class}.  The elements of this set
are direct slot definition metaobjects.  If the class has no direct slots, the
empty set is returned.  This is the defaulted value of the {\bf :direct-slots}
initialization argument that was associated with the class during
initialization and reinitialization.

\Defgeni {class-direct-subclasses} {class}

Returns a set of the direct subclasses of {\it class}. The elements of this
set are class metaobjects that all mention this class among their direct
superclasses.  The empty set is returned if {\it class\/} has no direct
subclasses.  This value is maintained by the generic functions {\bf
add-direct-subclass} and {\bf remove-direct-subclass}.

\Defgeni {class-direct-superclasses} {class}

Returns a list of the direct superclasses of {\it class}.  The elements of
this list are class metaobjects.  The empty list is returned if {\it class\/}
has no direct superclasses.  This is the defaulted value of the {\bf
:direct-superclasses} initialization argument that was associated with the
class during initialization or reinitialization.

\Defgeni {class-finalized-p} {class}

Returns true if {\it class\/} has been finalized.  Returns false otherwise.
Also returns false if the class has not been initialized.

\Defgeni {class-name} {class}

Returns the name of {\it class}.  This value can be any Lisp object, but is
usually a symbol, or &nil; if the class has no name.  This is the
defaulted value of the {\bf :name} initialization argument that was associated
with the class during initialization or reinitialization.  (Also see {\bf
(setf class-name)}.)

\Defgeni {class-precedence-list} {class}

Returns the class precedence list of {\it class}.  The elements of this list
are class metaobjects.

During class finalization {\bf finalize-inheritance} calls {\bf
compute-class-precedence-list} to compute the class precedence list of the
class.  That value is associated with the class metaobject and is returned by
{\bf class-precedence-list}.

This generic function signals an error if {\it class\/} has not been finalized.

\Defgeni {class-prototype} {class}

Returns a prototype instance of {\it class}.  Whether the instance is
initialized is not specified.  The results are undefined if a portable program
modifies the binding of any slot of prototype instance.

This generic function signals an error if {\it class\/} has not been finalized.

\Defgeni {class-slots} {class}

Returns a possibly empty set of the slots accessible in instances of {\it
class\/}.  The elements of this set are effective slot definition metaobjects.

During class finalization {\bf finalize-inheritance} calls {\bf compute-slots}
to compute the slots of the class.  That value is associated with the class
metaobject and is returned by {\bf class-slots}.

This generic function signals an error if {\it class\/} has not been finalized.

\Methodslabel

The specified methods for the class metaobject reader generic functions are
presented below.

Each entry in the table indicates a method on one of the reader generic
functions, specialized to a specified class.  The number in each entry is a
reference to the full description of the method.  The full descriptions appear
after the table.

\newpage                % Think carefully before taking this out.  Without it,
                        % the tables in this and the next few sections probably
                        % won't come out where they are supposed to.

\begin{figure}[h]
\begin{tabular}{lccc}
\toprule
& \bf  standard-class        & \bf forward-     & \bf built-in-  \\
&           and              & \bf referenced-  & \bf class      \\
& \bf   funcallable-         & \bf class        &                \\
& \bf  standard-class                                            \\
\tablerule
\bf class-default-initargs        &  2 &  3 &  4 \\
\bf class-direct-default-initargs &  1 &  4 &  4 \\
\bf class-direct-slots            &  1 &  4 &  4 \\
\bf class-direct-subclasses       &  9 &  9 &  7 \\
\bf class-direct-superclasses     &  1 &  4 &  7 \\
\bf class-finalized-p             &  2 &  6 &  5 \\
\bf class-name                    &  1 &  1 &  8 \\
\bf class-precedence-list         &  2 &  3 &  7 \\
\bf class-prototype               & 10 & 10 & 10 \\
\bf class-slots                   &  2 &  3 &  4 \\
\bottomrule
\end{tabular}
\end{figure}

%\newpage                % Think carefully before taking this out.  Without it,
                        % the tables in this and the next few sections probably
                        % won't come out where they are supposed to.

\begin{enumerate}

\item This method returns the value which was associated with the class
metaobject during initialization or reinitialization.

\item {This method returns the value associated with the class metaobject by
\method{finalize-inheritance}{standard-class} or
\method{finalize-inheritance}{funcallable-standard-class}.\tolerant\tolerant\tolerant\par}

\item This method signals an error.

\item This method returns the empty list.

\item This method returns true.

\item This method returns false.

\item This method returns a value derived from the information in
Table~\ref{inherit-struct-figure}, except that implementation-specific
modifications are permitted as described in section ``Implementation and User
Specialization.''

\item This method returns the name of the built-in class.

\item This methods returns a value which is maintained by
\method{add-direct-subclass}{class class} and
\method{remove-direct-subclass}{class class}.  This method can be overridden
only if those methods are overridden as well.

\item No behavior is specified for this method beyond that specified for the
generic function.

\end{enumerate}

\endcom

\begincom{Readers for Generic Function Metaobjects}\ftype{}\label{gf-mo-readers}

The reader generic functions which simply return information associated with
generic function metaobjects are presented together in this section.

Each of the reader generic functions for generic function metaobjects has the
same syntax, accepting one required argument called {\it generic-function},
which must be a generic function metaobject; otherwise, an error is signaled.
An error is also signaled if the generic function metaobject has not been
initialized.

These generic functions can be called by the user or the implementation.

The list returned by this generic function will not be mutated by the
implementation.  The results are undefined if a portable program mutates the
list returned by this generic function.

\Defgeni {generic-function-argument-precedence-order} {generic-function}

Returns the argument precedence order of the generic function.   This value is
a list of symbols, a permutation of the required parameters in the lambda list
of the generic function.  This is the defaulted value of the {\bf
:argument-precedence-order} initialization argument that was associated with
the generic function metaobject during initialization or reinitialization.

\Defgeni {generic-function-declarations} {generic-function}

Returns a possibly empty list of the declarations of the generic function.
The elements of this list are declarations.  This list is the defaulted value
of the {\bf :declarations} initialization argument that was associated with
the generic function metaobject during initialization or reinitialization.

\Defgeni {generic-function-lambda-list} {generic-function}

Returns the lambda list of the generic function.  This is the defaulted value
of the {\bf :lambda-list} initialization argument that was associated with the
generic function metaobject during initialization or reinitialization.  An
error is signaled if the lambda list has yet to be supplied.

\Defgeni {generic-function-method-class} {generic-function}

Returns the default method class of the generic function.  This class must be
a subclass of the class {\bf method}.  This is the defaulted value of the {\bf
:method-class} initialization argument that was associated with the generic
function metaobject during initialization or reinitialization.

\Defgeni {generic-function-method-combination} {generic-function}

Returns the method combination of the generic function.  This is a method
combination metaobject.  This is the defaulted value of the {\bf
:method-combination} initialization argument that was associated with the
generic function metaobject during initialization or reinitialization.

\Defgeni {generic-function-methods} {generic-function}

Returns the set of methods currently connected to the generic function.  This
is a set of method metaobjects.  This value is maintained by the generic
functions &add-method; and {\bf remove-method}.

\Defgeni {generic-function-name} {generic-function}

Returns the name of the generic function, or &nil; if the generic function
has no name.  This is the defaulted value of the {\bf :name} initialization
argument that was associated with the generic function metaobject during
initialization or reinitialization.  (Also see {\bf (setf
generic-function-name)}.)

\Methodslabel

The specified methods for the generic function metaobject reader generic
functions are presented below.

\Defmeth {generic-function-argument-precedence-order}
         {({\it generic-function\/} standard-generic-function)}
\Defmeth {generic-function-declarations}
         {({\it generic-function\/} standard-generic-function)}
\Defmeth {generic-function-lambda-list}
         {({\it generic-function\/} standard-generic-function)}
\Defmeth {generic-function-method-class}
         {({\it generic-function\/} standard-generic-function)}
\Defmeth {generic-function-method-combination}
         {({\it generic-function\/} standard-generic-function)}
\Defmeth {generic-function-name}
         {({\it generic-function\/} standard-generic-function)}

No behavior is specified for these methods beyond that which is specified for
their respective generic functions.

\vskip1.9pc                % Don't take this out without arranging somehow for
                           % the layout to still suggest the grouping of sets
                           % of methods.


\Defmeth {generic-function-methods}
         {({\it generic-function\/} standard-generic-function)}

No behavior is specified for this method beyond that which is specified for
their respective generic functions.

{The value returned by this method is maintained by
\method{add-method}{standard-generic-function standard-method} and
\method{remove-method}{standard-generic-function standard-method}.\tolerant\tolerant\tolerant\par}

\vskip1.9pc                % Don't take this out without arranging somehow for
                           % the layout to still suggest the grouping of sets
                           % of methods.

\endcom


\begincom{Readers for Method Metaobjects}\ftype{}\label{method-mo-readers}

The reader generic functions which simply return information associated with
method metaobjects are presented together here in the format described under
``Readers for Class Metaobjects.''

Each of these reader generic functions have the same syntax, accepting one
required argument called {\it method}, which must be a method metaobject;
otherwise, an error is signaled.  An error is also signaled if the method
metaobject has not been initialized.

These generic functions can be called by the user or the implementation.

For any of these generic functions which returns a list, such lists will not
be mutated by the implementation.  The results are undefined if a portable
program allows such a list to be mutated.

\Defgeni {method-function} {method}

Returns the method function of {\it method}.  This is the defaulted value of
the {\bf :function} initialization argument that was associated with the
method during initialization.

\Defgeni {method-generic-function} {method}

Returns the generic function that {\it method\/} is currently connected to, or
&nil; if it is not currently connected to any generic function.  This
value is either a generic function metaobject or &nil;.  When a method is
first created it is not connected to any generic function.  This connection is
maintained by the generic functions &add-method; and {\bf remove-method}.

\Defgeni {method-lambda-list} {method}

Returns the (unspecialized) lambda list of {\it method\/}.  This value is a
&cl; lambda list.   This is the defaulted value of the {\bf
:lambda-list} initialization argument that was associated with the method
during initialization.

\Defgeni {method-specializers} {method}

Returns a list of the specializers of {\it method}.  This value is a list of
specializer metaobjects.  This is the defaulted value of the {\bf
:specializers} initialization argument that was associated with the method
during initialization.

\Defgeni {method-qualifiers} {method}

Returns a (possibly empty) list of the qualifiers of {\it method}.  This value
is a list of non-&nil; atoms.  This is the defaulted value of the {\bf
:qualifiers} initialization argument that was associated with the method
during initialization.

\Defgeni {accessor-method-slot-definition} {method}

This accessor can only be called on accessor methods.  It returns the direct
slot definition metaobject that defined this method.  This is the value of the
{\bf :slot-definition} initialization argument associated with the method
during initialization.

\Methodslabel

The specified methods for the method metaobject readers are presented below.

\Defmeth {method-function}     {({\it method\/} standard-method)}
\Defmeth {method-lambda-list}  {({\it method\/} standard-method)}
\Defmeth {method-specializers} {({\it method\/} standard-method)}
\Defmeth {method-qualifiers}   {({\it method\/} standard-method)}

No behavior is specified for these methods beyond that which is specified for
their respective generic functions.

\vskip1.9pc                % Don't take this out without arranging somehow for
                           % the layout to still suggest the grouping of sets
                           % of methods.


\Defmeth {method-generic-function} {({\it method\/} standard-method)}

No behavior is specified for this method beyond that which is specified for
its generic function.

{The value returned by this method is maintained by
\method{add-method}{standard-generic-function standard-method} and
\method{remove-method}{standard-generic-function standard-method}.\tolerant\tolerant\tolerant\par}

\vskip1.9pc                % Don't take this out without arranging somehow for
                           % the layout to still suggest the grouping of sets
                           % of methods.


\Defmeth {accessor-method-slot-definition} {({\it method\/} standard-accessor-method)}

No behavior is specified for this method beyond that which is specified for
its generic function.

\endcom

\begincom{Readers for Slot Definition Metaobjects}\ftype{}\label{slotd-mo-readers}

The reader generic functions which simply return information associated with
slot definition metaobjects are presented together here in the format
described under ``Readers for Class Metaobjects.''

Each of the reader generic functions for slot definition metaobjects has the
same syntax, accepting one required argument called {\it slot}, which must be
a slot definition metaobject; otherwise, an error is signaled. An error is
also signaled if the slot definition metaobject has not been initialized.

These generic functions can be called by the user or the implementation.

For any of these generic functions which returns a list, such lists will not
be mutated by the implementation.  The results are undefined if a portable
program allows such a list to be mutated.

\GenericFunctionslabel

\Defgeni {slot-definition-allocation} {slot}

Returns the allocation of {\it slot}.  This is a symbol.  This is the
defaulted value of the {\bf :allocation} initialization argument that was
associated with the slot definition metaobject during initialization.

\Defgeni {slot-definition-initargs} {slot}

Returns the set of initialization argument keywords for {\it slot}.  This is
the defaulted value of the {\bf :initargs} initialization argument that was
associated with the slot definition metaobject during initialization.

\Defgeni {slot-definition-initform} {slot}

Returns the initialization form of {\it slot}.  This can be any form.  This is
the defaulted value of the {\bf :initform} initialization argument that was
associated with the slot definition metaobject during initialization.  When
{\it slot\/} has no initialization form, the value returned is unspecified
(however, {\bf slot-definition-initfunction} is guaranteed to return {\bf
nil}).

\Defgeni {slot-definition-initfunction} {slot}

Returns the initialization function of {\it slot}.  This value is either a
function of no arguments, or &nil;, indicating that the slot has no
initialization function.  This is the defaulted value of the {\bf
:initfunction} initialization argument that was associated with the slot
definition metaobject during initialization.

\Defgeni {slot-definition-name} {slot}

Returns the name of {\it slot}.  This value is a symbol that can be used as a
variable name.  This is the value of the {\bf :name} initialization argument
that was associated with the slot definition metaobject during initialization.

\Defgeni {slot-definition-type} {slot}

Returns the allocation of {\it slot}.  This is a type specifier name.  This is
the defaulted value of the {\bf :name} initialization argument that was
associated with the slot definition metaobject during initialization.

\Methodslabel

The specified methods for the slot definition metaobject readers are presented
below.

\Defmeth {slot-definition-allocation}   {({\it slot-definition\/} standard-slot-definition)}
\Defmeth {slot-definition-initargs}     {({\it slot-definition\/} standard-slot-definition)}
\Defmeth {slot-definition-initform}     {({\it slot-definition\/} standard-slot-definition)}
\Defmeth {slot-definition-initfunction} {({\it slot-definition\/} standard-slot-definition)}
\Defmeth {slot-definition-name}         {({\it slot-definition\/} standard-slot-definition)}
\Defmeth {slot-definition-type}         {({\it slot-definition\/} standard-slot-definition)}

No behavior is specified for these methods beyond that which is specified for
their respective generic functions.

\vskip1.9pc                % Don't take this out without arranging somehow for
                           % the layout to still suggest the grouping of sets
                           % of methods.

\Directlabel

The following additional reader generic functions are defined for direct slot
definition metaobjects.

\Defgeni {slot-definition-readers} {direct-slot}

Returns a (possibly empty) set of readers of the {\it direct slot}.  This
value is a list of function names.  This is the defaulted value of the {\bf
:readers} initialization argument that was associated with the direct slot
definition metaobject during initialization.

\Defgeni {slot-definition-writers} {direct-slot}

Returns a (possibly empty) set of writers of the {\it direct slot}.  This
value is a list of function names.  This is the defaulted value of the {\bf
:writers} initialization argument that was associated with the direct slot
definition metaobject during initialization.

\Defmeth {slot-definition-readers}
         {({\it direct-slot-definition\/} standard-direct-slot-definition)}
\Defmeth {slot-definition-writers}
         {({\it direct-slot-definition\/} standard-direct-slot-definition)}

No behavior is specified for these methods beyond what is specified for their
generic functions.

\vskip1.9pc                % Don't take this out without arranging somehow for
                           % the layout to still suggest the grouping of sets
                           % of methods.

\Effectivelabel

The following reader generic function is defined for effective slot definition
metaobjects.

\Defgeni {slot-definition-location} {effective-slot-definition}

Returns the location of {\it effective-slot-definition}.  The meaning and
interpretation of this value is described in the section called ``Instance
Structure Protocol.''

\Defmeth {slot-definition-location}
         {({\it effective-slot-definition\/} standard-effective-slot-definition)}

This method returns the value stored by
\aroundmethod{compute-slots}{standard-class} and
\aroundmethod{compute-slots}{funcallable-standard-class}.

\endcom

\begingfcom{reader-method-class}

\Syntaxlabel

\Defgen {reader-method-class} {class direct-slot {\rest} {\it initargs\/}}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

The {\it direct-slot\/} argument is a direct slot definition metaobject.

The {\it initargs\/} argument consists of alternating initialization argument
names and values.

\Valueslabel

The value returned is a class metaobject.

\Purposelabel

This generic function is called to determine the class of reader methods
created during class initialization and reinitialization.  The result must be
a subclass of {\bf standard-reader-method}.

The {\it initargs\/} argument must be the same as will be passed to {\bf
make-instance} to create the reader method.  The {\it initargs\/} must include
{\bf :slot-definition} with {\it slot-definition\/} as its value.

\Methodslabel

\Defmeth {reader-method-class}
               {{({\it class\/} standard-class)\\
                 ({\it direct-slot\/} standard-direct-slot-definition)\\
                 {\rest} {\it initargs}}}

\Defmeth {reader-method-class}
               {{({\it class\/} funcallable-standard-class)\\
                 ({\it direct-slot\/} standard-direct-slot-definition)\\
                 {\rest} {\it initargs}}}

These methods return the class {\bf standard-reader-method}. These methods can
be overridden.

\endcom

\begingfcom{remove-dependent}

\Syntaxlabel

\Defgen {remove-dependent} {metaobject dependent}

\Argumentslabel

The {\it metaobject\/} argument is a class or generic function metaobject.

The {\it dependent\/} argument is an object.

\Valueslabel

The value returned by this generic function is unspecified.

\Purposelabel

This generic function removes {\it dependent\/} from the dependents of {\it
metaobject}.  If {\it dependent\/} is not one of the dependents of {\it
metaobject}, no error is signaled.

The generic function {\bf map-dependents} can be called to access the set of
dependents of a class or generic function.  The generic function {\bf
add-dependent} can be called to add an object from the set of dependents of a
class or generic function.  The effect of calling {\bf add-dependent} or {\bf
remove-dependent} while a call to {\bf map-dependents} on the same class or
generic function is in progress is unspecified.

The situations in which {\bf remove-dependent} is called are not specified.

\Methodslabel

\Defmeth {remove-dependent}
         {({\it class\/\/} standard-class) {\it dependent\/}}

No behavior is specified for this method beyond that which is specified for
the generic function.

This method cannot be overridden unless the following methods are overridden
as well:

\begin{methods}
\method{add-dependent}{standard-class t}\\
\method{map-dependents}{standard-class t}
\end{methods}

\Defmeth {remove-dependent}
         {({\it class\/\/} funcallable-standard-class) {\it dependent\/}}

No behavior is specified for this method beyond that which is specified for
the generic function.

This method cannot be overridden unless the following methods are overridden
as well:

\begin{methods}
\method{add-dependent}{funcallable-standard-class t}\\
\method{map-dependents}{funcallable-standard-class t}
\end{methods}

\Defmeth {remove-dependent} {({\it generic-function\/} standard-generic-function) {\it dependent\/}}

No behavior is specified for this method beyond that which is specified for
the generic function.

This method cannot be overridden unless the following methods are
overridden as well:

\begin{methods}
\method{add-dependent}{standard-generic-function t}\\
\method{map-dependents}{standard-generic-function t}
\end{methods}

\Remarkslabel

See the ``Dependent Maintenance Protocol'' section for remarks about the use
of this facility.

\endcom

\begingfcom{remove-direct-method}

\Syntaxlabel

\Defgen {remove-direct-method} {specializer method}

\Argumentslabel

The {\it specializer\/} argument is a specializer metaobject.

The {\it method\/} argument is a method metaobject.

\Valueslabel

The value returned by {\bf remove-direct-method} is unspecified.

\Purposelabel

This generic function is called to maintain a set of backpointers from a
specializer to the set of methods specialized to it.  If {\it method\/} is in
the set it is removed.  If it is not, no error is signaled.

This set can be accessed as a list by calling the generic function {\bf
specializer-direct-methods}.  Methods are added to the set by {\bf
add-direct-method}.

The generic function {\bf remove-direct-method} is called by {\bf
remove-method} whenever a method is removed from a generic function.  It is
called once for each of the specializers of the method.  Note that in cases
where a specializer appears more than once in the specializers of a method,
this generic function will be called more than once with the same specializer
as argument.

The results are undefined if the {\it specializer\/} argument is not one of the
specializers of the {\it method\/} argument.

\Methodslabel

\Defmeth {remove-direct-method} {     {({\it specializer\/} class)\\
                                       ({\it method\/} method)}}

This method implements the behavior of the generic function for class
specializers.  No behavior is specified for this method beyond that which is
specified for the generic function.

This method cannot be overridden unless the following methods are
overridden as well:

\begin{methods}
\method{add-direct-method}{class method}\\
\method{specializer-direct-generic-functions}{class}\\
\method{specializer-direct-methods}{class}
\end{methods}

\Defmeth {remove-direct-method} {     {({\it specializer\/} eql-specializer)\\
                                       ({\it method\/} method)}}

This method implements the behavior of the generic function for {\bf eql}
specializers.  No behavior is specified for this method beyond that which is
specified for the generic function.

\endcom

\begingfcom{remove-direct-subclass}

\Syntaxlabel

\Defgen {remove-direct-subclass} {superclass subclass}

\Argumentslabel

The {\it superclass\/} argument is a class metaobject.

The {\it subclass\/} argument is a class metaobject.

\Valueslabel

The value returned by this generic function is unspecified.

\Purposelabel

This generic function is called to maintain a set of backpointers from a class
to its direct subclasses.  It removes {\it subclass\/} from the set of direct
subclasses of {\it superclass}.  No error is signaled if {\it subclass\/} is
not in this set.

Whenever a class is reinitialized, this generic function is called once with
each deleted direct superclass of the class.

\Methodslabel

\Defmeth {remove-direct-subclass} {  {({\it superclass\/} class)\\
                                      ({\it subclass\/} class)}}

No behavior is specified for this method beyond that which is specified for
the generic function.

This method cannot be overridden unless the following methods are overridden
as well:

\begin{methods}
\method{add-direct-subclass}{class class}\\
\method{class-direct-subclasses}{class}
\end{methods}

\endcom

\begingfcom{remove-method}

\Syntaxlabel

\Defgen {remove-method} {generic-function method}

\Argumentslabel

The {\it generic-function\/} argument is a generic function metaobject.

The {\it method\/} argument is a method metaobject.

\Valueslabel

The {\it generic-function\/} argument is returned.

\Purposelabel

This generic function breaks the association between a generic function and
one of its methods.

No error is signaled if the method is not among the methods of the generic
function.

Breaking the association between the method and the generic function proceeds
in four steps:  (i) remove {\it method\/} from the set returned by {\bf
generic-function-methods} and arrange for {\bf method-generic-function} to
return &nil;; (ii) call {\bf remove-direct-method} for each of the
method's specializers; (iii) call {\bf compute-discriminating-function} and
install its result with {\bf set-funcallable-instance-function}; and (iv)
update the dependents of the generic function.

The generic function {\bf remove-method} can be called by the user or the
implementation.

\Methodslabel

\Defmeth {remove-method}
         {     {({\it generic-function\/} standard-generic-function)\\
                ({\it method\/} standard-method)}}

No behavior is specified for this method beyond that which is specified for
the generic function.

\endcom

\beginfncom{set-funcallable-instance-function}

\Syntaxlabel

\Defun {set-funcallable-instance-function} {funcallable-instance function}

\Argumentslabel

The {\it funcallable-instance\/} argument is a funcallable instance (it must
have been returned by \method{allocate-instance}{funcallable-standard-class}).

The {\it function\/} argument is a function.

\Valueslabel

The value returned by this function is unspecified.

\Purposelabel

This function is called to set or to change the function of a funcallable
instance.  After {\bf set-funcallable-instance-function} is called, any
subsequent calls to {\it funcallable-instance\/} will run the new function.

\endcom

\beginfncom{(setf class-name)}

\Syntaxlabel

\Defgen {(setf class-name)} {new-name class}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

The {\it new-name\/} argument is any Lisp object.

\Resultslabel

This function returns its {\it new-name\/} argument.

\Purposelabel

This function changes the name of {\it class\/} to {\it new-name\/}.  This value
is usually a symbol, or &nil; if the class has no name.

This function works by calling {\bf reinitialize-instance} with {\it class\/} as
its first argument, the symbol {\bf :name} as its second argument and {\it
new-name\/} as its third argument.

\endcom

\beginfncom{(setf generic-function-name)}

\Syntaxlabel

\Defgen {(setf generic-function-name)} {new-name generic-function}

\Argumentslabel

The {\it generic-function\/} argument is a generic function metaobject.

The {\it new-name\/} argument is a function name or &nil;.

\Resultslabel

This function returns its {\it new-name\/} argument.

\Purposelabel

This function changes the name of {\it generic-function\/} to {\it new-name}.
This value is usually a function name (i.e., a symbol or a list of the form
{\bf (setf {\it symbol\/})}) or &nil;, if the generic function is to have
no name.

This function works by calling {\bf reinitialize-instance} with {\it
generic-function\/} as its first argument, the symbol {\bf :name} as its second
argument and {\it new-name\/} as its third argument.

\endcom

\begingfcom{(setf slot-value-using-class)}

\Syntaxlabel

\Defgen {(setf slot-value-using-class)} {new-value class object slot}

\Argumentslabel

The {\it new-value\/} argument is an object.

The {\it class\/} argument is a class metaobject.  It is the class of the {\it
object\/} argument.

The {\it object\/} argument is an object.

The {\it slot\/} argument is an effective slot definition metaobject.

\Valueslabel

This generic function returns the {\it new-value\/} argument.

\Purposelabel

The generic function {\bf (setf slot-value-using-class)} implements the
behavior of the {\bf (setf slot-value)} function. It is called by {\bf (setf
slot-value)} with the class of {\it object\/} as its second argument and the
pertinent effective slot definition metaobject as its fourth argument.

The generic function {\bf (setf slot-value-using-class)} sets the value
contained in the given slot of the given object to the given new value; any
previous value is lost.

The results are undefined if the {\it class\/} argument is not the class of the
{\it object\/} argument, or if the {\it slot\/} argument does not appear among
the set of effective slots associated with the {\it class\/} argument.

\Methodslabel

\Defmeth {(setf slot-value-using-class)} { {{\it new-value}\\
                                            ({\it class\/} standard-class)\\
                                            {\it object\/}\\
                                            ({\it slot\/} standard-effective-slot-definition)}}

\Defmeth {(setf slot-value-using-class)} { {{\it new-value}\\
                                            ({\it class\/} funcallable-standard-class)\\
                                            {\it object\/}\\
                                            ({\it slot\/} standard-effective-slot-definition)}}

These methods implement the full behavior of this generic function for slots
with allocation {\bf :instance} and {\bf :class}.  If the supplied slot has an
allocation other than {\bf :instance} or {\bf :class} an error is signaled.

Overriding these methods is permitted, but may require overriding other
methods in the standard implementation of the slot access protocol.

\Defmeth {(setf slot-value-using-class)} { {{\it new-value}\\
                                            ({\it class\/} built-in-class)\\
                                            {\it object\/}\\
                                            {\it slot}}}

This method signals an error.

\endcom

\begingfcom{slot-boundp-using-class}

\Syntaxlabel

\Defgen {slot-boundp-using-class} {class object slot}

\Argumentslabel

The {\it class\/} argument is a class metaobject.  It is the class of the {\it
object\/} argument.

The {\it object\/} argument is an object.

The {\it slot\/} argument is an effective slot definition metaobject.

\Valueslabel

This generic function returns true or false.

\Purposelabel

This generic function implements the behavior of the {\bf slot-boundp}
function.  It is called by {\bf slot-boundp} with the class of {\it object\/} as
its first argument and the pertinent effective slot definition metaobject as
its third argument.

The generic function {\bf slot-boundp-using-class} tests whether a specific
slot in an instance is bound.

The results are undefined if the {\it class\/} argument is not the class of the
{\it object\/} argument, or if the {\it slot\/} argument does not appear among
the set of effective slots associated with the {\it class\/} argument.

\Methodslabel

\Defmeth {slot-boundp-using-class} {{({\it class\/} standard-class)\\
                                     {\it object\/}\\
                                     ({\it slot\/} standard-effective-slot-definition)}}

\Defmeth {slot-boundp-using-class} {{({\it class\/} funcallable-standard-class)\\
                                     {\it object\/}\\
                                     ({\it slot\/} standard-effective-slot-definition)}}

These methods implement the full behavior of this generic function for slots
with allocation {\bf :instance} and {\bf :class}.  If the supplied slot has an
allocation other than {\bf :instance} or {\bf :class} an error is signaled.

Overriding these methods is permitted, but may require overriding other
methods in the standard implementation of the slot access protocol.

\Defmeth {slot-boundp-using-class} {{({\it class\/} built-in-class)\\
                                     {\it object\/}\\
                                     {\it slot}}}

This method signals an error.

\Remarkslabel

In cases where the class metaobject class does not distinguish unbound slots,
true should be returned.

\endcom

\begincom{slot-definition-\dots}\ftype{Generic Function}

{The following generic functions are described together under ``Readers for
Slot Definition Metaobjects'' (page~\pageref{slotd-mo-readers}): {\bf
slot-definition-allocation}, {\bf slot-definition-initargs}, {\bf
slot-definition-initform}, {\bf slot-definition-initfunction}, {\bf
slot-definition-location}, {\bf slot-definition-name}, {\bf
slot-definition-readers}, {\bf slot-definition-writers} and {\bf
slot-definition-type}.\tolerant\tolerant\tolerant\par}

\endcom

\begingfcom{slot-makunbound-using-class}

\Syntaxlabel

\Defgen {slot-makunbound-using-class} {class object slot}

\Argumentslabel

The {\it class\/} argument is a class metaobject.  It is the class of the {\it
object\/} argument.

The {\it object\/} argument is an object.

The {\it slot\/} argument is an effective slot definition metaobject.

\Valueslabel

This generic function returns its {\it object\/} argument.

\Purposelabel

This generic function implements the behavior of the {\bf slot-makunbound}
function.  It is called by {\bf slot-makunbound} with the class of {\it
object\/} as its first argument and the pertinent effective slot definition
metaobject as its third argument.

The generic function {\bf slot-makunbound-using-class} restores a slot in an
object to its unbound state.  The interpretation of ``restoring a slot to
its unbound state'' depends on the class metaobject class.

The results are undefined if the {\it class\/} argument is not the class of the
{\it object\/} argument, or if the {\it slot\/} argument does not appear among the
set of effective slots associated with the {\it class\/} argument.

\Methodslabel

\Defmeth {slot-makunbound-using-class}
          {     {({\it class\/} standard-class)\\
                {\it object\/}\\
                ({\it slot\/} standard-effective-slot-definition)}}



\Defmeth {slot-makunbound-using-class}
          {     {({\it class\/} funcallable-standard-class)\\
                {\it object\/}\\
                ({\it slot\/} standard-effective-slot-definition)}}

These methods implement the full behavior of this generic function for slots
with allocation {\bf :instance} and {\bf :class}.  If the supplied slot has an
allocation other than {\bf :instance} or {\bf :class} an error is signaled.

Overriding these methods is permitted, but may require overriding other
methods in the standard implementation of the slot access protocol.

\Defmeth {slot-makunbound-using-class} {     {({\it class\/} built-in-class)\\
                                              {\it object\/}\\
                                              {\it slot}}}

This method signals an error.

\endcom

\begingfcom{slot-value-using-class}

\Syntaxlabel

\Defgen {slot-value-using-class} {class object slot}

\Argumentslabel

The {\it class\/} argument is a class metaobject.  It is the class of the {\it
object\/} argument.

The {\it object\/} argument is an object.

The {\it slot\/} argument is an effective slot definition metaobject.

\Valueslabel

The value returned by this generic function is an object.

\Purposelabel

This generic function implements the behavior of the {\bf slot-value}
function.  It is called by {\bf slot-value} with the class of {\it object\/} as
its first argument and the pertinent effective slot definition metaobject as
its third argument.

The generic function {\bf slot-value-using-class} returns the value contained
in the given slot of the given object.  If the slot is unbound {\bf
slot-unbound} is called.

The results are undefined if the {\it class\/} argument is not the class of the
{\it object\/} argument, or if the {\it slot\/} argument does not appear among
the set of effective slots associated with the {\it class\/} argument.

\Methodslabel

\Defmeth {slot-value-using-class} {     {({\it class\/} standard-class)\\
                                         {\it object\/}\\
                                         ({\it slot\/} standard-effective-slot-definition)}}

\Defmeth {slot-value-using-class} {     {({\it class\/} funcallable-standard-class)\\
                                         {\it object\/}\\
                                         ({\it slot\/} standard-effective-slot-definition)}}

These methods implement the full behavior of this generic function for slots
with allocation {\bf :instance} and {\bf :class}.  If the supplied slot has an
allocation other than {\bf :instance} or {\bf :class} an error is signaled.

Overriding these methods is permitted, but may require overriding other
methods in the standard implementation of the slot access protocol.

\Defmeth {slot-value-using-class} {     {({\it class\/} built-in-class)\\
                                         {\it object\/}\\
                                         {\it slot}}}

This method signals an error.

\endcom

\begingfcom{specializer-direct-generic-functions}

\Syntaxlabel

\Defgen {specializer-direct-generic-functions} {specializer}

\Argumentslabel

The {\it specializer\/} argument is a specializer metaobject.

\Valueslabel

The result of this generic function is a possibly empty list of generic
function metaobjects.

\Purposelabel

This generic function returns the possibly empty set of those generic functions
which have a method with {\it specializer\/} as a specializer.  The elements of
this set are generic function metaobjects.  This value is maintained by the
generic functions {\bf add-direct-method} and {\bf remove-direct-method}.

\Methodslabel

\Defmeth {specializer-direct-generic-functions} {({\it specializer\/} class)}

No behavior is specified for this method beyond that which is specified for
the generic function.

This method cannot be overridden unless the following methods are overridden as
well:

\begin{methods}
\method{add-direct-method}{class method}\\
\method{remove-direct-method}{class method}\\
\method{specializer-direct-methods}{class}
\end{methods}

\Defmeth {specializer-direct-generic-functions} {({\it specializer\/} eql-specializer)}

No behavior is specified for this method beyond that which is specified for
the generic function.

\endcom

\begingfcom{specializer-direct-methods}

\Syntaxlabel

\Defgen {specializer-direct-methods} {specializer}

\Argumentslabel

The {\it specializer\/} argument is a specializer metaobject.

\Valueslabel

The result of this generic function is a possibly empty list of method
metaobjects.

\Purposelabel

This generic function returns the possibly empty set of those methods,
connected to generic functions, which have {\it specializer\/} as a specializer.
The elements of this set are method metaobjects.  This value is maintained by
the generic functions {\bf add-direct-method} and {\bf remove-direct-method}.

\Methodslabel

\Defmeth {specializer-direct-methods} {({\it specializer\/} class)}

No behavior is specified for this method beyond that which is specified for
the generic function.

This method cannot be overridden unless the following methods are overridden as
well:

\begin{methods}
\method{add-direct-method}{class method}\\
\method{remove-direct-method}{class method}\\
\method{specializer-direct-generic-functions}{class}
\end{methods}

\Defmeth {specializer-direct-methods} {({\it specializer\/} eql-specializer)}

No behavior is specified for this method beyond that which is specified for
the generic function.

\endcom

\beginfncom{standard-instance-access}

\Syntaxlabel

\Defun {standard-instance-access} {instance location}

\Argumentslabel

The {\it instance\/} argument is an object.

The {\it location\/} argument is a slot location.

\Valueslabel

The result of this function is an object.

\Purposelabel

This function is called to provide direct access to a slot in an instance.  By
usurping the normal slot lookup protocol, this function is intended to provide
highly optimized access to the slots associated with an instance.

The following restrictions apply to the use of this function:

<itemizedlist>
\item The {\it instance\/} argument must be a standard instance (it must have
been returned by \method{allocate-instance}{standard-class}).

\item The {\it instance\/} argument cannot be an non-updated obsolete instance.

\item The {\it location\/} argument must be a location of one of the directly
accessible slots of the instance's class.

\item The slot must be bound.
</itemizedlist>

The results are undefined if any of these restrictions are not met.

\endcom

\begingfcom{update-dependent}

\Syntaxlabel

\Defgen {update-dependent} {metaobject dependent {\tt {\rest} {\it initargs}}}

\Argumentslabel

The {\it metaobject\/} argument is a class or generic function metaobject.  It
is the metaobject being reinitialized or otherwise modified.

The {\it dependent\/} argument is an object.  It is the dependent being updated.

The {\it initargs\/} argument is a list of the initialization arguments for
the metaobject redefinition.

\Valueslabel

The value returned by {\bf update-dependent} is unspecified.

\Purposelabel

This generic function is called to update a dependent of {\it metaobject}.

When a class or a generic function is reinitialized each of its dependents is
updated.  The {\it initargs\/} argument to {\bf update-dependent} is the set of
initialization arguments received by {\bf reinitialize-instance}.

When a method is added to a generic function, each of the generic function's
dependents is updated.  The {\it initargs\/} argument is a list of two elements:
the symbol &add-method;, and the method that was added.

When a method is removed from a generic function, each of the generic
function's dependents is updated.  The {\it initargs\/} argument is a list of
two elements:  the symbol {\bf remove-method}, and the method that was
removed.

In each case, {\bf map-dependents} is used to call {\bf update-dependent} on
each of the dependents.  So, for example, the update of a generic function's
dependents when a method is added could be performed by the following code:

\begin{lispcode}
  (map-dependents\em generic-function\tt
                  #'(lambda (dep)
                      (update-dependent\em generic-function\tt
                                        dep
                                        'add-method
                                       \em new-method\tt)))
\end{lispcode}

\Methodslabel

There are no specified methods on this generic function.

\Remarkslabel

See the ``Dependent Maintenance Protocol'' section for remarks about the use
of this facility.

\endcom

\begingfcom{validate-superclass}

\Syntaxlabel

\Defgen {validate-superclass} {class superclass}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

The {\it superclass\/} argument is a class metaobject.

\Valueslabel

This generic function returns true or false.

\Purposelabel

This generic function is called to determine whether the class {\it
superclass\/} is suitable for use as a superclass of {\it class}.

This generic function can be be called by the implementation or user code.  It
is called during class metaobject initialization and reinitialization, before
the direct superclasses are stored.  If this generic function returns false,
the initialization or reinitialization will signal an error.

\Methodslabel

\Defmeth {validate-superclass} {     {({\it class\/} class)\\
                                      ({\it superclass\/} class)}}

This method returns true in three situations:

\begin{unlabeled}

\item (i) If the {\it superclass\/} argument is the class named {\tt t},

\item (ii) if the class of the {\it class\/} argument is the same as the class
of the {\it superclass\/} argument or

\item (iii) if the classes one of the arguments is {\bf standard-class} and
the class of the other is {\bf funcallable-standard-class}.

\end{unlabeled}

\noindent In all other cases, this method returns false.

This method can be overridden.

\Remarkslabel

Defining a method on {\bf validate-superclass} requires detailed knowledge of
of the internal protocol followed by each of the two class metaobject classes.
A method on {\bf validate-superclass} which returns true for two different
class metaobject classes declares that they are compatible.

\endcom

\begingfcom{writer-method-class}

\Syntaxlabel

\Defgen {writer-method-class} {class direct-slot {\rest} {\it initargs\/}}

\Argumentslabel

The {\it class\/} argument is a class metaobject.

The {\it direct-slot\/} argument is a direct slot definition metaobject.

The {\it initargs\/} argument is a list of initialization arguments and
values.

\Valueslabel

The value returned is a class metaobject.

\Purposelabel

This generic function is called to determine the class of writer methods
created during class initialization and reinitialization.  The result must be
a subclass of {\bf standard-writer-method}.

The {\it initargs\/} argument must be the same as will be passed to {\bf
make-instance} to create the reader method.  The {\it initargs\/} must include
{\bf :slot-definition} with {\it slot-definition\/} as its value.

\Methodslabel

\Defmeth {writer-method-class}
               {{({\it class\/} standard-class)\\
                 ({\it direct-slot\/} standard-direct-slot-definition)\\
                 {\rest} {\it initargs}}}

\Defmeth {writer-method-class}
               {{({\it class\/} funcallable-standard-class)\\
                 ({\it direct-slot\/} standard-direct-slot-definition)\\
                 {\rest} {\it initargs}}}

These methods returns the class {\bf standard-writer-method}.  These methods
can be overridden.

\endcom

\clearpage
\pagestyle{headings}

</section>
</chapter>
