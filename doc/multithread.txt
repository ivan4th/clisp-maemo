                              Multithreading
                              ==============

is currently being developed and does not work yet.
Current status is described at the end of the file.

General principles
------------------

* Parallelizability Principle:

  Simple formulation:
    "A program that was developed for a single-threaded world and which shares
     no application objects with programs running in other threads must run
     fine, without problems."

  Extended formulation:
    "If, in a single-threaded world, execution of program A before program B
     produces semantically the same results as execution of program B before
     program A, then in a multithreaded world, it is possible to run A and B
     simultaneously in different threads, and the result will be the same as
     in the two single-threaded cases (A before B, or B before A)."
  That's what the users ultimately want.
  - If A and B have no objects in common, then the implementation ensures by
    itself that the principle is fulfilled.
  - If A and B shared some objects, the implementation allows the programs
    to satisfy the principle with little effort.

Installation
------------

In the Makefile, define in the CFLAGS the symbol MULTITHREAD and one of
the symbols POSIX_THREADS, SOLARIS_THREADS, WIN32_THREADS.
(See xthread.d about their meaning.)
Alternatively, you can pass "--with-threads=flavor" to the top-level
configure ("flavor" is one of POSIX_THREADS, SOLARIS_THREADS, WIN32_THREADS).

Symbol values
-------------

Any symbol can be in one of five states:

  - Global Variable. This means that SYMBOL-VALUE of the symbol accesses
    the same value cell for all threads.

  - Global Constant. This is the same as Global Variable, except that the
    value cell cannot be modified. And the compiler can optimize this kind
    of symbols.

  - Per-Thread Variable. This means that every thread has its private value
    cell which is accessed by SYMBOL-VALUE. LET/LET*/MULTIPLE-VALUE-BIND
    bindings of the variable will affect the lexical environment only, not
    the value cell, unless the variable is locally declared SPECIAL.

  - Per-Thread Special Variable. This means that every thread has its private
    value cell which is accessed by SYMBOL-VALUE. LET/LET*/MULTIPLE-VALUE-BIND
    bindings of the variable will affect this value cell.

  - Lazy. This is the initial state of the symbol. It lasts until
      - a DEFGLOBAL or DEFCONSTANT declaration for the symbol is evaluated,
        in which case the symbol becomes a Global Variable or a Global Constant,
    or
      - a SPECIAL proclamation for the symbol is evaluated,
        in which case the symbol becomes a Per-Thread Special Variable,
    or
      - a SYMBOL-VALUE reference for the symbol is evaluated,
        in which case the symbol becomes a Per-Thread Variable.

Once a symbol is Global or Per-Thread, this cannot change any more.
However, a Global Variable can become a Global Constant (by means of a
DEFCONSTANT declaration), and a Per-Thread Variable can become a
Per-Thread Special Variable (by means of a SPECIAL proclamation).

The Common Lisp standard variables are all Per-Thread, except *features* and
*modules*, which are Global.


Packages
--------

PACKAGE objects are LOCKABLE and are locked by INTERN before adding a
symbol (if FIND-SYMBOL fails).
(This is a consequence of the Parallelizability Principle.)
This puts an unknown speed penalty on READ and therefore LOAD.

CLOS
----

DEFCLASS, DEFGENERIC, DEFMETHOD, DEFSTRUCT must get a global "DEF-CLOS"
lock because they change the global class hierarchy.
(This is a consequence of the Parallelizability Principle.)

Hash Tables and Sequences
-------------------------

Nothing is ever locked, so the user is required to use locks when
sharing HASH-TABLEs and SEQUENCEs between threads.
If two threads evaluate
   (INCF (GETHASH x global-ht 0)),
the results are undefined.
-- But this doesn't allow the programmer to fulfill the Parallelizability
   Principle easily.
     Program PRELUDE: (defparameter global-ht (make-hash-table))
     Program A: (setf (gethash 'a global-ht) 'aaaa)
     Program B: (setf (gethash 'b global-ht) 'bbbb)
   The Parallelizability Principle implies that one should
   have an easy way to declare that global-ht is shared, without modifying
   the programs A and B. The obvious proposal is a change in the PRELUDE:
        (defparameter global-ht (make-hash-table :lockable t))
   While this automatic locking will indeed work when no keys are shared,
   this is not a universal solution:
     Program A: (incf (gethash 10 global-ht 0))
     Program B: (incf (gethash 10 global-ht 0))
   It is possible that both GETHASH calls will happen before both
   PUTHASH calls unless both INCF forms are guarded with a lock.
   Instead of making GLOBAL-HT an instance of LOCK (and relying on some
   magic which cannot always work), one needs to create an explicit lock with
        (defparameter global-ht-lock (ext:make-lock))
   and wrap all his GLOBAL-HT accesses with
        (with-lock (global-ht-lock)
          (incf (gethash 'a global-ht 0)))
   The bottom line is: programs that use global variables do not fall
   under the Parallelizability Principle because they share application
   objects with programs running in other threads.
--
Automatic locking will impose an unjustifiable penalty on HASH-TABLEs
and SEQUENCEs local to threads.
It is also consistent with the usual Common Lisp approach of
   http://www.lisp.org/HyperSpec/Body/sec_3-6.html:
        The consequences are undefined when code executed during an
        object-traversing operation destructively modifies the object in
        a way that might affect the ongoing traversal operation...
   http://www.lisp.org/HyperSpec/Body/sec_18-1-2.html
        If an object O1 is used as a key in a hash table H and is then
        visibly modified with regard to the equivalence test of H, then
        the consequences are unspecified if O1 is used as a key in
        further operations on H...
I.e., if you want to shoot yourself, it is YOUR responsibility to wear armor.

Garbage Collector
-----------------

GC must stop all other threads while it is executing.
CLISP has a copying GC, so anything else would require a write barrier
during the scan phase and a read barrier during the move phase.

C variables of type "object" are invalidated by GC, so the code that
uses such variables must be surrounded with NO-GC locks.
Actually, even gcv_object_t is not safe here:
          ThePackage(STACK_0)->pack_name = ...
When STACK_0 is already dereferenced and converted to a Package, but
before the assignment occurs, GC should be banned.
Looks like any C code that manipulates Lisp objects must lock GC.
Also, begin_system_call() should release the lock and end_system_call()
should re-acquire the lock (so that blocking system calls do not block
other threads that need to GC), thus all system calls now "maygc".

--------------------------------------------------------------------------
CURRENT STATUS
--------------------------------------------------------------------------
1. Installation.
Currently only POSIX_THREADS are tested and all development is done with them.
There is code for Win32 and Solaris threads -
however it is not clear whether it even compiles.

2. MAKE-THREAD - the "mother" of (almost) all threads.
(MAKE-THREAD function
             &key name
             (initial-bindings THREADS:*DEFAULT-SPECIAL-BINDINGS*)
             (cstack-size THREADS::*DEFAULT-CONTROL-STACK-SIZE*)
             (vstack-size THREADS::*DEFAULT-VALUE-STACK-SIZE*))
Parameters:
function and name - required and obvious.
:initial-bindings - see below
:cstack-size - the size in bytes of the control stack (C stack)
               if passed 0 whatever the OS decides for it.
:vstack-size - the size of the LISP stack in gcv_object_t.
               Default value is calculated based on the -m option
               used when CLISP was started (hmm am i right)?
               If passed 0 - the value stack will be the same
               as the calling thread's.

3. Symbol values - ready.
The implementation follows the explanation above. For a good description see:
http://www.franz.com/support/documentation/current/doc/multiprocessing.htm#dynamic-environments-1

Basically every special symbol has a "global" value that can be shared
between all threads. However if a thread binds the symbol - per thread
cell will be allocated for it and in the scope of this binding the
thread will see this cell. For example:

(defvar *global* 1)

(defun thread-1 ()
  (setq *global* 5) ;; changes the global symbol value
  (let ((*global* 10)) ;; per thread value cell is allocated and initialized
    (setq *global* 20) ;; per thread value cell is changed.
    ;; global value cell is no accessible at all here
    )
  (setq *global* 30)) ; global value cell is modified again

MAKE-THREAD accepts keyword parameter :INITIAL-BINDINGS - an alist of
(symbol . form). The forms are EVALed in the context of the new thread
and symbols are bound to the result - in the thread.

Function (THREADS:SYMBOL-VALUE-THREAD symbol thread) can be used to
obtain or set the per thread value of symbol. Returns two values - the
symbol binding and BOUND-P boolean (like GETHASH). If "thread" is T -
current thread is assumed.  If "thread" is NIL - the global binding is
returned.

TODO:
 savemem/loadmem - per thread binding are lost (and the threads are not
 re-created when an image is loaded anyway). Not sure that something
 special should be done here.

4. Packages & CLOS locks - not ready (not worked at all on it)
spinlock with GC safe point will be used.

5. Garbage Collector
GC stops all threads in order to execute.

Heap objects may be "pinned" - they will not move during GC.
Used when execution is blocked in foreign/system call and
pointer to heap object is passed in non-lisp land.
The GC tries to minimize the wholes in the heap introduced
by the "pinning" process.

The threads may be stopped only at certain safe points.
Currently implemented safe points are:
5.1. Any heap allocation (actually before the allocations itself).
5.2. Some "possibly blocking" system call.
     Basically every thread that "conses" or can block in system call will not
     stop the GC from executing.

TO BE DONE:
a) Not all "possibly blocking" calls are marked as safe (currently all
   stream operations).
b) Certain functions that do not cons but may go in infinite loop
   (length of circular list for example).

6. Signal handling (POSIX - no Win32)

Synchronous signals (SIGSEGV,SIGPIPE) are handled in the threads that
caused them (after all they are synchronous).
Asynchronous signals (SIGINT,SIGTERM,SIGHUP,etc) are handled synchronously
(nice oxymoron - they are asynchronous:)).
After initialization of the heap - new thread is spawned for the main REPL.
The "main thread" (where main() is executed) goes into infinite signal
handling loop (via sigwait()) and does not deal with lisp heap/object
at all (almost - just prepares the stack for SIG_THREAD_INTERRUPT).
Thread can be interrupted by sending SIG_THREAD_INTERRUPT (SIGUSR1) to it.
There are special requirement when sending this signal:
  1. LISP stack should contain info what to execute.
  2. The thread should be in GC safe location.

TODO:
SIGCLD needs special attention - currently it may not to work
as expected.

7. THREAD package exported functions
Currently no locks are exposed through MT package - so it is good time
to practice lock-free multithreading :).

The usable functions from MT currently are:
MAKE-THREAD, CURRENT-THREAD, LIST-THREADS, THREADP, THREAD-ACTIVE-P,
THREAD-INTERRUPT, THREAD-KILL, THREAD-YIELD, THREAD-NAME, SYMBOL-VALUE-THREAD

Some docs on them will be helpful (and will come shortly :))


